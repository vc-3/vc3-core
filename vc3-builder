#! /usr/bin/env perl
#
# This is an automatically generated file. Do not modify! All changes
# should go into vc3-builder-bare and the modules in VC3.
#
# Copyright (C) 2016- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.
# 

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
CWD

$fatpacked{"Digest/Perl/MD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIGEST_PERL_MD5';
  package Digest::Perl::MD5;
  use strict;
  use integer;
  use Exporter;
  use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);
  
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  @ISA = 'Exporter';
  $VERSION = '1.9';
  
  # I-Vektor
  sub A() { 0x67_45_23_01 }
  sub B() { 0xef_cd_ab_89 }
  sub C() { 0x98_ba_dc_fe }
  sub D() { 0x10_32_54_76 }
  
  # for internal use
  sub MAX() { 0xFFFFFFFF }
  
  # pad a message to a multiple of 64
  sub padding {
      my $l = length (my $msg = shift() . chr(128));    
      $msg .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  }
  
  
  sub rotate_left($$) {
  	#$_[0] << $_[1] | $_[0] >> (32 - $_[1]);
  	#my $right = $_[0] >> (32 - $_[1]);
  	#my $rmask = (1 << $_[1]) - 1;
  	($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));
  	#$_[0] << $_[1] | (($_[0]>> (32 - $_[1])) & (1 << (32 - $_[1])) - 1);
  }
  
  sub gen_code {
    # Discard upper 32 bits on 64 bit archs.
    my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';
  #	FF => "X0=rotate_left(((X1&X2)|(~X1&X3))+X0+X4+X6$MSK,X5)+X1$MSK;",
  #	GG => "X0=rotate_left(((X1&X3)|(X2&(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    my %f = (
  	FF => "X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	GG => "X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	HH => "X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",
  	II => "X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    );
    #unless ( (1 << 16) << 16) { %f = %{$CODES{'32bit'}} }
    #else { %f = %{$CODES{'64bit'}} }
  
    my %s = (  # shift lengths
  	S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,
  	S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,
  	S43 => 15, S44 => 21
    );
  
    my $insert = "\n";
    while(defined( my $data = <DATA> )) {
  	chomp $data;
  	next unless $data =~ /^[FGHI]/;
  	my ($func,@x) = split /,/, $data;
  	my $c = $f{$func};
  	$c =~ s/X(\d)/$x[$1]/g;
  	$c =~ s/(S\d{2})/$s{$1}/;
  	$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;
  
  	my $su = 32 - $3;
  	my $sh = (1 << $3) - 1;
  
  	$c = "$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";
  
  	#my $rotate = "(($2 << $3) || (($2 >> (32 - $3)) & (1 << $2) - 1)))"; 
  	# $c = "\$r = $2;
  	# $1 = ((\$r << $3) | ((\$r >> (32 - $3))  & ((1 << $3) - 1))) + $4";
  	$insert .= "\t$c\n";
    }
    close DATA;
    
    my $dump = '
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' . $insert . '
  	$_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK . 
          ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';
    }';
    eval $dump;
    # print "$dump\n";
    # exit 0;
  }
  
  gen_code();
  
  #########################################
  # Private output converter functions:
  sub _encode_hex { unpack 'H*', $_[0] }
  sub _encode_base64 {
  	my $res;
  	while ($_[0] =~ /(.{1,45})/gs) {
  		$res .= substr pack('u', $1), 1;
  		chop $res;
  	}
  	$res =~ tr|` -_|AA-Za-z0-9+/|;#`
  	chop $res; chop $res;
  	$res
  }
  
  #########################################
  # OOP interface:
  sub new {
  	my $proto = shift;
  	my $class = ref $proto || $proto;
  	my $self = {};
  	bless $self, $class;
  	$self->reset();
  	$self
  }
  
  sub reset {
  	my $self = shift;
  	delete $self->{_data};
  	$self->{_state} = [A,B,C,D];
  	$self->{_length} = 0;
  	$self
  }
  
  sub add {
  	my $self = shift;
  	$self->{_data} .= join '', @_ if @_;
  	my ($i,$c);
  	for $i (0 .. (length $self->{_data})/64-1) {
  		my @X = unpack 'V16', substr $self->{_data}, $i*64, 64;
  		@{$self->{_state}} = round(@{$self->{_state}},@X);
  		++$c;
  	}
  	if ($c) {
  		substr ($self->{_data}, 0, $c*64) = '';
  		$self->{_length} += $c*64;
  	}
  	$self
  }
  
  sub finalize {
  	my $self = shift;
  	$self->{_data} .= chr(128);
      my $l = $self->{_length} + length $self->{_data};
      $self->{_data} .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $self->{_data} .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  	$self->add();
  	$self
  }
  
  sub addfile {
    	my ($self,$fh) = @_;
  	if (!ref($fh) && ref(\$fh) ne "GLOB") {
  	    require Symbol;
  	    $fh = Symbol::qualify($fh, scalar caller);
  	}
  	# $self->{_data} .= do{local$/;<$fh>};
  	my $read = 0;
  	my $buffer = '';
  	$self->add($buffer) while $read = read $fh, $buffer, 8192;
  	die __PACKAGE__, " read failed: $!" unless defined $read;
  	$self
  }
  
  sub add_bits {
  	my $self = shift;
  	return $self->add( pack 'B*', shift ) if @_ == 1;
  	my ($b,$n) = @_;
  	die __PACKAGE__, " Invalid number of bits\n" if $n%8;
  	$self->add( substr $b, 0, $n/8 )
  }
  
  sub digest {
  	my $self = shift;
  	$self->finalize();
  	my $res = pack 'V4', @{$self->{_state}};
  	$self->reset();
  	$res
  }
  
  sub hexdigest {
  	_encode_hex($_[0]->digest)
  }
  
  sub b64digest {
  	_encode_base64($_[0]->digest)
  }
  
  sub clone {
  	my $self = shift;
  	my $clone = { 
  		_state => [@{$self->{_state}}],
  		_length => $self->{_length},
  		_data => $self->{_data}
  	};
  	bless $clone, ref $self || $self;
  }
  
  #########################################
  # Procedural interface:
  sub md5 {
  	my $message = padding(join'',@_);
  	my ($a,$b,$c,$d) = (A,B,C,D);
  	my $i;
  	for $i (0 .. (length $message)/64-1) {
  		my @X = unpack 'V16', substr $message,$i*64,64;	
  		($a,$b,$c,$d) = round($a,$b,$c,$d,@X);
  	}
  	pack 'V4',$a,$b,$c,$d;
  }
  sub md5_hex { _encode_hex &md5 } 
  sub md5_base64 { _encode_base64 &md5 }
  
  
  1;
  
  =head1 NAME
  
  Digest::MD5::Perl - Perl implementation of Ron Rivests MD5 Algorithm
  
  =head1 DISCLAIMER
  
  This is B<not> an interface (like C<Digest::MD5>) but a Perl implementation of MD5.
  It is written in perl only and because of this it is slow but it works without C-Code.
  You should use C<Digest::MD5> instead of this module if it is available.
  This module is only useful for
  
  =over 4
  
  =item
  
  computers where you cannot install C<Digest::MD5> (e.g. lack of a C-Compiler)
  
  =item
  
  encrypting only small amounts of data (less than one million bytes). I use it to
  hash passwords.
  
  =item
  
  educational purposes
  
  =back
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5  qw(md5 md5_hex md5_base64);
  
   $hash = md5 $data;
   $hash = md5_hex $data;
   $hash = md5_base64 $data;
      
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile(*FILE);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  This modules has the same interface as the much faster C<Digest::MD5>. So you can
  easily exchange them, e.g.
  
  	BEGIN {
  	  eval {
  	    require Digest::MD5;
  	    import Digest::MD5 'md5_hex'
  	  };
  	  if ($@) { # ups, no Digest::MD5
  	    require Digest::Perl::MD5;
  	    import Digest::Perl::MD5 'md5_hex'
  	  }		
  	}
  
  If the C<Digest::MD5> module is available it is used and if not you take
  C<Digest::Perl::MD5>.
  
  You can also install the Perl part of Digest::MD5 together with Digest::Perl::MD5
  and use Digest::MD5 as normal, it falls back to Digest::Perl::MD5 if it
  cannot load its object files.
  
  For a detailed Documentation see the C<Digest::MD5> module.
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::Perl::MD5 'md5_hex';
      print 'Digest is ', md5_hex('foobarbaz'), "\n";
  
  The above example would print out the message
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  provided that the implementation is working correctly.  The same
  checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  The digest methods are destructive. That means you can only call them
  once and the $md5 objects is reset after use. You can make a copy with clone:
  
  	$md5->clone->hexdigest
  
  =head1 LIMITATIONS
  
  This implementation of the MD5 algorithm has some limitations:
  
  =over 4
  
  =item
  
  It's slow, very slow. I've done my very best but Digest::MD5 is still about 100 times faster.
  You can only encrypt Data up to one million bytes in an acceptable time. But it's very useful
  for encrypting small amounts of data like passwords.
  
  =item
  
  You can only encrypt up to 2^32 bits = 512 MB on 32bit archs. But You should
  use C<Digest::MD5> for those amounts of data anyway.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest::MD5>
  
  L<md5(1)>
  
  RFC 1321
  
  tools/md5: a small BSD compatible md5 tool written in pure perl.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 2000 Christian Lackas, Imperia Software Solutions
   Copyright 1998-1999 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. The basic C code
  implementing the algorithm is derived from that in the RFC and is
  covered by the following copyright:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-1992, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original MD5 interface was written by Neil Winton
  (<N.Winton (at) axion.bt.co.uk>).
  
  C<Digest::MD5> was made by Gisle Aas <gisle (at) aas.no> (I took his Interface
  and part of the documentation).
  
  Thanks to Guido Flohr for his 'use integer'-hint.
  
  This release was made by Christian Lackas <delta (at) lackas.net>.
  
  =cut
  
  __DATA__
  FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

$fatpacked{"English.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENGLISH';
  package English;
  
  our $VERSION = '1.10';
  
  require Exporter;
  @ISA = qw(Exporter);
  
  =head1 NAME
  
  English - use nice English (or awk) names for ugly punctuation variables
  
  =head1 SYNOPSIS
  
      use English;
      use English qw( -no_match_vars ) ;  # Avoids regex performance
                                          # penalty in perl 5.16 and
                                          # earlier
      ...
      if ($ERRNO =~ /denied/) { ... }
  
  =head1 DESCRIPTION
  
  This module provides aliases for the built-in variables whose
  names no one seems to like to read.  Variables with side-effects
  which get triggered just by accessing them (like $0) will still 
  be affected.
  
  For those variables that have an B<awk> version, both long
  and short English alternatives are provided.  For example, 
  the C<$/> variable can be referred to either $RS or 
  $INPUT_RECORD_SEPARATOR if you are using the English module.
  
  See L<perlvar> for a complete list of these.
  
  =head1 PERFORMANCE
  
  NOTE: This was fixed in perl 5.20.  Mentioning these three variables no
  longer makes a speed difference.  This section still applies if your code
  is to run on perl 5.18 or earlier.
  
  This module can provoke sizeable inefficiencies for regular expressions,
  due to unfortunate implementation details.  If performance matters in
  your application and you don't need $PREMATCH, $MATCH, or $POSTMATCH,
  try doing
  
     use English qw( -no_match_vars ) ;
  
  .  B<It is especially important to do this in modules to avoid penalizing
  all applications which use them.>
  
  =cut
  
  no warnings;
  
  my $globbed_match ;
  
  # Grandfather $NAME import
  sub import {
      my $this = shift;
      my @list = grep { ! /^-no_match_vars$/ } @_ ;
      local $Exporter::ExportLevel = 1;
      if ( @_ == @list ) {
          *EXPORT = \@COMPLETE_EXPORT ;
          $globbed_match ||= (
  	    eval q{
  		*MATCH				= *&	;
  		*PREMATCH			= *`	;
  		*POSTMATCH			= *'	;
  		1 ;
  	       }
  	    || do {
  		require Carp ;
  		Carp::croak("Can't create English for match leftovers: $@") ;
  	    }
  	) ;
      }
      else {
          *EXPORT = \@MINIMAL_EXPORT ;
      }
      Exporter::import($this,grep {s/^\$/*/} @list);
  }
  
  @MINIMAL_EXPORT = qw(
  	*ARG
  	*LAST_PAREN_MATCH
  	*INPUT_LINE_NUMBER
  	*NR
  	*INPUT_RECORD_SEPARATOR
  	*RS
  	*OUTPUT_AUTOFLUSH
  	*OUTPUT_FIELD_SEPARATOR
  	*OFS
  	*OUTPUT_RECORD_SEPARATOR
  	*ORS
  	*LIST_SEPARATOR
  	*SUBSCRIPT_SEPARATOR
  	*SUBSEP
  	*FORMAT_PAGE_NUMBER
  	*FORMAT_LINES_PER_PAGE
  	*FORMAT_LINES_LEFT
  	*FORMAT_NAME
  	*FORMAT_TOP_NAME
  	*FORMAT_LINE_BREAK_CHARACTERS
  	*FORMAT_FORMFEED
  	*CHILD_ERROR
  	*OS_ERROR
  	*ERRNO
  	*EXTENDED_OS_ERROR
  	*EVAL_ERROR
  	*PROCESS_ID
  	*PID
  	*REAL_USER_ID
  	*UID
  	*EFFECTIVE_USER_ID
  	*EUID
  	*REAL_GROUP_ID
  	*GID
  	*EFFECTIVE_GROUP_ID
  	*EGID
  	*PROGRAM_NAME
  	*PERL_VERSION
  	*OLD_PERL_VERSION
  	*ACCUMULATOR
  	*COMPILING
  	*DEBUGGING
  	*SYSTEM_FD_MAX
  	*INPLACE_EDIT
  	*PERLDB
  	*BASETIME
  	*WARNING
  	*EXECUTABLE_NAME
  	*OSNAME
  	*LAST_REGEXP_CODE_RESULT
  	*EXCEPTIONS_BEING_CAUGHT
  	*LAST_SUBMATCH_RESULT
  	@LAST_MATCH_START
  	@LAST_MATCH_END
  );
  
  
  @MATCH_EXPORT = qw(
  	*MATCH
  	*PREMATCH
  	*POSTMATCH
  );
  
  @COMPLETE_EXPORT = ( @MINIMAL_EXPORT, @MATCH_EXPORT ) ;
  
  # The ground of all being.
  
  	*ARG					= *_	;
  
  # Matching.
  
  	*LAST_PAREN_MATCH			= *+	;
  	*LAST_SUBMATCH_RESULT			= *^N ;
  	*LAST_MATCH_START			= *-{ARRAY} ;
  	*LAST_MATCH_END				= *+{ARRAY} ;
  
  # Input.
  
  	*INPUT_LINE_NUMBER			= *.	;
  	    *NR					= *.	;
  	*INPUT_RECORD_SEPARATOR			= */	;
  	    *RS					= */	;
  
  # Output.
  
  	*OUTPUT_AUTOFLUSH			= *|	;
  	*OUTPUT_FIELD_SEPARATOR			= *,	;
  	    *OFS				= *,	;
  	*OUTPUT_RECORD_SEPARATOR		= *\	;
  	    *ORS				= *\	;
  
  # Interpolation "constants".
  
  	*LIST_SEPARATOR				= *"	;
  	*SUBSCRIPT_SEPARATOR			= *;	;
  	    *SUBSEP				= *;	;
  
  # Formats
  
  	*FORMAT_PAGE_NUMBER			= *%	;
  	*FORMAT_LINES_PER_PAGE			= *=	;
  	*FORMAT_LINES_LEFT			= *-{SCALAR}	;
  	*FORMAT_NAME				= *~	;
  	*FORMAT_TOP_NAME			= *^	;
  	*FORMAT_LINE_BREAK_CHARACTERS		= *:	;
  	*FORMAT_FORMFEED			= *^L	;
  
  # Error status.
  
  	*CHILD_ERROR				= *?	;
  	*OS_ERROR				= *!	;
  	    *ERRNO				= *!	;
  	*OS_ERROR				= *!	;
  	    *ERRNO				= *!	;
  	*EXTENDED_OS_ERROR			= *^E	;
  	*EVAL_ERROR				= *@	;
  
  # Process info.
  
  	*PROCESS_ID				= *$	;
  	    *PID				= *$	;
  	*REAL_USER_ID				= *<	;
  	    *UID				= *<	;
  	*EFFECTIVE_USER_ID			= *>	;
  	    *EUID				= *>	;
  	*REAL_GROUP_ID				= *(	;
  	    *GID				= *(	;
  	*EFFECTIVE_GROUP_ID			= *)	;
  	    *EGID				= *)	;
  	*PROGRAM_NAME				= *0	;
  
  # Internals.
  
  	*PERL_VERSION				= *^V	;
  	*OLD_PERL_VERSION			= *]	;
  	*ACCUMULATOR				= *^A	;
  	*COMPILING				= *^C	;
  	*DEBUGGING				= *^D	;
  	*SYSTEM_FD_MAX				= *^F	;
  	*INPLACE_EDIT				= *^I	;
  	*PERLDB					= *^P	;
  	*LAST_REGEXP_CODE_RESULT		= *^R	;
  	*EXCEPTIONS_BEING_CAUGHT		= *^S	;
  	*BASETIME				= *^T	;
  	*WARNING				= *^W	;
  	*EXECUTABLE_NAME			= *^X	;
  	*OSNAME					= *^O	;
  
  # Deprecated.
  
  #	*ARRAY_BASE				= *[	;
  #	*OFMT					= *#	;
  
  1;
ENGLISH

$fatpacked{"File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC';
  package File::Spec;
  
  use strict;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  my %module = (
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  our @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of files in a directory (such as from C<readdir()>),
  strip out C<'.'> and C<'..'>.
  
  B<SECURITY NOTE:> This does NOT filter paths containing C<'..'>, like
  C<'../../../../etc/passwd'>, only literal matches to C<'.'> and C<'..'>.
  
      @paths = File::Spec->no_upwards( readdir $dirhandle );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_SPEC

$fatpacked{"File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec
                                # if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
FILE_SPEC_AMIGAOS

$fatpacked{"File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval {
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Win32API::File;
    } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
FILE_SPEC_CYGWIN

$fatpacked{"File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
FILE_SPEC_EPOC

$fatpacked{"File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  our @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
FILE_SPEC_FUNCTIONS

$fatpacked{"File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  L<File::Spec::Unix/canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see L<File::Spec::Unix/canonpath()>. If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns the empty string.  Mac OS has no real root directory.
  
  =cut
  
  sub rootdir { '' }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
FILE_SPEC_MAC

$fatpacked{"File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_SPEC_OS2

$fatpacked{"File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use Cwd ();
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { !defined($_) || eval { eval('1'.substr $_,0,0) } }
  			@dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath(Cwd::getcwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
FILE_SPEC_UNIX

$fatpacked{"File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__};
                 local @INC = @INC;
                 pop @INC if $INC[-1] eq '.';
                 require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])(?:\^.|[^\]\.])+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $self->canonpath( $path ) unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
FILE_SPEC_VMS

$fatpacked{"File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval {
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Win32API::File;
    } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( Cwd::getcwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = Cwd::getcwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
FILE_SPEC_WIN32

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  # vim: ts=4 sts=4 sw=4 et:
  package HTTP::Tiny;
  use strict;
  use warnings;
  # ABSTRACT: A small, simple, correct HTTP/1.1 client
  
  our $VERSION = '0.058';
  
  use Carp ();
  
  #pod =method new
  #pod
  #pod     $http = HTTP::Tiny->new( %attributes );
  #pod
  #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  #pod
  #pod =for :list
  #pod * C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If
  #pod   C<agent> — ends in a space character, the default user-agent string is
  #pod   appended.
  #pod * C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class
  #pod   that supports the C<add> and C<cookie_header> methods
  #pod * C<default_headers> — A hashref of default headers to apply to requests
  #pod * C<local_address> — The local IP address to bind to
  #pod * C<keep_alive> — Whether to reuse the last connection (if for the same
  #pod   scheme, host and port) (defaults to 1)
  #pod * C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  #pod * C<max_size> — Maximum response size in bytes (only when not using a data
  #pod   callback).  If defined, responses larger than this will return an
  #pod   exception.
  #pod * C<http_proxy> — URL of a proxy server to use for HTTP connections
  #pod   (default is C<$ENV{http_proxy}> — if set)
  #pod * C<https_proxy> — URL of a proxy server to use for HTTPS connections
  #pod   (default is C<$ENV{https_proxy}> — if set)
  #pod * C<proxy> — URL of a generic proxy server for both HTTP and HTTPS
  #pod   connections (default is C<$ENV{all_proxy}> — if set)
  #pod * C<no_proxy> — List of domain suffixes that should not be proxied.  Must
  #pod   be a comma-separated string or an array reference. (default is
  #pod   C<$ENV{no_proxy}> —)
  #pod * C<timeout> — Request timeout in seconds (default is 60) If a socket open,
  #pod   read or write takes longer than the timeout, an exception is thrown.
  #pod * C<verify_SSL> — A boolean that indicates whether to validate the SSL
  #pod   certificate of an C<https> — connection (default is false)
  #pod * C<SSL_options> — A hashref of C<SSL_*> — options to pass through to
  #pod   L<IO::Socket::SSL>
  #pod
  #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  #pod prevent getting the corresponding proxies from the environment.
  #pod
  #pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
  #pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  #pod content field in the response will contain the text of the exception.
  #pod
  #pod The C<keep_alive> parameter enables a persistent connection, but only to a
  #pod single destination scheme, host and port.  Also, if any connection-relevant
  #pod attributes are modified, or if the process ID or thread ID change, the
  #pod persistent connection will be dropped.  If you want persistent connections
  #pod across multiple destinations, use multiple HTTP::Tiny objects.
  #pod
  #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  #pod
  #pod =cut
  
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ($self->{handle}) {
              $self->{handle}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub new {
      my($class, %args) = @_;
  
      my $self = {
          max_redirect => 5,
          timeout      => 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };
  
      bless $self, $class;
  
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
  
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
  
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
  
      $self->_set_proxies;
  
      return $self;
  }
  
  sub _set_proxies {
      my ($self) = @_;
  
      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment
  
      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }
  
      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }
  
      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }
  
      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }
  
      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }
  
      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }
  
      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
  
      return;
  }
  
  #pod =method get|head|put|post|delete
  #pod
  #pod     $response = $http->get($url);
  #pod     $response = $http->get($url, \%options);
  #pod     $response = $http->head($url);
  #pod
  #pod These methods are shorthand for calling C<request()> for the given method.  The
  #pod URL must have unsafe characters escaped and international domain names encoded.
  #pod See C<request()> for valid options and a description of the response.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  for my $sub_name ( qw/get head put post delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  
  #pod =method post_form
  #pod
  #pod     $response = $http->post_form($url, $form_data);
  #pod     $response = $http->post_form($url, $form_data, \%options);
  #pod
  #pod This method executes a C<POST> request and sends the key/value pairs from a
  #pod form data hash or array reference to the given URL with a C<content-type> of
  #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
  #pod reference, the order is preserved; if provided as a hash reference, the terms
  #pod are sorted on key and value for consistency.  See documentation for the
  #pod C<www_form_urlencode> method for details on the encoding.
  #pod
  #pod The URL must have unsafe characters escaped and international domain names
  #pod encoded.  See C<request()> for valid options and a description of the response.
  #pod Any C<content-type> header or content in the options hashref will be ignored.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
  
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
      delete $args->{headers};
  
      return $self->request('POST', $url, {
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  
  #pod =method mirror
  #pod
  #pod     $response = $http->mirror($url, $file, \%options)
  #pod     if ( $response->{success} ) {
  #pod         print "$file is up to date\n";
  #pod     }
  #pod
  #pod Executes a C<GET> request for the URL and saves the response body to the file
  #pod name provided.  The URL must have unsafe characters escaped and international
  #pod domain names encoded.  If the file already exists, the request will include an
  #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
  #pod may specify a different C<If-Modified-Since> header yourself in the C<<
  #pod $options->{headers} >> hash.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX
  #pod or if the status code is 304 (unmodified).
  #pod
  #pod If the file was modified and the server response includes a properly
  #pod formatted C<Last-Modified> header, the file modification time will
  #pod be updated accordingly.
  #pod
  #pod =cut
  
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
  
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
  
      if ( $response->{success} ) {
          rename $tempfile, $file
              or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  
  #pod =method request
  #pod
  #pod     $response = $http->request($method, $url);
  #pod     $response = $http->request($method, $url, \%options);
  #pod
  #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  #pod international domain names encoded.
  #pod
  #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
  #pod authorization headers.  (Authorization headers will not be included in a
  #pod redirected request.) For example:
  #pod
  #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  #pod
  #pod If the "user:password" stanza contains reserved characters, they must
  #pod be percent-escaped:
  #pod
  #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
  #pod
  #pod A hashref of options may be appended to modify the request.
  #pod
  #pod Valid options are:
  #pod
  #pod =for :list
  #pod * C<headers> —
  #pod     A hashref containing headers to include with the request.  If the value for
  #pod     a header is an array reference, the header will be output multiple times with
  #pod     each value in the array.  These headers over-write any default headers.
  #pod * C<content> —
  #pod     A scalar to include as the body of the request OR a code reference
  #pod     that will be called iteratively to produce the body of the request
  #pod * C<trailer_callback> —
  #pod     A code reference that will be called if it exists to provide a hashref
  #pod     of trailing headers (only used with chunked transfer-encoding)
  #pod * C<data_callback> —
  #pod     A code reference that will be called for each chunks of the response
  #pod     body received.
  #pod * C<peer> —
  #pod     Override host resolution and force all connections to go only to a
  #pod     specific peer address, regardless of the URL of the request.  This will
  #pod     include any redirections!  This options should be used with extreme
  #pod     caution (e.g. debugging or very special circumstances).
  #pod
  #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  #pod may be ignored or overwritten if necessary for transport compliance.
  #pod
  #pod If the C<content> option is a code reference, it will be called iteratively
  #pod to provide the content body of the request.  It should return the empty
  #pod string or undef when the iterator is exhausted.
  #pod
  #pod If the C<content> option is the empty string, no C<content-type> or
  #pod C<content-length> headers will be generated.
  #pod
  #pod If the C<data_callback> option is provided, it will be called iteratively until
  #pod the entire response body is received.  The first argument will be a string
  #pod containing a chunk of the response body, the second argument will be the
  #pod in-progress response hash reference, as described below.  (This allows
  #pod customizing the action of the callback based on the C<status> or C<headers>
  #pod received prior to the content body.)
  #pod
  #pod The C<request> method returns a hashref containing the response.  The hashref
  #pod will have the following keys:
  #pod
  #pod =for :list
  #pod * C<success> —
  #pod     Boolean indicating whether the operation returned a 2XX status code
  #pod * C<url> —
  #pod     URL that provided the response. This is the URL of the request unless
  #pod     there were redirections, in which case it is the last URL queried
  #pod     in a redirection chain
  #pod * C<status> —
  #pod     The HTTP status code of the response
  #pod * C<reason> —
  #pod     The response phrase returned by the server
  #pod * C<content> —
  #pod     The body of the response.  If the response does not have any content
  #pod     or if a data callback is provided to consume the response body,
  #pod     this will be the empty string
  #pod * C<headers> —
  #pod     A hashref of header fields.  All header field names will be normalized
  #pod     to be lower case. If a header is repeated, the value will be an arrayref;
  #pod     it will otherwise be a scalar string containing the value
  #pod * C<redirects>
  #pod     If this field exists, it is an arrayref of response hash references from
  #pod     redirects in the same order that redirections occurred.  If it does
  #pod     not exist, then no redirections occurred.
  #pod
  #pod On an exception during the execution of the request, the C<status> field will
  #pod contain 599, and the C<content> field will contain the text of the exception.
  #pod
  #pod =cut
  
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
  
      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end)};
      }
  
      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              return $e;
          }
  
          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              }
          };
      }
      return $response;
  }
  
  #pod =method www_form_urlencode
  #pod
  #pod     $params = $http->www_form_urlencode( $data );
  #pod     $response = $http->get("http://example.com/query?$params");
  #pod
  #pod This method converts the key/value pairs from a data hash or array reference
  #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
  #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  #pod array reference, the key will be repeated with each of the values of the array
  #pod reference.  If data is provided as a hash reference, the key/value pairs in the
  #pod resulting string will be sorted by key and value for consistent ordering.
  #pod
  #pod =cut
  
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or Carp::croak("form data must be a hash or array reference\n");
  
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or Carp::croak("form data reference must have an even number of terms\n");
  
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
  
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  
  #pod =method can_ssl
  #pod
  #pod     $ok         = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = $http->can_ssl;
  #pod
  #pod Indicates if SSL support is available.  When called as a class object, it
  #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  #pod is set in C<SSL_options>, it checks that a CA file is available.
  #pod
  #pod In scalar context, returns a boolean indicating if SSL is available.
  #pod In list context, returns the boolean and a (possibly multi-line) string of
  #pod errors indicating why SSL isn't available.
  #pod
  #pod =cut
  
  sub can_ssl {
      my ($self) = @_;
  
      my($ok, $reason) = (1, '');
  
      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }
  
      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }
  
      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }
  
      wantarray ? ($ok, $reason) : $ok;
  }
  
  #pod =method connected
  #pod
  #pod     $host = $http->connected;
  #pod     ($host, $port) = $http->connected;
  #pod
  #pod Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  #pod option.
  #pod
  #pod In scalar context, returns the peer host and port, joined with a colon, or
  #pod C<undef> (if no peer is connected).
  #pod In list context, returns the peer host and port or an empty list (if no peer
  #pod is connected).
  #pod
  #pod B<Note>: This method cannot reliably be used to discover whether the remote
  #pod host has closed its end of the socket.
  #pod
  #pod =cut
  
  sub connected {
      my ($self) = @_;
  
      # If a socket exists...
      if ($self->{handle} && $self->{handle}{fh}) {
          my $socket = $self->{handle}{fh};
  
          # ...and is connected, return the peer host and port.
          if ($socket->connected) {
              return wantarray
                  ? ($socket->peerhost, $socket->peerport)
                  : join(':', $socket->peerhost, $socket->peerport);
          }
      }
      return;
  }
  
  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#
  
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      return $default_agent . "/" . $class->VERSION;
  }
  
  sub _request {
      my ($self, $method, $url, $args) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
  
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
  
      my $peer = $args->{peer} || $host;
  
      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
  
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
  
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);
  
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
  
      if ( $self->{keep_alive}
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
  
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
  
      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }
  
      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }
  
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;
  
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
  
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }
  
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
  
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
  
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
  
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
  
      $handle->connect($p_scheme, $p_host, $p_port, $p_host);
  
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
  
      return $handle;
  }
  
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
  
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
  
      return ($scheme, $host, $port, $auth);
  }
  
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
  
      $handle->_assert_ssl;
  
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
  
      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };
  
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
  
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
  
      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );
  
      return;
  }
  
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }
  
      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }
  
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
  
      if ( defined $args->{content} ) {
          if (ref $args->{content} eq 'CODE') {
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'transfer-encoding'} = 'chunked'
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = $args->{content};
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
  
      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
  
      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
  
      return;
  }
  
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
  
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
  
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
  
      my @cookies = ref $cookies ? @$cookies : $cookies;
  
      $self->cookie_jar->add( $url, $_ ) for @cookies;
  
      return;
  }
  
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
  
      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
  
      return;
  }
  
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];
  
      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  
  sub _split_url {
      my $url = pop;
  
      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
  
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
  
      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host
  
          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;
  
      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }
  
  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  
  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  
  sub _uri_escape {
      my ($self, $str) = @_;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/ge;
      return $str;
  }
  
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
  
  # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
  # behavior if someone is unable to boostrap CPAN from a new perl install; it is
  # not intended for general, per-client use and may be removed in the future
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  
  sub BUFSIZE () { 32768 } ## no critic
  
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
  
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => 0,
          SSL_options      => {},
          %args
      }, $class;
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ( $self->{fh} && $self->{fh}->can('timeout') ) {
              $self->{fh}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub connect {
      @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
      my ($self, $scheme, $host, $port, $peer) = @_;
  
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
      elsif ( $scheme ne 'http' ) {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $peer,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
  
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
  
      if ( $self->{keep_alive} ) {
          unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
              CORE::close($self->{fh});
              die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
          }
      }
  
      $self->start_ssl($host) if $scheme eq 'https';
  
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{peer} = $peer;
      $self->{port} = $port;
      $self->{pid} = $$;
      $self->{tid} = _get_tid();
  
      return $self;
  }
  
  sub start_ssl {
      my ($self, $host) = @_;
  
      # As this might be used via CONNECT after an SSL session
      # to a proxy, we shut down any existing SSL before attempting
      # the handshake
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
  
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
  
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
  
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
  
      my $len = length $buf;
      my $off = 0;
  
      local $SIG{PIPE} = 'IGNORE';
  
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
  
          }
      }
      return $off;
  }
  
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
  
      my $buf  = '';
      my $got = length $self->{rbuf};
  
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
  
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
  
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
  
      while () {
           my $line = $self->readline;
  
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers header_case/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  
  # Standard request header names/case from HTTP/1.1 RFCs
  my @rfc_request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language Authorization
    Cache-Control Connection Content-Length Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
    Transfer-Encoding Upgrade User-Agent Via
  );
  
  my @other_request_headers = qw(
    Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
    X-XSS-Protection
  );
  
  my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
  
  # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
  # combine writes.
  sub write_header_lines {
      (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
      my($self, $headers, $header_case, $prefix_data) = @_;
      $header_case ||= {};
  
      my $buf = (defined $prefix_data ? $prefix_data : '');
  
      # Per RFC, control fields should be listed first
      my %seen;
      for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
          next unless exists $headers->{$k};
          $seen{$k}++;
          my $field_name = $HeaderCase{$k};
          my $v = $headers->{$k};
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
  
      # Other headers sent in arbitrary order
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          next if $seen{$field_name};
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              if (exists $header_case->{$field_name}) {
                  $field_name = $header_case->{$field_name};
              }
              else {
                  $field_name =~ s/\b(\w)/\u$1/g;
              }
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              # unwrap a field value if pre-wrapped by user
              s/\x0D?\x0A\s+/ /g;
              die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
                unless $_ eq '' || /\A $Field_Content \z/xo;
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  
  # return value indicates whether message length was defined; this is generally
  # true unless there was no content-length header and we just read until EOF.
  # Other message length errors are thrown as exceptions
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if ($request->{headers}{'content-length'}) {
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
  
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
  
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
  
      return;
  }
  
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
  
          $len += $self->write($data);
      }
  
      $len == $content_length
        or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
  
      return $len;
  }
  
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
  
      while () {
          my $head = $self->readline;
  
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
  
          my $len = hex($1)
            or last;
  
          $self->read_content_body($cb, $response, $len);
  
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
  
          $len += length $data;
  
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
  
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      $self->write_header_lines($request->{trailer_cb}->())
          if ref $request->{trailer_cb} eq 'CODE';
      return $len;
  }
  
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
  
      my $line = $self->readline;
  
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
  
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
  
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
  
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  
  sub write_request_header {
      @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
      my ($self, $method, $request_uri, $headers, $header_case) = @_;
  
      return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
  
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
  
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
  
      vec(my $fdset = '', $fd, 1) = 1;
  
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  
  sub _assert_ssl {
      my($ok, $reason) = HTTP::Tiny->can_ssl();
      die $reason unless $ok;
  }
  
  sub can_reuse {
      my ($self,$scheme,$host,$port,$peer) = @_;
      return 0 if
          $self->{pid} != $$
          || $self->{tid} != _get_tid()
          || length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || $peer ne $self->{peer}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  
  # Try to find a CA bundle to validate the SSL cert,
  # prefer Mozilla::CA or fallback to a system file
  sub _find_CA_file {
      my $self = shift();
  
      my $ca_file =
        defined( $self->{SSL_options}->{SSL_ca_file} )
        ? $self->{SSL_options}->{SSL_ca_file}
        : $ENV{SSL_CERT_FILE};
  
      if ( defined $ca_file ) {
          unless ( -r $ca_file ) {
              die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
          }
          return $ca_file;
      }
  
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA; 1 };
  
      # cert list copied from golang src/crypto/x509/root_unix.go
      foreach my $ca_bundle (
          "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
          "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
          "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
          "/etc/openssl/certs/ca-certificates.crt", # NetBSD
          "/etc/ssl/cert.pem",                      # OpenBSD
          "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
          "/etc/pki/tls/cacert.pem",                # OpenELEC
          "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
  
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  
  # for thread safety, we need to know thread id if threads are loaded
  sub _get_tid {
      no warnings 'reserved'; # for 'threads'
      return threads->can("tid") ? threads->tid : 0;
  }
  
  sub _ssl_args {
      my ($self, $host) = @_;
  
      my %ssl_args;
  
      # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
      # added until IO::Socket::SSL 1.84
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
  
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
  
      # user options override settings from verify_SSL
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
  
      return \%ssl_args;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Tiny - A small, simple, correct HTTP/1.1 client
  
  =head1 VERSION
  
  version 0.058
  
  =head1 SYNOPSIS
  
      use HTTP::Tiny;
  
      my $response = HTTP::Tiny->new->get('http://example.com/');
  
      die "Failed!\n" unless $response->{success};
  
      print "$response->{status} $response->{reason}\n";
  
      while (my ($k, $v) = each %{$response->{headers}}) {
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              print "$k: $_\n";
          }
      }
  
      print $response->{content} if length $response->{content};
  
  =head1 DESCRIPTION
  
  This is a very simple HTTP/1.1 client, designed for doing simple
  requests without the overhead of a large framework like L<LWP::UserAgent>.
  
  It is more correct and more complete than L<HTTP::Lite>.  It supports
  proxies and redirection.  It also correctly resumes after EINTR.
  
  If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
  of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
  
  Cookie support requires L<HTTP::CookieJar> or an equivalent class.
  
  =head1 METHODS
  
  =head2 new
  
      $http = HTTP::Tiny->new( %attributes );
  
  This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  
  =over 4
  
  =item *
  
  C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
  
  =item *
  
  C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
  
  =item *
  
  C<default_headers> — A hashref of default headers to apply to requests
  
  =item *
  
  C<local_address> — The local IP address to bind to
  
  =item *
  
  C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
  
  =item *
  
  C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  
  =item *
  
  C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
  
  =item *
  
  C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
  
  =item *
  
  C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
  
  =item *
  
  C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
  
  =item *
  
  C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
  
  =item *
  
  C<timeout> — Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.
  
  =item *
  
  C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
  
  =item *
  
  C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
  
  =back
  
  Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  prevent getting the corresponding proxies from the environment.
  
  Exceptions from C<max_size>, C<timeout> or other errors will result in a
  pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  content field in the response will contain the text of the exception.
  
  The C<keep_alive> parameter enables a persistent connection, but only to a
  single destination scheme, host and port.  Also, if any connection-relevant
  attributes are modified, or if the process ID or thread ID change, the
  persistent connection will be dropped.  If you want persistent connections
  across multiple destinations, use multiple HTTP::Tiny objects.
  
  See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  
  =head2 get|head|put|post|delete
  
      $response = $http->get($url);
      $response = $http->get($url, \%options);
      $response = $http->head($url);
  
  These methods are shorthand for calling C<request()> for the given method.  The
  URL must have unsafe characters escaped and international domain names encoded.
  See C<request()> for valid options and a description of the response.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 post_form
  
      $response = $http->post_form($url, $form_data);
      $response = $http->post_form($url, $form_data, \%options);
  
  This method executes a C<POST> request and sends the key/value pairs from a
  form data hash or array reference to the given URL with a C<content-type> of
  C<application/x-www-form-urlencoded>.  If data is provided as an array
  reference, the order is preserved; if provided as a hash reference, the terms
  are sorted on key and value for consistency.  See documentation for the
  C<www_form_urlencode> method for details on the encoding.
  
  The URL must have unsafe characters escaped and international domain names
  encoded.  See C<request()> for valid options and a description of the response.
  Any C<content-type> header or content in the options hashref will be ignored.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 mirror
  
      $response = $http->mirror($url, $file, \%options)
      if ( $response->{success} ) {
          print "$file is up to date\n";
      }
  
  Executes a C<GET> request for the URL and saves the response body to the file
  name provided.  The URL must have unsafe characters escaped and international
  domain names encoded.  If the file already exists, the request will include an
  C<If-Modified-Since> header with the modification timestamp of the file.  You
  may specify a different C<If-Modified-Since> header yourself in the C<<
  $options->{headers} >> hash.
  
  The C<success> field of the response will be true if the status code is 2XX
  or if the status code is 304 (unmodified).
  
  If the file was modified and the server response includes a properly
  formatted C<Last-Modified> header, the file modification time will
  be updated accordingly.
  
  =head2 request
  
      $response = $http->request($method, $url);
      $response = $http->request($method, $url, \%options);
  
  Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  international domain names encoded.
  
  If the URL includes a "user:password" stanza, they will be used for Basic-style
  authorization headers.  (Authorization headers will not be included in a
  redirected request.) For example:
  
      $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  
  If the "user:password" stanza contains reserved characters, they must
  be percent-escaped:
  
      $http->request('GET', 'http://john%40example.com:password@example.com/');
  
  A hashref of options may be appended to modify the request.
  
  Valid options are:
  
  =over 4
  
  =item *
  
  C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
  
  =item *
  
  C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
  
  =item *
  
  C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
  
  =item *
  
  C<data_callback> — A code reference that will be called for each chunks of the response body received.
  
  =item *
  
  C<peer> — Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request.  This will include any redirections!  This options should be used with extreme caution (e.g. debugging or very special circumstances).
  
  =back
  
  The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  may be ignored or overwritten if necessary for transport compliance.
  
  If the C<content> option is a code reference, it will be called iteratively
  to provide the content body of the request.  It should return the empty
  string or undef when the iterator is exhausted.
  
  If the C<content> option is the empty string, no C<content-type> or
  C<content-length> headers will be generated.
  
  If the C<data_callback> option is provided, it will be called iteratively until
  the entire response body is received.  The first argument will be a string
  containing a chunk of the response body, the second argument will be the
  in-progress response hash reference, as described below.  (This allows
  customizing the action of the callback based on the C<status> or C<headers>
  received prior to the content body.)
  
  The C<request> method returns a hashref containing the response.  The hashref
  will have the following keys:
  
  =over 4
  
  =item *
  
  C<success> — Boolean indicating whether the operation returned a 2XX status code
  
  =item *
  
  C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
  
  =item *
  
  C<status> — The HTTP status code of the response
  
  =item *
  
  C<reason> — The response phrase returned by the server
  
  =item *
  
  C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
  
  =item *
  
  C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
  
  =item *
  
  C<redirects> If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred.  If it does not exist, then no redirections occurred.
  
  =back
  
  On an exception during the execution of the request, the C<status> field will
  contain 599, and the C<content> field will contain the text of the exception.
  
  =head2 www_form_urlencode
  
      $params = $http->www_form_urlencode( $data );
      $response = $http->get("http://example.com/query?$params");
  
  This method converts the key/value pairs from a data hash or array reference
  into a C<x-www-form-urlencoded> string.  The keys and values from the data
  reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  array reference, the key will be repeated with each of the values of the array
  reference.  If data is provided as a hash reference, the key/value pairs in the
  resulting string will be sorted by key and value for consistent ordering.
  
  =head2 can_ssl
  
      $ok         = HTTP::Tiny->can_ssl;
      ($ok, $why) = HTTP::Tiny->can_ssl;
      ($ok, $why) = $http->can_ssl;
  
  Indicates if SSL support is available.  When called as a class object, it
  checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  is set in C<SSL_options>, it checks that a CA file is available.
  
  In scalar context, returns a boolean indicating if SSL is available.
  In list context, returns the boolean and a (possibly multi-line) string of
  errors indicating why SSL isn't available.
  
  =head2 connected
  
      $host = $http->connected;
      ($host, $port) = $http->connected;
  
  Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  option.
  
  In scalar context, returns the peer host and port, joined with a colon, or
  C<undef> (if no peer is connected).
  In list context, returns the peer host and port or an empty list (if no peer
  is connected).
  
  B<Note>: This method cannot reliably be used to discover whether the remote
  host has closed its end of the socket.
  
  =for Pod::Coverage SSL_options
  agent
  cookie_jar
  default_headers
  http_proxy
  https_proxy
  keep_alive
  local_address
  max_redirect
  max_size
  no_proxy
  proxy
  timeout
  verify_SSL
  
  =head1 SSL SUPPORT
  
  Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
  greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
  thrown if new enough versions of these modules are not installed or if the SSL
  encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
  that returns boolean to see if the required modules are installed.
  
  An C<https> connection may be made via an C<http> proxy that supports the CONNECT
  command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
  requires C<https> to communicate.
  
  SSL provides two distinct capabilities:
  
  =over 4
  
  =item *
  
  Encrypted communication channel
  
  =item *
  
  Verification of server identity
  
  =back
  
  B<By default, HTTP::Tiny does not verify server identity>.
  
  Server identity verification is controversial and potentially tricky because it
  depends on a (usually paid) third-party Certificate Authority (CA) trust model
  to validate a certificate as legitimate.  This discriminates against servers
  with self-signed certificates or certificates signed by free, community-driven
  CA's such as L<CAcert.org|http://cacert.org>.
  
  By default, HTTP::Tiny does not make any assumptions about your trust model,
  threat level or risk tolerance.  It just aims to give you an encrypted channel
  when you need one.
  
  Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
  that an SSL connection has a valid SSL certificate corresponding to the host
  name of the connection and that the SSL certificate has been verified by a CA.
  Assuming you trust the CA, this will protect against a L<man-in-the-middle
  attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
  concerned about security, you should enable this option.
  
  Certificate verification requires a file containing trusted CA certificates.
  
  If the environment variable C<SSL_CERT_FILE> is present, HTTP::Tiny
  will try to find a CA certificate file in that location.
  
  If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
  included with it as a source of trusted CA's.  (This means you trust Mozilla,
  the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
  toolchain used to install it, and your operating system security, right?)
  
  If that module is not available, then HTTP::Tiny will search several
  system-specific default locations for a CA certificate file:
  
  =over 4
  
  =item *
  
  /etc/ssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/pki/tls/certs/ca-bundle.crt
  
  =item *
  
  /etc/ssl/ca-bundle.pem
  
  =back
  
  An exception will be raised if C<verify_SSL> is true and no CA certificate file
  is available.
  
  If you desire complete control over SSL connections, the C<SSL_options> attribute
  lets you provide a hash reference that will be passed through to
  C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
  example, to provide your own trusted CA file:
  
      SSL_options => {
          SSL_ca_file => $file_path,
      }
  
  The C<SSL_options> attribute could also be used for such things as providing a
  client certificate for authentication to a server or controlling the choice of
  cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
  details.
  
  =head1 PROXY SUPPORT
  
  HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
  authorization is supported and it must be provided as part of the proxy URL:
  C<http://user:pass@proxy.example.com/>.
  
  HTTP::Tiny supports the following proxy environment variables:
  
  =over 4
  
  =item *
  
  http_proxy or HTTP_PROXY
  
  =item *
  
  https_proxy or HTTPS_PROXY
  
  =item *
  
  all_proxy or ALL_PROXY
  
  =back
  
  If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
  process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
  security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
  variant only) is ignored.
  
  Tunnelling C<https> over an C<http> proxy using the CONNECT method is
  supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
  over it.
  
  Be warned that proxying an C<https> connection opens you to the risk of a
  man-in-the-middle attack by the proxy server.
  
  The C<no_proxy> environment variable is supported in the format of a
  comma-separated list of domain extensions proxy should not be used for.
  
  Proxy arguments passed to C<new> will override their corresponding
  environment variables.
  
  =head1 LIMITATIONS
  
  HTTP::Tiny is I<conditionally compliant> with the
  L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
  
  =over 4
  
  =item *
  
  "Message Syntax and Routing" [RFC7230]
  
  =item *
  
  "Semantics and Content" [RFC7231]
  
  =item *
  
  "Conditional Requests" [RFC7232]
  
  =item *
  
  "Range Requests" [RFC7233]
  
  =item *
  
  "Caching" [RFC7234]
  
  =item *
  
  "Authentication" [RFC7235]
  
  =back
  
  It attempts to meet all "MUST" requirements of the specification, but does not
  implement all "SHOULD" requirements.  (Note: it was developed against the
  earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
  spec.)
  
  Some particular limitations of note include:
  
  =over
  
  =item *
  
  HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
  that user-defined headers and content are compliant with the HTTP/1.1
  specification.
  
  =item *
  
  Users must ensure that URLs are properly escaped for unsafe characters and that
  international domain names are properly encoded to ASCII. See L<URI::Escape>,
  L<URI::_punycode> and L<Net::IDN::Encode>.
  
  =item *
  
  Redirection is very strict against the specification.  Redirection is only
  automatic for response codes 301, 302, 307 and 308 if the request method is
  'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
  redirection, as mandated by the specification.  There is no automatic support
  for status 305 ("Use proxy") redirections.
  
  =item *
  
  There is no provision for delaying a request body using an C<Expect> header.
  Unexpected C<1XX> responses are silently ignored as per the specification.
  
  =item *
  
  Only 'chunked' C<Transfer-Encoding> is supported.
  
  =item *
  
  There is no support for a Request-URI of '*' for the 'OPTIONS' request.
  
  =item *
  
  Headers mentioned in the RFCs and some other, well-known headers are
  generated with their canonical case.  Other headers are sent in the
  case provided by the user.  Except for control headers (which are sent first),
  headers are sent in arbitrary order.
  
  =back
  
  Despite the limitations listed above, HTTP::Tiny is considered
  feature-complete.  New feature requests should be directed to
  L<HTTP::Tiny::UA>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
  
  =item *
  
  L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
  
  =item *
  
  L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
  
  =item *
  
  L<IO::Socket::IP> - Required for IPv6 support
  
  =item *
  
  L<IO::Socket::SSL> - Required for SSL support
  
  =item *
  
  L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
  
  =item *
  
  L<Mozilla::CA> - Required if you want to validate SSL certificates
  
  =item *
  
  L<Net::SSLeay> - Required for SSL support
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/chansen/p5-http-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/chansen/p5-http-tiny>
  
    git clone https://github.com/chansen/p5-http-tiny.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alan Gardner Alessandro Ghedini A. Sinan Unur Brad Gilbert brian m. carlson Chris Nehren Weyl Claes Jakobsson Clinton Gormley David Golden Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař SkyMarshal Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook
  
  =over 4
  
  =item *
  
  Alan Gardner <gardner@pythian.com>
  
  =item *
  
  Alessandro Ghedini <al3xbio@gmail.com>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Brad Gilbert <bgills@cpan.org>
  
  =item *
  
  brian m. carlson <sandals@crustytoothpaste.net>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Claes Jakobsson <claes@surfar.nu>
  
  =item *
  
  Clinton Gormley <clint@traveljury.com>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Dean Pearce <pearce@pythian.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jeremy Mates <jmates@cpan.org>
  
  =item *
  
  Jess Robinson <castaway@desert-island.me.uk>
  
  =item *
  
  Lukas Eklund <leklund@gmail.com>
  
  =item *
  
  Martin J. Evans <mjegh@ntlworld.com>
  
  =item *
  
  Martin-Louis Bright <mlbright@gmail.com>
  
  =item *
  
  Mike Doherty <doherty@cpan.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Petr Písař <ppisar@redhat.com>
  
  =item *
  
  SkyMarshal <skymarshal1729@gmail.com>
  
  =item *
  
  Sören Kornetzki <soeren.kornetzki@delti.com>
  
  =item *
  
  Syohei YOSHIDA <syohex@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Tom Hukins <tom@eborcom.com>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_TINY

$fatpacked{"IO/Socket/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_IP';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2015 -- leonerd@leonerd.org.uk
  
  package IO::Socket::IP;
  # $VERSION needs to be set before  use base 'IO::Socket'
  #  - https://rt.cpan.org/Ticket/Display.html?id=92107
  BEGIN {
     $VERSION = '0.37';
  }
  
  use strict;
  use warnings;
  use base qw( IO::Socket );
  
  use Carp;
  
  use Socket 1.97 qw(
     getaddrinfo getnameinfo
     sockaddr_family
     AF_INET
     AI_PASSIVE
     IPPROTO_TCP IPPROTO_UDP
     IPPROTO_IPV6 IPV6_V6ONLY
     NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV
     SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR
     SOCK_DGRAM SOCK_STREAM
     SOL_SOCKET
  );
  my $AF_INET6 = eval { Socket::AF_INET6() }; # may not be defined
  my $AI_ADDRCONFIG = eval { Socket::AI_ADDRCONFIG() } || 0;
  use POSIX qw( dup2 );
  use Errno qw( EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK );
  
  use constant HAVE_MSWIN32 => ( $^O eq "MSWin32" );
  
  # At least one OS (Android) is known not to have getprotobyname()
  use constant HAVE_GETPROTOBYNAME => defined eval { getprotobyname( "tcp" ) };
  
  my $IPv6_re = do {
     # translation of RFC 3986 3.2.2 ABNF to re
     my $IPv4address = do {
        my $dec_octet = q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;
        qq<$dec_octet(?: \\. $dec_octet){3}>;
     };
     my $IPv6address = do {
        my $h16  = qq<[0-9A-Fa-f]{1,4}>;
        my $ls32 = qq<(?: $h16 : $h16 | $IPv4address)>;
        qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>
     };
     qr<$IPv6address>xo;
  };
  
  =head1 NAME
  
  C<IO::Socket::IP> - Family-neutral IP socket supporting both IPv4 and IPv6
  
  =head1 SYNOPSIS
  
   use IO::Socket::IP;
  
   my $sock = IO::Socket::IP->new(
      PeerHost => "www.google.com",
      PeerPort => "http",
      Type     => SOCK_STREAM,
   ) or die "Cannot construct socket - $@";
  
   my $familyname = ( $sock->sockdomain == PF_INET6 ) ? "IPv6" :
                    ( $sock->sockdomain == PF_INET  ) ? "IPv4" :
                                                        "unknown";
  
   printf "Connected to google via %s\n", $familyname;
  
  =head1 DESCRIPTION
  
  This module provides a protocol-independent way to use IPv4 and IPv6 sockets,
  intended as a replacement for L<IO::Socket::INET>. Most constructor arguments
  and methods are provided in a backward-compatible way. For a list of known
  differences, see the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  It uses the C<getaddrinfo(3)> function to convert hostnames and service names
  or port numbers into sets of possible addresses to connect to or listen on.
  This allows it to work for IPv6 where the system supports it, while still
  falling back to IPv4-only on systems which don't.
  
  =head1 REPLACING C<IO::Socket> DEFAULT BEHAVIOUR
  
  By placing C<-register> in the import list, L<IO::Socket> uses
  C<IO::Socket::IP> rather than C<IO::Socket::INET> as the class that handles
  C<PF_INET>.  C<IO::Socket> will also use C<IO::Socket::IP> rather than
  C<IO::Socket::INET6> to handle C<PF_INET6>, provided that the C<AF_INET6>
  constant is available.
  
  Changing C<IO::Socket>'s default behaviour means that calling the
  C<IO::Socket> constructor with either C<PF_INET> or C<PF_INET6> as the
  C<Domain> parameter will yield an C<IO::Socket::IP> object.
  
   use IO::Socket::IP -register;
  
   my $sock = IO::Socket->new(
      Domain    => PF_INET6,
      LocalHost => "::1",
      Listen    => 1,
   ) or die "Cannot create socket - $@\n";
  
   print "Created a socket of type " . ref($sock) . "\n";
  
  Note that C<-register> is a global setting that applies to the entire program;
  it cannot be applied only for certain callers, removed, or limited by lexical
  scope.
  
  =cut
  
  sub import
  {
     my $pkg = shift;
     my @symbols;
  
     foreach ( @_ ) {
        if( $_ eq "-register" ) {
           IO::Socket::IP::_ForINET->register_domain( AF_INET );
           IO::Socket::IP::_ForINET6->register_domain( $AF_INET6 ) if defined $AF_INET6;
        }
        else {
           push @symbols, $_;
        }
     }
  
     @_ = ( $pkg, @symbols );
     goto &IO::Socket::import;
  }
  
  # Convenient capability test function
  {
     my $can_disable_v6only;
     sub CAN_DISABLE_V6ONLY
     {
        return $can_disable_v6only if defined $can_disable_v6only;
  
        socket my $testsock, Socket::PF_INET6(), SOCK_STREAM, 0 or
           die "Cannot socket(PF_INET6) - $!";
  
        if( setsockopt $testsock, IPPROTO_IPV6, IPV6_V6ONLY, 0 ) {
           return $can_disable_v6only = 1;
        }
        elsif( $! == EINVAL ) {
           return $can_disable_v6only = 0;
        }
        else {
           die "Cannot setsockopt() - $!";
        }
     }
  }
  
  =head1 CONSTRUCTORS
  
  =cut
  
  =head2 $sock = IO::Socket::IP->new( %args )
  
  Creates a new C<IO::Socket::IP> object, containing a newly created socket
  handle according to the named arguments passed. The recognised arguments are:
  
  =over 8
  
  =item PeerHost => STRING
  
  =item PeerService => STRING
  
  Hostname and service name for the peer to C<connect()> to. The service name
  may be given as a port number, as a decimal string.
  
  =item PeerAddr => STRING
  
  =item PeerPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<PeerHost> and
  C<PeerService> respectively.
  
  =item PeerAddrInfo => ARRAY
  
  Alternate form of specifying the peer to C<connect()> to. This should be an
  array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Peer*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item LocalHost => STRING
  
  =item LocalService => STRING
  
  Hostname and service name for the local address to C<bind()> to.
  
  =item LocalAddr => STRING
  
  =item LocalPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<LocalHost> and
  C<LocalService> respectively.
  
  =item LocalAddrInfo => ARRAY
  
  Alternate form of specifying the local address to C<bind()> to. This should be
  an array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Local*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item Family => INT
  
  The address family to pass to C<getaddrinfo> (e.g. C<AF_INET>, C<AF_INET6>).
  Normally this will be left undefined, and C<getaddrinfo> will search using any
  address family supported by the system.
  
  =item Type => INT
  
  The socket type to pass to C<getaddrinfo> (e.g. C<SOCK_STREAM>,
  C<SOCK_DGRAM>). Normally defined by the caller; if left undefined
  C<getaddrinfo> may attempt to infer the type from the service name.
  
  =item Proto => STRING or INT
  
  The IP protocol to use for the socket (e.g. C<'tcp'>, C<IPPROTO_TCP>,
  C<'udp'>,C<IPPROTO_UDP>). Normally this will be left undefined, and either
  C<getaddrinfo> or the kernel will choose an appropriate value. May be given
  either in string name or numeric form.
  
  =item GetAddrInfoFlags => INT
  
  More flags to pass to the C<getaddrinfo()> function. If not supplied, a
  default of C<AI_ADDRCONFIG> will be used.
  
  These flags will be combined with C<AI_PASSIVE> if the C<Listen> argument is
  given. For more information see the documentation about C<getaddrinfo()> in
  the L<Socket> module.
  
  =item Listen => INT
  
  If defined, puts the socket into listening mode where new connections can be
  accepted using the C<accept> method. The value given is used as the
  C<listen(2)> queue size.
  
  =item ReuseAddr => BOOL
  
  If true, set the C<SO_REUSEADDR> sockopt
  
  =item ReusePort => BOOL
  
  If true, set the C<SO_REUSEPORT> sockopt (not all OSes implement this sockopt)
  
  =item Broadcast => BOOL
  
  If true, set the C<SO_BROADCAST> sockopt
  
  =item V6Only => BOOL
  
  If defined, set the C<IPV6_V6ONLY> sockopt when creating C<PF_INET6> sockets
  to the given value. If true, a listening-mode socket will only listen on the
  C<AF_INET6> addresses; if false it will also accept connections from
  C<AF_INET> addresses.
  
  If not defined, the socket option will not be changed, and default value set
  by the operating system will apply. For repeatable behaviour across platforms
  it is recommended this value always be defined for listening-mode sockets.
  
  Note that not all platforms support disabling this option. Some, at least
  OpenBSD and MirBSD, will fail with C<EINVAL> if you attempt to disable it.
  To determine whether it is possible to disable, you may use the class method
  
   if( IO::Socket::IP->CAN_DISABLE_V6ONLY ) {
      ...
   }
   else {
      ...
   }
  
  If your platform does not support disabling this option but you still want to
  listen for both C<AF_INET> and C<AF_INET6> connections you will have to create
  two listening sockets, one bound to each protocol.
  
  =item MultiHomed
  
  This C<IO::Socket::INET>-style argument is ignored, except if it is defined
  but false. See the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  However, the behaviour it enables is always performed by C<IO::Socket::IP>.
  
  =item Blocking => BOOL
  
  If defined but false, the socket will be set to non-blocking mode. Otherwise
  it will default to blocking mode. See the NON-BLOCKING section below for more
  detail.
  
  =item Timeout => NUM
  
  If defined, gives a maximum time in seconds to block per C<connect()> call
  when in blocking mode. If missing, no timeout is applied other than that
  provided by the underlying operating system. When in non-blocking mode this
  parameter is ignored.
  
  Note that if the hostname resolves to multiple address candidates, the same
  timeout will apply to each connection attempt individually, rather than to the
  operation as a whole. Further note that the timeout does not apply to the
  initial hostname resolve operation, if connecting by hostname.
  
  This behviour is copied inspired by C<IO::Socket::INET>; for more fine grained
  control over connection timeouts, consider performing a nonblocking connect
  directly.
  
  =back
  
  If neither C<Type> nor C<Proto> hints are provided, a default of
  C<SOCK_STREAM> and C<IPPROTO_TCP> respectively will be set, to maintain
  compatibility with C<IO::Socket::INET>. Other named arguments that are not
  recognised are ignored.
  
  If neither C<Family> nor any hosts or addresses are passed, nor any
  C<*AddrInfo>, then the constructor has no information on which to decide a
  socket family to create. In this case, it performs a C<getaddinfo> call with
  the C<AI_ADDRCONFIG> flag, no host name, and a service name of C<"0">, and
  uses the family of the first returned result.
  
  If the constructor fails, it will set C<$@> to an appropriate error message;
  this may be from C<$!> or it may be some other string; not every failure
  necessarily has an associated C<errno> value.
  
  =head2 $sock = IO::Socket::IP->new( $peeraddr )
  
  As a special case, if the constructor is passed a single argument (as
  opposed to an even-sized list of key/value pairs), it is taken to be the value
  of the C<PeerAddr> parameter. This is parsed in the same way, according to the
  behaviour given in the C<PeerHost> AND C<LocalHost> PARSING section below.
  
  =cut
  
  sub new
  {
     my $class = shift;
     my %arg = (@_ == 1) ? (PeerHost => $_[0]) : @_;
     return $class->SUPER::new(%arg);
  }
  
  # IO::Socket may call this one; neaten up the arguments from IO::Socket::INET
  # before calling our real _configure method
  sub configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     $arg->{PeerHost} = delete $arg->{PeerAddr}
        if exists $arg->{PeerAddr} && !exists $arg->{PeerHost};
  
     $arg->{PeerService} = delete $arg->{PeerPort}
        if exists $arg->{PeerPort} && !exists $arg->{PeerService};
  
     $arg->{LocalHost} = delete $arg->{LocalAddr}
        if exists $arg->{LocalAddr} && !exists $arg->{LocalHost};
  
     $arg->{LocalService} = delete $arg->{LocalPort}
        if exists $arg->{LocalPort} && !exists $arg->{LocalService};
  
     for my $type (qw(Peer Local)) {
        my $host    = $type . 'Host';
        my $service = $type . 'Service';
  
        if( defined $arg->{$host} ) {
           ( $arg->{$host}, my $s ) = $self->split_addr( $arg->{$host} );
           # IO::Socket::INET compat - *Host parsed port always takes precedence
           $arg->{$service} = $s if defined $s;
        }
     }
  
     $self->_io_socket_ip__configure( $arg );
  }
  
  # Avoid simply calling it _configure, as some subclasses of IO::Socket::INET on CPAN already take that
  sub _io_socket_ip__configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     my %hints;
     my @localinfos;
     my @peerinfos;
  
     my $listenqueue = $arg->{Listen};
     if( defined $listenqueue and
         ( defined $arg->{PeerHost} || defined $arg->{PeerService} || defined $arg->{PeerAddrInfo} ) ) {
        croak "Cannot Listen with a peer address";
     }
  
     if( defined $arg->{GetAddrInfoFlags} ) {
        $hints{flags} = $arg->{GetAddrInfoFlags};
     }
     else {
        $hints{flags} = $AI_ADDRCONFIG;
     }
  
     if( defined( my $family = $arg->{Family} ) ) {
        $hints{family} = $family;
     }
  
     if( defined( my $type = $arg->{Type} ) ) {
        $hints{socktype} = $type;
     }
  
     if( defined( my $proto = $arg->{Proto} ) ) {
        unless( $proto =~ m/^\d+$/ ) {
           my $protonum = HAVE_GETPROTOBYNAME
              ? getprotobyname( $proto )
              : eval { Socket->${\"IPPROTO_\U$proto"}() };
           defined $protonum or croak "Unrecognised protocol $proto";
           $proto = $protonum;
        }
  
        $hints{protocol} = $proto;
     }
  
     # To maintain compatibility with IO::Socket::INET, imply a default of
     # SOCK_STREAM + IPPROTO_TCP if neither hint is given
     if( !defined $hints{socktype} and !defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM;
        $hints{protocol} = IPPROTO_TCP;
     }
  
     # Some OSes (NetBSD) don't seem to like just a protocol hint without a
     # socktype hint as well. We'll set a couple of common ones
     if( !defined $hints{socktype} and defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM if $hints{protocol} == IPPROTO_TCP;
        $hints{socktype} = SOCK_DGRAM  if $hints{protocol} == IPPROTO_UDP;
     }
  
     if( my $info = $arg->{LocalAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";
        @localinfos = @$info;
     }
     elsif( defined $arg->{LocalHost} or
            defined $arg->{LocalService} or
            HAVE_MSWIN32 and $arg->{Listen} ) {
        # Either may be undef
        my $host = $arg->{LocalHost};
        my $service = $arg->{LocalService};
  
        unless ( defined $host or defined $service ) {
           $service = 0;
        }
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        my %localhints = %hints;
        $localhints{flags} |= AI_PASSIVE;
        ( my $err, @localinfos ) = getaddrinfo( $host, $service, \%localhints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @localinfos ) = getaddrinfo( $host, $fallback_port, \%localhints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     if( my $info = $arg->{PeerAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";
        @peerinfos = @$info;
     }
     elsif( defined $arg->{PeerHost} or defined $arg->{PeerService} ) {
        defined( my $host = $arg->{PeerHost} ) or
           croak "Expected 'PeerHost'";
        defined( my $service = $arg->{PeerService} ) or
           croak "Expected 'PeerService'";
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        ( my $err, @peerinfos ) = getaddrinfo( $host, $service, \%hints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @peerinfos ) = getaddrinfo( $host, $fallback_port, \%hints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     my @sockopts_enabled;
     push @sockopts_enabled, SO_REUSEADDR if $arg->{ReuseAddr};
     push @sockopts_enabled, SO_REUSEPORT if $arg->{ReusePort};
     push @sockopts_enabled, SO_BROADCAST if $arg->{Broadcast};
  
     my $blocking = $arg->{Blocking};
     defined $blocking or $blocking = 1;
  
     my $v6only = $arg->{V6Only};
  
     # IO::Socket::INET defines this key. IO::Socket::IP always implements the
     # behaviour it requests, so we can ignore it, unless the caller is for some
     # reason asking to disable it.
     if( defined $arg->{MultiHomed} and !$arg->{MultiHomed} ) {
        croak "Cannot disable the MultiHomed parameter";
     }
  
     my @infos;
     foreach my $local ( @localinfos ? @localinfos : {} ) {
        foreach my $peer ( @peerinfos ? @peerinfos : {} ) {
           next if defined $local->{family}   and defined $peer->{family}   and
              $local->{family} != $peer->{family};
           next if defined $local->{socktype} and defined $peer->{socktype} and
              $local->{socktype} != $peer->{socktype};
           next if defined $local->{protocol} and defined $peer->{protocol} and
              $local->{protocol} != $peer->{protocol};
  
           my $family   = $local->{family}   || $peer->{family}   or next;
           my $socktype = $local->{socktype} || $peer->{socktype} or next;
           my $protocol = $local->{protocol} || $peer->{protocol} || 0;
  
           push @infos, {
              family    => $family,
              socktype  => $socktype,
              protocol  => $protocol,
              localaddr => $local->{addr},
              peeraddr  => $peer->{addr},
           };
        }
     }
  
     if( !@infos ) {
        # If there was a Family hint then create a plain unbound, unconnected socket
        if( defined $hints{family} ) {
           @infos = ( {
              family   => $hints{family},
              socktype => $hints{socktype},
              protocol => $hints{protocol},
           } );
        }
        # If there wasn't, use getaddrinfo()'s AI_ADDRCONFIG side-effect to guess a
        # suitable family first.
        else {
           ( my $err, @infos ) = getaddrinfo( "", "0", \%hints );
           if( $err ) {
              $@ = "$err";
              $! = EINVAL;
              return;
           }
  
           # We'll take all the @infos anyway, because some OSes (HPUX) are known to
           # ignore the AI_ADDRCONFIG hint and return AF_INET6 even if they don't
           # support them
        }
     }
  
     # In the nonblocking case, caller will be calling ->setup multiple times.
     # Store configuration in the object for the ->setup method
     # Yes, these are messy. Sorry, I can't help that...
  
     ${*$self}{io_socket_ip_infos} = \@infos;
  
     ${*$self}{io_socket_ip_idx} = -1;
  
     ${*$self}{io_socket_ip_sockopts} = \@sockopts_enabled;
     ${*$self}{io_socket_ip_v6only} = $v6only;
     ${*$self}{io_socket_ip_listenqueue} = $listenqueue;
     ${*$self}{io_socket_ip_blocking} = $blocking;
  
     ${*$self}{io_socket_ip_errors} = [ undef, undef, undef ];
  
     # ->setup is allowed to return false in nonblocking mode
     $self->setup or !$blocking or return undef;
  
     return $self;
  }
  
  sub setup
  {
     my $self = shift;
  
     while(1) {
        ${*$self}{io_socket_ip_idx}++;
        last if ${*$self}{io_socket_ip_idx} >= @{ ${*$self}{io_socket_ip_infos} };
  
        my $info = ${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];
  
        $self->socket( @{$info}{qw( family socktype protocol )} ) or
           ( ${*$self}{io_socket_ip_errors}[2] = $!, next );
  
        $self->blocking( 0 ) unless ${*$self}{io_socket_ip_blocking};
  
        foreach my $sockopt ( @{ ${*$self}{io_socket_ip_sockopts} } ) {
           $self->setsockopt( SOL_SOCKET, $sockopt, pack "i", 1 ) or ( $@ = "$!", return undef );
        }
  
        if( defined ${*$self}{io_socket_ip_v6only} and defined $AF_INET6 and $info->{family} == $AF_INET6 ) {
           my $v6only = ${*$self}{io_socket_ip_v6only};
           $self->setsockopt( IPPROTO_IPV6, IPV6_V6ONLY, pack "i", $v6only ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{localaddr} ) ) {
           $self->bind( $addr ) or
              ( ${*$self}{io_socket_ip_errors}[1] = $!, next );
        }
  
        if( defined( my $listenqueue = ${*$self}{io_socket_ip_listenqueue} ) ) {
           $self->listen( $listenqueue ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{peeraddr} ) ) {
           if( $self->connect( $addr ) ) {
              $! = 0;
              return 1;
           }
  
           if( $! == EINPROGRESS or $! == EWOULDBLOCK ) {
              ${*$self}{io_socket_ip_connect_in_progress} = 1;
              return 0;
           }
  
           # If connect failed but we have no system error there must be an error
           # at the application layer, like a bad certificate with
           # IO::Socket::SSL.
           # In this case don't continue IP based multi-homing because the problem
           # cannot be solved at the IP layer.
           return 0 if ! $!;
  
           ${*$self}{io_socket_ip_errors}[0] = $!;
           next;
        }
  
        return 1;
     }
  
     # Pick the most appropriate error, stringified
     $! = ( grep defined, @{ ${*$self}{io_socket_ip_errors}} )[0];
     $@ = "$!";
     return undef;
  }
  
  sub connect :method
  {
     my $self = shift;
  
     # It seems that IO::Socket hides EINPROGRESS errors, making them look like
     # a success. This is annoying here.
     # Instead of putting up with its frankly-irritating intentional breakage of
     # useful APIs I'm just going to end-run around it and call core's connect()
     # directly
  
     if( @_ ) {
        my ( $addr ) = @_;
  
        # Annoyingly IO::Socket's connect() is where the timeout logic is
        # implemented, so we'll have to reinvent it here
        my $timeout = ${*$self}{'io_socket_timeout'};
  
        return connect( $self, $addr ) unless defined $timeout;
  
        my $was_blocking = $self->blocking( 0 );
  
        my $err = defined connect( $self, $addr ) ? 0 : $!+0;
  
        if( !$err ) {
           # All happy
           $self->blocking( $was_blocking );
           return 1;
        }
        elsif( not( $err == EINPROGRESS or $err == EWOULDBLOCK ) ) {
           # Failed for some other reason
           return undef;
        }
        elsif( !$was_blocking ) {
           # We shouldn't block anyway
           return undef;
        }
  
        my $vec = ''; vec( $vec, $self->fileno, 1 ) = 1;
        if( !select( undef, $vec, $vec, $timeout ) ) {
           $! = ETIMEDOUT;
           return undef;
        }
  
        # Hoist the error by connect()ing a second time
        $err = $self->getsockopt( SOL_SOCKET, SO_ERROR );
        $err = 0 if $err == EISCONN; # Some OSes give EISCONN
  
        $self->blocking( $was_blocking );
  
        $! = $err, return undef if $err;
        return 1;
     }
  
     return 1 if !${*$self}{io_socket_ip_connect_in_progress};
  
     # See if a connect attempt has just failed with an error
     if( my $errno = $self->getsockopt( SOL_SOCKET, SO_ERROR ) ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        ${*$self}{io_socket_ip_errors}[0] = $! = $errno;
        return $self->setup;
     }
  
     # No error, so either connect is still in progress, or has completed
     # successfully. We can tell by trying to connect() again; either it will
     # succeed or we'll get EISCONN (connected successfully), or EALREADY
     # (still in progress). This even works on MSWin32.
     my $addr = ${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};
  
     if( connect( $self, $addr ) or $! == EISCONN ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        $! = 0;
        return 1;
     }
     else {
        $! = EINPROGRESS;
        return 0;
     }
  }
  
  sub connected
  {
     my $self = shift;
     return defined $self->fileno &&
            !${*$self}{io_socket_ip_connect_in_progress} &&
            defined getpeername( $self ); # ->peername caches, we need to detect disconnection
  }
  
  =head1 METHODS
  
  As well as the following methods, this class inherits all the methods in
  L<IO::Socket> and L<IO::Handle>.
  
  =cut
  
  sub _get_host_service
  {
     my $self = shift;
     my ( $addr, $flags, $xflags ) = @_;
  
     defined $addr or
        $! = ENOTCONN, return;
  
     $flags |= NI_DGRAM if $self->socktype == SOCK_DGRAM;
  
     my ( $err, $host, $service ) = getnameinfo( $addr, $flags, $xflags || 0 );
     croak "getnameinfo - $err" if $err;
  
     return ( $host, $service );
  }
  
  sub _unpack_sockaddr
  {
     my ( $addr ) = @_;
     my $family = sockaddr_family $addr;
  
     if( $family == AF_INET ) {
        return ( Socket::unpack_sockaddr_in( $addr ) )[1];
     }
     elsif( defined $AF_INET6 and $family == $AF_INET6 ) {
        return ( Socket::unpack_sockaddr_in6( $addr ) )[1];
     }
     else {
        croak "Unrecognised address family $family";
     }
  }
  
  =head2 ( $host, $service ) = $sock->sockhost_service( $numeric )
  
  Returns the hostname and service name of the local address (that is, the
  socket address given by the C<sockname> method).
  
  If C<$numeric> is true, these will be given in numeric form rather than being
  resolved into names.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub sockhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->sockname, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->sockhost
  
  Return the numeric form of the local address as a textual representation
  
  =head2 $port = $sock->sockport
  
  Return the numeric form of the local port number
  
  =head2 $host = $sock->sockhostname
  
  Return the resolved name of the local address
  
  =head2 $service = $sock->sockservice
  
  Return the resolved name of the local port number
  
  =cut
  
  sub sockhost { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub sockport { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub sockhostname { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOSERV ) )[0] }
  sub sockservice  { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $sock->sockaddr
  
  Return the local address as a binary octet string
  
  =cut
  
  sub sockaddr { my $self = shift; _unpack_sockaddr $self->sockname }
  
  =head2 ( $host, $service ) = $sock->peerhost_service( $numeric )
  
  Returns the hostname and service name of the peer address (that is, the
  socket address given by the C<peername> method), similar to the
  C<sockhost_service> method.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub peerhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->peername, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->peerhost
  
  Return the numeric form of the peer address as a textual representation
  
  =head2 $port = $sock->peerport
  
  Return the numeric form of the peer port number
  
  =head2 $host = $sock->peerhostname
  
  Return the resolved name of the peer address
  
  =head2 $service = $sock->peerservice
  
  Return the resolved name of the peer port number
  
  =cut
  
  sub peerhost { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub peerport { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub peerhostname { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOSERV ) )[0] }
  sub peerservice  { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $peer->peeraddr
  
  Return the peer address as a binary octet string
  
  =cut
  
  sub peeraddr { my $self = shift; _unpack_sockaddr $self->peername }
  
  # This unbelievably dodgy hack works around the bug that IO::Socket doesn't do
  # it
  #    https://rt.cpan.org/Ticket/Display.html?id=61577
  sub accept
  {
     my $self = shift;
     my ( $new, $peer ) = $self->SUPER::accept( @_ ) or return;
  
     ${*$new}{$_} = ${*$self}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
     return wantarray ? ( $new, $peer )
                      : $new;
  }
  
  # This second unbelievably dodgy hack guarantees that $self->fileno doesn't
  # change, which is useful during nonblocking connect
  sub socket :method
  {
     my $self = shift;
     return $self->SUPER::socket(@_) if not defined $self->fileno;
  
     # I hate core prototypes sometimes...
     socket( my $tmph, $_[0], $_[1], $_[2] ) or return undef;
  
     dup2( $tmph->fileno, $self->fileno ) or die "Unable to dup2 $tmph onto $self - $!";
  }
  
  # Versions of IO::Socket before 1.35 may leave socktype undef if from, say, an
  #   ->fdopen call. In this case we'll apply a fix
  BEGIN {
     if( eval($IO::Socket::VERSION) < 1.35 ) {
        *socktype = sub {
           my $self = shift;
           my $type = $self->SUPER::socktype;
           if( !defined $type ) {
              $type = $self->sockopt( Socket::SO_TYPE() );
           }
           return $type;
        };
     }
  }
  
  =head2 $inet = $sock->as_inet
  
  Returns a new L<IO::Socket::INET> instance wrapping the same filehandle. This
  may be useful in cases where it is required, for backward-compatibility, to
  have a real object of C<IO::Socket::INET> type instead of C<IO::Socket::IP>.
  The new object will wrap the same underlying socket filehandle as the
  original, so care should be taken not to continue to use both objects
  concurrently. Ideally the original C<$sock> should be discarded after this
  method is called.
  
  This method checks that the socket domain is C<PF_INET> and will throw an
  exception if it isn't.
  
  =cut
  
  sub as_inet
  {
     my $self = shift;
     croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless $self->sockdomain == AF_INET;
     return IO::Socket::INET->new_from_fd( $self->fileno, "r+" );
  }
  
  =head1 NON-BLOCKING
  
  If the constructor is passed a defined but false value for the C<Blocking>
  argument then the socket is put into non-blocking mode. When in non-blocking
  mode, the socket will not be set up by the time the constructor returns,
  because the underlying C<connect(2)> syscall would otherwise have to block.
  
  The non-blocking behaviour is an extension of the C<IO::Socket::INET> API,
  unique to C<IO::Socket::IP>, because the former does not support multi-homed
  non-blocking connect.
  
  When using non-blocking mode, the caller must repeatedly check for
  writeability on the filehandle (for instance using C<select> or C<IO::Poll>).
  Each time the filehandle is ready to write, the C<connect> method must be
  called, with no arguments. Note that some operating systems, most notably
  C<MSWin32> do not report a C<connect()> failure using write-ready; so you must
  also C<select()> for exceptional status.
  
  While C<connect> returns false, the value of C<$!> indicates whether it should
  be tried again (by being set to the value C<EINPROGRESS>, or C<EWOULDBLOCK> on
  MSWin32), or whether a permanent error has occurred (e.g. C<ECONNREFUSED>).
  
  Once the socket has been connected to the peer, C<connect> will return true
  and the socket will now be ready to use.
  
  Note that calls to the platform's underlying C<getaddrinfo(3)> function may
  block. If C<IO::Socket::IP> has to perform this lookup, the constructor will
  block even when in non-blocking mode.
  
  To avoid this blocking behaviour, the caller should pass in the result of such
  a lookup using the C<PeerAddrInfo> or C<LocalAddrInfo> arguments. This can be
  achieved by using L<Net::LibAsyncNS>, or the C<getaddrinfo(3)> function can be
  called in a child process.
  
   use IO::Socket::IP;
   use Errno qw( EINPROGRESS EWOULDBLOCK );
  
   my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
  
   my $socket = IO::Socket::IP->new(
      PeerAddrInfo => \@peeraddrinfo,
      Blocking     => 0,
   ) or die "Cannot construct socket - $@";
  
   while( !$socket->connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
      my $wvec = '';
      vec( $wvec, fileno $socket, 1 ) = 1;
      my $evec = '';
      vec( $evec, fileno $socket, 1 ) = 1;
  
      select( undef, $wvec, $evec, undef ) or die "Cannot select - $!";
   }
  
   die "Cannot connect - $!" if $!;
  
   ...
  
  The example above uses C<select()>, but any similar mechanism should work
  analogously. C<IO::Socket::IP> takes care when creating new socket filehandles
  to preserve the actual file descriptor number, so such techniques as C<poll>
  or C<epoll> should be transparent to its reallocation of a different socket
  underneath, perhaps in order to switch protocol family between C<PF_INET> and
  C<PF_INET6>.
  
  For another example using C<IO::Poll> and C<Net::LibAsyncNS>, see the
  F<examples/nonblocking_libasyncns.pl> file in the module distribution.
  
  =cut
  
  =head1 C<PeerHost> AND C<LocalHost> PARSING
  
  To support the C<IO::Socket::INET> API, the host and port information may be
  passed in a single string rather than as two separate arguments.
  
  If either C<LocalHost> or C<PeerHost> (or their C<...Addr> synonyms) have any
  of the following special forms then special parsing is applied.
  
  The value of the C<...Host> argument will be split to give both the hostname
  and port (or service name):
  
   hostname.example.org:http    # Host name
   192.0.2.1:80                 # IPv4 address
   [2001:db8::1]:80             # IPv6 address
  
  In each case, the port or service name (e.g. C<80>) is passed as the
  C<LocalService> or C<PeerService> argument.
  
  Either of C<LocalService> or C<PeerService> (or their C<...Port> synonyms) can
  be either a service name, a decimal number, or a string containing both a
  service name and number, in a form such as
  
   http(80)
  
  In this case, the name (C<http>) will be tried first, but if the resolver does
  not understand it then the port number (C<80>) will be used instead.
  
  If the C<...Host> argument is in this special form and the corresponding
  C<...Service> or C<...Port> argument is also defined, the one parsed from
  the C<...Host> argument will take precedence and the other will be ignored.
  
  =head2 ( $host, $port ) = IO::Socket::IP->split_addr( $addr )
  
  Utility method that provides the parsing functionality described above.
  Returns a 2-element list, containing either the split hostname and port
  description if it could be parsed, or the given address and C<undef> if it was
  not recognised.
  
   IO::Socket::IP->split_addr( "hostname:http" )
                                # ( "hostname",  "http" )
  
   IO::Socket::IP->split_addr( "192.0.2.1:80" )
                                # ( "192.0.2.1", "80"   )
  
   IO::Socket::IP->split_addr( "[2001:db8::1]:80" )
                                # ( "2001:db8::1", "80" )
  
   IO::Socket::IP->split_addr( "something.else" )
                                # ( "something.else", undef )
  
  =cut
  
  sub split_addr
  {
     shift;
     my ( $addr ) = @_;
  
     local ( $1, $2 ); # Placate a taint-related bug; [perl #67962]
     if( $addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or
         $addr =~ m/\A([^\s:]*):([^\s:]*)\z/ ) {
        return ( $1, $2 ) if defined $2 and length $2;
        return ( $1, undef );
     }
  
     return ( $addr, undef );
  }
  
  =head2 $addr = IO::Socket::IP->join_addr( $host, $port )
  
  Utility method that performs the reverse of C<split_addr>, returning a string
  formed by joining the specified host address and port number. The host address
  will be wrapped in C<[]> brackets if required (because it is a raw IPv6
  numeric address).
  
  This can be especially useful when combined with the C<sockhost_service> or
  C<peerhost_service> methods.
  
   say "Connected to ", IO::Socket::IP->join_addr( $sock->peerhost_service );
  
  =cut
  
  sub join_addr
  {
     shift;
     my ( $host, $port ) = @_;
  
     $host = "[$host]" if $host =~ m/:/;
  
     return join ":", $host, $port if defined $port;
     return $host;
  }
  
  # Since IO::Socket->new( Domain => ... ) will delete the Domain parameter
  # before calling ->configure, we need to keep track of which it was
  
  package # hide from indexer
     IO::Socket::IP::_ForINET;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET() } );
  }
  
  package # hide from indexer
     IO::Socket::IP::_ForINET6;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET6() } );
  }
  
  =head1 C<IO::Socket::INET> INCOMPATIBILITES
  
  =over 4
  
  =item *
  
  The behaviour enabled by C<MultiHomed> is in fact implemented by
  C<IO::Socket::IP> as it is required to correctly support searching for a
  useable address from the results of the C<getaddrinfo(3)> call. The
  constructor will ignore the value of this argument, except if it is defined
  but false. An exception is thrown in this case, because that would request it
  disable the C<getaddrinfo(3)> search behaviour in the first place.
  
  =item *
  
  C<IO::Socket::IP> implements both the C<Blocking> and C<Timeout> parameters,
  but it implements the interaction of both in a different way.
  
  In C<::INET>, supplying a timeout overrides the non-blocking behaviour,
  meaning that the C<connect()> operation will still block despite that the
  caller asked for a non-blocking socket. This is not explicitly specified in
  its documentation, nor does this author believe that is a useful behaviour -
  it appears to come from a quirk of implementation.
  
  In C<::IP> therefore, the C<Blocking> parameter takes precedence - if a
  non-blocking socket is requested, no operation will block. The C<Timeout>
  parameter here simply defines the maximum time that a blocking C<connect()>
  call will wait, if it blocks at all.
  
  In order to specifically obtain the "blocking connect then non-blocking send
  and receive" behaviour of specifying this combination of options to C<::INET>
  when using C<::IP>, perform first a blocking connect, then afterwards turn the
  socket into nonblocking mode.
  
   my $sock = IO::Socket::IP->new(
      PeerHost => $peer,
      Timeout => 20,
   ) or die "Cannot connect - $@";
  
   $sock->blocking( 0 );
  
  This code will behave identically under both C<IO::Socket::INET> and
  C<IO::Socket::IP>.
  
  =back
  
  =cut
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Investigate whether C<POSIX::dup2> upsets BSD's C<kqueue> watchers, and if so,
  consider what possible workarounds might be applied.
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
IO_SOCKET_IP

$fatpacked{"JSON/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_TINY';
  package JSON::Tiny;
  
  # Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
  # License: Artistic 2.0 license.
  # http://www.perlfoundation.org/artistic_license_2_0
  
  use strict;
  use warnings;
  use Carp 'croak';
  use Exporter 'import';
  use Scalar::Util 'blessed';
  use Encode ();
  
  our $VERSION = '0.56';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Literal names
  # Users may override Booleans with literal 0 or 1 if desired.
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  
  # Escaped special character map with u2028 and u2029
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {$FALSE}  ## no critic (prototypes)
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {$TRUE} ## no critic (prototypes)
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length( local $_ = shift );
  
      # UTF-8
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
    
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos $str, length $str;
  }
  
  sub _decode_value {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if m/\G"/gc;
  
    # Object
    return _decode_object() if m/\G\{/gc;
  
    # Array
    return _decode_array() if m/\G\[/gc;
  
    # Number
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
  
    # True
    return $TRUE if m/\Gtrue/gc;
  
    # False
    return $FALSE if m/\Gfalse/gc;
  
    # Null
    return undef if m/\Gnull/gc;  ## no critic (return)
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
  
      # Blessed reference with TO_JSON method
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
  
    # Null
    return 'null' unless defined $value;
  
  
    # Number (bitwise operators change behavior based on the internal value type)
  
    # "0" & $x will modify the flags on the "0" on perl < 5.14, so use a copy
    my $zero = "0";
    # "0" & $num -> 0. "0" & "" -> "". "0" & $string -> a character.
    # this maintains the internal type but speeds up the xor below.
    my $check = $zero & $value;
    return $value
      if length $check
      # 0 ^ itself          -> 0    (false)
      # $character ^ itself -> "\0" (true)
      && !($check ^ $check)
      # filter out "upgraded" strings whose numeric form doesn't strictly match
      && 0 + $value eq $value
      # filter out inf and nan
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  # Emulate boolean type
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
JSON_TINY

$fatpacked{"LockFile/Lock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_LOCK';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Lock.pm,v $
  ;# Revision 0.3  2007/09/28 19:20:14  jv
  ;# Track where lock was issued in the code.
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:16:28  ram
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:04  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Lock;
  
  #
  # A lock instance -- deferred class.
  #
  
  #
  # ->_lock_init
  #
  # Common lock initialization
  #
  # Attributes:
  #
  #	scheme		the LockFile::* object that created the lock
  #	filename	where lock was taken
  #	line		line in filename where lock was taken
  #
  sub _lock_init {
  	my $self = shift;
  	my ($scheme, $filename, $line) = @_;
  	$self->{'scheme'} = $scheme;
  	$self->{'filename'} = $filename;
  	$self->{'line'} = $line;
  }
  
  #
  # Common attribute access
  #
  
  sub scheme		{ $_[0]->{'scheme'} }
  sub filename	{ $_[0]->{'filename'} }
  sub line		{ $_[0]->{'line'} }
  
  #
  # ->release
  #
  # Release the lock
  #
  sub release {
  	my $self = shift;
  	return $self->scheme->release($self);
  }
  
  #
  # ->where
  #
  # Returns '"filename", line #' where lock was taken.
  #
  sub where {
  	my $self = shift;
  	return sprintf '"%s", line %d', $self->filename, $self->line;
  }
  
  1;
  
LOCKFILE_LOCK

$fatpacked{"LockFile/Lock/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_LOCK_SIMPLE';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Simple.pm,v $
  ;# Revision 0.3  2007/09/28 19:18:27  jv
  ;# Track where lock was issued in the code.
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:16:35  ram
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:04  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Lock::Simple;
  
  require LockFile::Lock;
  
  use vars qw(@ISA);
  
  @ISA = qw(LockFile::Lock);
  
  #
  # ->make
  #
  # Creation routine
  #
  # Attributes:
  #
  #	scheme		the LockFile::* object that created the lock
  #	file		the locked file
  #	format		the format used to create the lockfile
  #	filename	where lock was taken
  #	line		line in filename where lock was taken
  #
  sub make {
  	my $self = bless {}, shift;
  	my ($scheme, $file, $format, $filename, $line) = @_;
  	$self->{'file'} = $file;
  	$self->{'format'} = $format;
  	$self->_lock_init($scheme, $filename, $line);
  	return $self;
  }
  
  #
  # Attribute access
  #
  
  sub file	{ $_[0]->{'file'} }
  sub format	{ $_[0]->{'format'} }
  
  1;
  
LOCKFILE_LOCK_SIMPLE

$fatpacked{"LockFile/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_MANAGER';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Manager.pm,v $
  ;# Revision 0.2  1999/12/07 20:51:05  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Manager;
  
  #
  # A pool of all created locks.
  #
  
  my $MANAGER = undef;		# The main manager
  
  #
  # ->make
  #
  # Creates a new LockFile::Manager to hold the locks.
  #
  # Attributes:
  #
  #	pool		hash of LockFile::Lock objects
  #	wfunc		warning function to be called
  #	efunc		error function to be called
  #
  sub make {
  	my $self = bless {}, shift;
  	my ($wfunc, $efunc) = @_;
  	$self->{'pool'} = {};
  	$self->{'wfunc'} = $wfunc;
  	$self->{'efunc'} = $efunc;
  	return $self;
  }
  
  #
  # Attribute access
  #
  
  sub pool	{ $_[0]->{'pool'} }
  sub wfunc	{ $_[0]->{'wfunc'} }
  sub efunc	{ $_[0]->{'efunc'} }
  
  #
  # ->manager		-- "once" function
  #
  # Returns the main manager.
  #
  sub manager {
  	my ($class, $wfunc, $efunc) = @_;
  	return $MANAGER || ($MANAGER = $class->make($wfunc, $efunc));
  }
  
  #
  # ->remember
  #
  # Remember created locks.
  #
  sub remember {
  	my $self = shift;
  	my ($lock) = @_;				# A LockFile::Lock object
  	my $pool = $self->pool;
  	if (exists $pool->{$lock}) {
  		&{$self->efunc}("lock $lock already remembered");
  		return;
  	}
  	$pool->{$lock} = $lock;
  }
  
  #
  # ->forget
  #
  # Forget about a lock.
  #
  sub forget {
  	my $self = shift;
  	my ($lock) = @_;				# A LockFile::Lock object
  	my $pool = $self->pool;
  	unless (exists $pool->{$lock}) {
  		&{$self->efunc}("lock $lock not remembered yet");
  		return;
  	}
  	delete $pool->{$lock};
  }
  
  #
  # ->release_all
  #
  # Release all the locks.
  #
  sub release_all {
  	my $self = shift;
  	my $pool = $self->pool;
  	my $locks = scalar keys %$pool;
  	return unless $locks;
  
  	my $s = $locks == 1 ? '' : 's';
  	&{$self->wfunc}("releasing $locks pending lock$s...");
  
  	foreach my $lock (values %$pool) {
  		$lock->release;
  	}
  }
  
  sub END { $MANAGER->release_all if defined $MANAGER }
  
  1;
  
LOCKFILE_MANAGER

$fatpacked{"LockFile/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_SIMPLE';
  ;# $Id$
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Simple.pm,v $
  ;# Revision 0.4  2007/09/28 19:22:05  jv
  ;# Bump version.
  ;#
  ;# Revision 0.3  2007/09/28 19:19:41  jv
  ;# Revision 0.2.1.5  2000/09/18 19:55:07  ram
  ;# patch5: fixed computation of %F and %D when no '/' in file name
  ;# patch5: fixed OO example of lock to emphasize check on returned value
  ;# patch5: now warns when no lockfile is found during unlocking
  ;#
  ;# Revision 0.2.1.4  2000/08/15 18:41:43  ram
  ;# patch4: updated version number, grrr...
  ;#
  ;# Revision 0.2.1.3  2000/08/15 18:37:37  ram
  ;# patch3: fixed non-working "-wfunc => undef" due to misuse of defined()
  ;# patch3: check for stale lock while we wait for it
  ;# patch3: untaint pid before running kill() for -T scripts
  ;#
  ;# Revision 0.2.1.2  2000/03/02 22:35:02  ram
  ;# patch2: allow "undef" in -efunc and -wfunc to suppress logging
  ;# patch2: documented how to force warn() despite Log::Agent being there
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:18:10  ram
  ;# patch1: logerr and logwarn are autoloaded, need to check something real
  ;# patch1: forbid re-lock of a file we already locked
  ;# patch1: force $\ to be undef prior to writing the PID to lockfile
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2.1.5  2000/09/18 19:55:07  ram
  ;# patch5: fixed computation of %F and %D when no '/' in file name
  ;# patch5: fixed OO example of lock to emphasize check on returned value
  ;# patch5: now warns when no lockfile is found during unlocking
  ;#
  ;# Revision 0.2.1.4  2000/08/15 18:41:43  ram
  ;# patch4: updated version number, grrr...
  ;#
  ;# Revision 0.2.1.3  2000/08/15 18:37:37  ram
  ;# patch3: fixed non-working "-wfunc => undef" due to misuse of defined()
  ;# patch3: check for stale lock while we wait for it
  ;# patch3: untaint pid before running kill() for -T scripts
  ;#
  ;# Revision 0.2.1.2  2000/03/02 22:35:02  ram
  ;# patch2: allow "undef" in -efunc and -wfunc to suppress logging
  ;# patch2: documented how to force warn() despite Log::Agent being there
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:18:10  ram
  ;# patch1: logerr and logwarn are autoloaded, need to check something real
  ;# patch1: forbid re-lock of a file we already locked
  ;# patch1: force $\ to be undef prior to writing the PID to lockfile
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:05  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Simple;
  
  #
  # This package extracts the simple locking logic used by mailagent-3.0
  # into a standalone Perl module to be reused in other applications.
  #
  
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  use Sys::Hostname;
  require Exporter;
  require LockFile::Lock::Simple;
  eval "use Log::Agent";
  
  @ISA = qw(Exporter);
  @EXPORT = ();
  @EXPORT_OK = qw(lock trylock unlock);
  $VERSION = '0.208';
  
  my $LOCKER = undef;			# Default locking object
  
  #
  # ->make
  #
  # Create a file locking object, responsible for holding the locking
  # parameters to be used by all the subsequent locks requested from
  # this locking object.
  #
  # Configuration attributes:
  #
  #	autoclean		keep track of locks and release pending one at END time
  #   max				max number of attempts
  #	delay			seconds to wait between attempts
  #	format			how to derive lockfile from file to be locked
  #	hold			max amount of seconds before breaking lock (0 for never)
  #	ext				lock extension
  #	nfs				true if lock must "work" on top of NFS
  #	stale			try to detect stale locks via SIGZERO and delete them
  #	warn			flag to turn warnings on
  #	wmin			warn once after that many waiting seconds
  #	wafter			warn every that many seconds after first warning
  #	wfunc			warning function to be called
  #	efunc			error function to be called
  #
  # Additional attributes:
  #
  #	manager			lock manager, used when autoclean
  #	lock_by_file	returns lock by filename
  #
  # The creation routine first and sole argument is a "hash table list" listing
  # all the configuration attributes. Missing attributes are given a default
  # value. A call to ->configure can alter the configuration parameters of
  # an existing object.
  #
  sub make {
  	my $self = bless {}, shift;
  	my (@hlist) = @_;
  
  	# Set configuration defaults, then override with user preferences
  	$self->{'max'} = 30;
  	$self->{'delay'} = 2;
  	$self->{'hold'} = 3600;
  	$self->{'ext'} = '.lock';
  	$self->{'nfs'} = 0;
  	$self->{'stale'} = 0;
  	$self->{'warn'} = 1;
  	$self->{'wmin'} = 15;
  	$self->{'wafter'} = 20;
  	$self->{'autoclean'} = 0;
  	$self->{'lock_by_file'} = {};
  
  	# The logxxx routines are autoloaded, so need to check for @EXPORT
  	$self->{'wfunc'} = @Log::Agent::EXPORT ? \&logwarn : \&core_warn;
  	$self->{'efunc'} = @Log::Agent::EXPORT ?  \&logerr  : \&core_warn;
  
  	$self->configure(@hlist);		# Will init "manager" if necessary
  	return $self;
  }
  
  #
  # ->locker		-- "once" function
  #
  # Compute the default locking object.
  #
  sub locker {
  	return $LOCKER || ($LOCKER = LockFile::Simple->make('-warn' => 1));
  }
  
  #
  # ->configure
  #
  # Extract known configuration parameters from the specified hash list
  # and use their values to change the object's corresponding parameters.
  #
  # Parameters are specified as (-warn => 1, -ext => '.lock') for instance.
  #
  sub configure {
  	my $self = shift;
  	my (%hlist) = @_;
  	my @known = qw(
  		autoclean
  		max delay hold format ext nfs warn wfunc wmin wafter efunc stale
  	);
  
  	foreach my $attr (@known) {
  		$self->{$attr} = $hlist{"-$attr"} if exists $hlist{"-$attr"};
  	}
  
  	$self->{'wfunc'} = \&no_warn unless defined $self->{'wfunc'};
  	$self->{'efunc'} = \&no_warn unless defined $self->{'efunc'};
  
  	if ($self->autoclean) {
  		require LockFile::Manager;
  		# Created via "once" function
  		$self->{'manager'} = LockFile::Manager->manager(
  			$self->wfunc, $self->efunc);
  	}
  }
  
  #
  # Attribute access
  #
  
  sub max				{ $_[0]->{'max'} }
  sub delay			{ $_[0]->{'delay'} }
  sub format			{ $_[0]->{'format'} }
  sub hold			{ $_[0]->{'hold'} }
  sub nfs				{ $_[0]->{'nfs'} }
  sub stale			{ $_[0]->{'stale'} }
  sub ext				{ $_[0]->{'ext'} }
  sub warn			{ $_[0]->{'warn'} }
  sub wmin			{ $_[0]->{'wmin'} }
  sub wafter			{ $_[0]->{'wafter'} }
  sub wfunc			{ $_[0]->{'wfunc'} }
  sub efunc			{ $_[0]->{'efunc'} }
  sub autoclean		{ $_[0]->{'autoclean'} }
  sub lock_by_file	{ $_[0]->{'lock_by_file'} }
  sub manager			{ $_[0]->{'manager'} }
  
  #
  # Warning and error reporting -- Log::Agent used only when available
  #
  
  sub core_warn	{ CORE::warn(@_) }
  sub no_warn		{ return }
  
  #
  # ->lock
  #
  # Lock specified file, possibly using alternate file "format".
  # Returns whether file was locked or not at the end of the configured
  # blocking period by providing the LockFile::Lock instance if successful.
  #
  # For quick and dirty scripts wishing to use locks, create the locking
  # object if not invoked as a method, turning on warnings.
  #
  sub lock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be locked, lock format
  	return $self->take_lock($file, $format, 0);
  }
  
  #
  # ->trylock
  #
  # Attempt to lock specified file, possibly using alternate file "format".
  # If the file is already locked, don't block and return undef. The
  # LockFile::Lock instance is returned upon success.
  #
  # For quick and dirty scripts wishing to use locks, create the locking
  # object if not invoked as a method, turning on warnings.
  #
  sub trylock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be locked, lock format
  	return $self->take_lock($file, $format, 1);
  }
  
  #
  # ->take_lock
  #
  # Common code for ->lock and ->trylock.
  # Returns a LockFile::Lock object on success, undef on failure.
  #
  sub take_lock {
  	my $self = shift;
  	my ($file, $format, $tryonly) = @_;
  
  	#
  	# If lock was already taken by us, it's an error when $tryonly is 0.
  	# Otherwise, simply fail to get the lock.
  	#
  
  	my $lock = $self->lock_by_file->{$file};
  	if (defined $lock) {
  		my $where = $lock->where;
  		&{$self->efunc}("file $file already locked at $where") unless $tryonly;
  		return undef;
  	}
  
  	my $locked = $self->_acs_lock($file, $format, $tryonly);
  	return undef unless $locked;
  
  	#
  	# Create LockFile::Lock object
  	#
  
  	my ($package, $filename, $line) = caller(1);
  	$lock = LockFile::Lock::Simple->make($self, $file, $format,
  		$filename, $line);
  	$self->manager->remember($lock) if $self->autoclean;
  	$self->lock_by_file->{$file} = $lock;
  
  	return $lock;
  }
  
  #
  # ->unlock
  #
  # Unlock file.
  # Returns true if file was unlocked.
  #
  sub unlock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be unlocked, lock format
  
  	if (defined $format) {
  		require Carp;
  		Carp::carp("2nd argument (format) is no longer needed nor used");
  	}
  
  	#
  	# Retrieve LockFile::Lock object
  	#
  
  	my $lock = $self->lock_by_file->{$file};
  
  	unless (defined $lock) {
  		&{$self->efunc}("file $file not currently locked");
  		return undef;
  	}
  
  	return $self->release($lock);
  }
  
  #
  # ->release			-- not exported (i.e. not documented)
  #
  # Same a unlock, but we're passed a LockFile::Lock object.
  # And we MUST be called as a method (usually via LockFile::Lock, not user code).
  #
  # Returns true if file was unlocked.
  #
  sub release {
  	my $self = shift;
  	my ($lock) = @_;
  	my $file = $lock->file;
  	my $format = $lock->format;
  	$self->manager->forget($lock) if $self->autoclean;
  	delete $self->lock_by_file->{$file};
  	return $self->_acs_unlock($file, $format);
  }
  
  #
  # ->lockfile
  #
  # Return the name of the lockfile, given the file name to lock and the custom
  # string provided by the user. The following macros are substituted:
  #	%D: the file dir name
  #   %f: the file name (full path)
  #   %F: the file base name (last path component)
  #   %p: the process's pid
  #   %%: a plain % character
  #
  sub lockfile {
  	my $self = shift;
  	my ($file, $format) = @_;
  	local $_ = defined($format) ? $format : $self->format;
  	s/%%/\01/g;				# Protect double percent signs
  	s/%/\02/g;				# Protect against substitutions adding their own %
  	s/\02f/$file/g;			# %f is the full path name
  	s/\02D/&dir($file)/ge;	# %D is the dir name
  	s/\02F/&base($file)/ge;	# %F is the base name
  	s/\02p/$$/g;			# %p is the process's pid
  	s/\02/%/g;				# All other % kept as-is
  	s/\01/%/g;				# Restore escaped % signs
  	$_;
  }
  
  # Return file basename (last path component)
  sub base {
  	my ($file) = @_;
  	my ($base) = $file =~ m|^.*/(.*)|;
  	return ($base eq '') ? $file : $base;
  }
  
  # Return dirname
  sub dir {
  	my ($file) = @_;
  	my ($dir) = $file =~ m|^(.*)/.*|;
  	return ($dir eq '') ? '.' : $dir;
  }
  
  #
  # _acs_lock			-- private
  #
  # Internal locking routine.
  #
  # If $try is true, don't wait if the file is already locked.
  # Returns true if the file was locked.
  #
  sub _acs_lock {		## private
  	my $self = shift;
  	my ($file, $format, $try) = @_;
  	my $max = $self->max;
  	my $delay = $self->delay;
  	my $stamp = $$;
  
  	# For NFS, we need something more unique than the process's PID
  	$stamp .= ':' . hostname if $self->nfs;
  
  	# Compute locking file name -- hardwired default format is "%f.lock"
  	my $lockfile = $file . $self->ext;
  	$format = $self->format unless defined $format;
  	$lockfile = $self->lockfile($file, $format) if defined $format;
  
  	# Detect stale locks or break lock if held for too long
  	$self->_acs_stale($file, $lockfile) if $self->stale;
  	$self->_acs_check($file, $lockfile) if $self->hold;
  
  	my $waited = 0;					# Amount of time spent sleeping
  	my $lastwarn = 0;				# Last time we warned them...
  	my $warn = $self->warn;
  	my ($wmin, $wafter, $wfunc);
  	($wmin, $wafter, $wfunc) = 
  		($self->wmin, $self->wafter, $self->wfunc) if $warn;
  	my $locked = 0;
  	my $mask = umask(0333);			# No write permission
  	local *FILE;
  
  	while ($max-- > 0) {
  		if (-f $lockfile) {
  			next unless $try;
  			umask($mask);
  			return 0;				# Already locked
  		}
  
  		# Attempt to create lock
  		if (open(FILE, ">$lockfile")) {
  			local $\ = undef;
  			print FILE "$stamp\n";
  			close FILE;
  			open(FILE, $lockfile);	# Check lock
  			my $l;
  			chop($l = <FILE>);
  			$locked = $l eq $stamp;
  			$l = <FILE>;			# Must be EOF
  			$locked = 0 if defined $l; 
  			close FILE;
  			last if $locked;		# Lock seems to be ours
  		} elsif ($try) {
  			umask($mask);
  			return 0;				# Already locked, or cannot create lock
  		}
  	} continue {
  		sleep($delay);				# Busy: wait
  		$waited += $delay;
  
  		# Warn them once after $wmin seconds and then every $wafter seconds
  		if (
  			$warn &&
  				((!$lastwarn && $waited > $wmin) ||
  				($waited - $lastwarn) > $wafter)
  		) {
  			my $waiting  = $lastwarn ? 'still waiting' : 'waiting';
  			my $after  = $lastwarn ? 'after' : 'since';
  			my $s = $waited == 1 ? '' : 's';
  			&$wfunc("$waiting for $file lock $after $waited second$s");
  			$lastwarn = $waited;
  		}
  
  		# While we wait, existing lockfile may become stale or too old
  		$self->_acs_stale($file, $lockfile) if $self->stale;
  		$self->_acs_check($file, $lockfile) if $self->hold;
  	}
  
  	umask($mask);
  	return $locked;
  }
  
  #
  # ->_acs_unlock		-- private
  #
  # Unlock file. If lock format is specified, it must match the one used
  # at lock time.
  #
  # Return true if file was indeed locked by us and is now properly unlocked.
  #
  sub _acs_unlock {	## private
  	my $self = shift;
  	my ($file, $format) = @_;		# Locked file, locking format
  	my $stamp = $$;
  	$stamp .= ':' . hostname if $self->nfs;
  
  	# Compute locking file name -- hardwired default format is "%f.lock"
  	my $lockfile = $file . $self->ext;
  	$format = $self->format unless defined $format;
  	$lockfile = $self->lockfile($file, $format) if defined $format;
  
  	local *FILE;
  	my $unlocked = 0;
  
  	if (-f $lockfile) {
  		open(FILE, $lockfile);
  		my $l;
  		chop($l = <FILE>);
  		close FILE;
  		if ($l eq $stamp) {			# Pid (plus hostname possibly) is OK
  			$unlocked = 1;
  			unless (unlink $lockfile) {
  				$unlocked = 0;
  				&{$self->efunc}("cannot unlock $file: $!");
  			}
  		} else {
  			&{$self->efunc}("cannot unlock $file: lock not owned");
  		}
  	} else {
  		&{$self->wfunc}("no lockfile found for $file");
  	}
  
  	return $unlocked;				# Did we successfully unlock?
  }
  
  #
  # ->_acs_check
  #
  # Make sure lock lasts only for a reasonable time. If it has expired,
  # then remove the lockfile.
  #
  # This is not enabled by default because there is a race condition between
  # the time we stat the file and the time we unlink the lockfile.
  #
  sub _acs_check {
  	my $self = shift;
  	my ($file, $lockfile) = @_;
  
  	my $mtime = (stat($lockfile))[9];
  	return unless defined $mtime;	# Assume file does not exist
  	my $hold = $self->hold;
  
  	# If file too old to be considered stale?
  	if ((time - $mtime) > $hold) {
  
  		# RACE CONDITION -- shall we lock the lockfile?
  
  		unless (unlink $lockfile) {
  			&{$self->efunc}("cannot unlink $lockfile: $!");
  			return;
  		}
  
  		if ($self->warn) {
  			my $s = $hold == 1 ? '' : 's';
  			&{$self->wfunc}("UNLOCKED $file (lock older than $hold second$s)");
  		}
  	}
  }
  
  #
  # ->_acs_stale
  #
  # Detect stale locks and remove them. This works by sending a SIGZERO to
  # the pid held in the lockfile. If configured for NFS, only processes
  # on the same host than the one holding the lock will be able to perform
  # the check.
  #
  # Stale lock detection is not enabled by default because there is a race
  # condition between the time we check for the pid, and the time we unlink
  # the lockfile: we could well be unlinking a new lockfile created inbetween.
  #
  sub _acs_stale {
  	my $self = shift;
  	my ($file, $lockfile) = @_;
  
  	local *FILE;
  	open(FILE, $lockfile) || return;
  	my $stamp;
  	chop($stamp = <FILE>);
  	close FILE;
  
  	my ($pid, $hostname);
  
  	if ($self->nfs) {
  		($pid, $hostname) = $stamp =~ /^(\d+):(\S+)/;
  		my $local = hostname;
  		return if $local ne $hostname;
  		return if kill 0, $pid;
  		$hostname = " on $hostname";
  	} else {
  		($pid) = $stamp =~ /^(\d+)$/;		# Untaint $pid for kill()
  		$hostname = '';
  		return if kill 0, $pid;
  	}
  
  	# RACE CONDITION -- shall we lock the lockfile?
  
  	unless (unlink $lockfile) {
  		&{$self->efunc}("cannot unlink stale $lockfile: $!");
  		return;
  	}
  
  	&{$self->wfunc}("UNLOCKED $file (stale lock by PID $pid$hostname)");
  }
  
  1;
  
  ########################################################################
  
  =head1 NAME
  
  LockFile::Simple - simple file locking scheme
  
  =head1 SYNOPSIS
  
   use LockFile::Simple qw(lock trylock unlock);
  
   # Simple locking using default settings
   lock("/some/file") || die "can't lock /some/file\n";
   warn "already locked\n" unless trylock("/some/file");
   unlock("/some/file");
  
   # Build customized locking manager object
   $lockmgr = LockFile::Simple->make(-format => '%f.lck',
  	-max => 20, -delay => 1, -nfs => 1);
  
   $lockmgr->lock("/some/file") || die "can't lock /some/file\n";
   $lockmgr->trylock("/some/file");
   $lockmgr->unlock("/some/file");
  
   $lockmgr->configure(-nfs => 0);
  
   # Using lock handles
   my $lock = $lockmgr->lock("/some/file");
   $lock->release;
  
  =head1 DESCRIPTION
  
  This simple locking scheme is not based on any file locking system calls
  such as C<flock()> or C<lockf()> but rather relies on basic file system
  primitives and properties, such as the atomicity of the C<write()> system
  call. It is not meant to be exempt from all race conditions, especially over
  NFS. The algorithm used is described below in the B<ALGORITHM> section.
  
  It is possible to customize the locking operations to attempt locking
  once every 5 seconds for 30 times, or delete stale locks (files that are
  deemed too ancient) before attempting the locking.
  
  =head1 ALGORITHM
  
  The locking alogrithm attempts to create a I<lockfile> using a temporarily
  redefined I<umask> (leaving only read rights to prevent further create
  operations). It then writes the process ID (PID) of the process and closes
  the file. That file is then re-opened and read. If we are able to read the
  same PID we wrote, and only that, we assume the locking is successful.
  
  When locking over NFS, i.e. when the one of the potentially locking processes
  could access the I<lockfile> via NFS, then writing the PID is not enough.
  We also write the hostname where locking is attempted to ensure the data
  are unique.
  
  =head1 CUSTOMIZING
  
  Customization is only possible by using the object-oriented interface,
  since the configuration parameters are stored within the object. The
  object creation routine C<make> can be given configuration parmeters in
  the form a "hash table list", i.e. a list of key/value pairs. Those
  parameters can later be changed via C<configure> by specifying a similar
  list of key/value pairs.
  
  To benefit from the bareword quoting Perl offers, all the parameters must
  be prefixed with the C<-> (minus) sign, as in C<-format> for the I<format>
  parameter..  However, when querying the object, the minus must be omitted,
  as in C<$obj-E<gt>format>.
  
  Here are the available configuration parmeters along with their meaning,
  listed in alphabetical order:
  
  =over 4
  
  =item I<autoclean>
  
  When true, all locks are remembered and pending ones are automatically
  released when the process exits normally (i.e. whenever Perl calls the
  END routines).
  
  =item I<delay>
  
  The amount of seconds to wait between locking attempts when the file appears
  to be already locked. Default is 2 seconds.
  
  =item I<efunc>
  
  A function pointer to dereference when an error is to be reported. By default,
  it redirects to the logerr() routine if you have Log::Agent installed,
  to Perl's warn() function otherwise.
  
  You may set it explicitely to C<\&LockFile::Simple::core_warn> to force the
  use of Perl's warn() function, or to C<undef> to suppress logging.
  
  =item I<ext>
  
  The locking extension that must be added to the file path to be locked to
  compute the I<lockfile> path. Default is C<.lock> (note that C<.> is part
  of the extension and can therefore be changed). Ignored when I<format> is
  also used.
  
  =item I<format>
  
  Using this parmeter supersedes the I<ext> parmeter. The formatting string
  specified is run through a rudimentary macro expansion to derive the
  I<lockfile> path from the file to be locked. The following macros are
  available:
  
      %%	A real % sign
      %f	The full file path name
      %D	The directory where the file resides
      %F	The base name of the file
      %p	The process ID (PID)
  
  The default is to use the locking extension, which itself is C<.lock>, so
  it is as if the format used was C<%f.lock>, but one could imagine things
  like C</var/run/%F.%p>, i.e. the I<lockfile> does not necessarily lie besides
  the locked file (which could even be missing).
  
  When locking, the locking format can be specified to supersede the object
  configuration itself.
  
  =item I<hold>
  
  Maximum amount of seconds we may hold a lock. Past that amount of time,
  an existing I<lockfile> is removed, being taken for a stale lock. Default
  is 3600 seconds. Specifying 0 prevents any forced unlocking.
  
  =item I<max>
  
  Amount of times we retry locking when the file is busy, sleeping I<delay>
  seconds between attempts. Defaults to 30.
  
  =item I<nfs>
  
  A boolean flag, false by default. Setting it to true means we could lock
  over NFS and therefore the hostname must be included along with the process
  ID in the stamp written to the lockfile.
  
  =item I<stale>
  
  A boolean flag, false by default. When set to true, we attempt to detect
  stale locks and break them if necessary.
  
  =item I<wafter>
  
  Stands for I<warn after>. It is the number of seconds past the first
  warning during locking time after which a new warning should be emitted.
  See I<warn> and I<wmin> below. Default is 20.
  
  =item I<warn>
  
  A boolean flag, true by default. To suppress any warning, set it to false.
  
  =item I<wfunc>
  
  A function pointer to dereference when a warning is to be issued. By default,
  it redirects to the logwarn() routine if you have Log::Agent installed,
  to Perl's warn() function otherwise.
  
  You may set it explicitely to C<\&LockFile::Simple::core_warn> to force the
  use of Perl's warn() function, or to C<undef> to suppress logging.
  
  =item I<wmin>
  
  The minimal amount of time when waiting for a lock after which a first
  warning must be emitted, if I<warn> is true. After that, a warning will
  be emitted every I<wafter> seconds. Defaults to 15.
  
  =back
  
  Each of those configuration attributes can be queried on the object directly:
  
      $obj = LockFile::Simple->make(-nfs => 1);
      $on_nfs = $obj->nfs;
  
  Those are pure query routines, i.e. you cannot say:
  
      $obj->nfs(0);                  # WRONG
      $obj->configure(-nfs => 0);    # Right
  
  to turn of the NFS attribute. That is because my OO background chokes
  at having querying functions with side effects.
  
  =head1 INTERFACE
  
  The OO interface documented below specifies the signature and the
  semantics of the operations. Only the C<lock>, C<trylock> and
  C<unlock> operation can be imported and used via a non-OO interface,
  with the exact same signature nonetheless.
  
  The interface contains all the attribute querying routines, one for
  each configuration parmeter documented in the B<CUSTOMIZING> section
  above, plus, in alphabetical order:
  
  =over 4
  
  =item configure(I<-key =E<gt> value, -key2 =E<gt> value2, ...>)
  
  Change the specified configuration parameters and silently ignore
  the invalid ones.
  
  =item lock(I<file>, I<format>)
  
  Attempt to lock the file, using the optional locking I<format> if
  specified, otherwise using the default I<format> scheme configured
  in the object, or by simply appending the I<ext> extension to the file.
  
  If the file is already locked, sleep I<delay> seconds before retrying,
  repeating try/sleep at most I<max> times. If warning is configured,
  a first warning is emitted after waiting for I<wmin> seconds, and
  then once every I<wafter> seconds, via  the I<wfunc> routine.
  
  Before the first attempt, and if I<hold> is non-zero, any existing
  I<lockfile> is checked for being too old, and it is removed if found
  to be stale. A warning is emitted via the I<wfunc> routine in that
  case, if allowed.
  
  Likewise, if I<stale> is non-zero, a check is made to see whether
  any locking process is still around (only if the lock holder is on the
  same machine when NFS locking is configured). Should the locking
  process be dead, the I<lockfile> is declared stale and removed.
  
  Returns a lock handle if the file has been successfully locked, which
  does not necessarily needs to be kept around. For instance:
  
      $obj->lock('ppp', '/var/run/ppp.%p');
      <do some work>
      $obj->unlock('ppp');
  
  or, using OO programming:
  
      my $lock = $obj->lock('ppp', '/var/run/ppp.%p') ||;
          die "Can't lock for ppp\n";
      <do some work>
      $lock->relase;   # The only method defined for a lock handle
  
  i.e. you don't even have to know which file was locked to release it, since
  there is a lock handle right there that knows enough about the lock parameters.
  
  =item lockfile(I<file>, I<format>)
  
  Simply compute the path of the I<lockfile> that would be used by the
  I<lock> procedure if it were passed the same parameters.
  
  =item make(I<-key =E<gt> value, -key2 =E<gt> value2, ...>)
  
  The creation routine for the simple lock object. Returns a blessed hash
  reference.
  
  =item trylock(I<file>, I<format>)
  
  Same as I<lock> except that it immediately returns false and does not
  sleep if the to-be-locked file is busy, i.e. already locked. Any
  stale locking file is removed, as I<lock> would do anyway.
  
  Returns a lock hande if the file has been successfully locked.
  
  =item unlock(I<file>)
  
  Unlock the I<file>.
  
  =back
  
  =head1 BUGS
  
  The algorithm is not bullet proof.  It's only reasonably safe.  Don't bet
  the integrity of a mission-critical database on it though.
  
  The sysopen() call should probably be used with the C<O_EXCL|O_CREAT> flags
  to be on the safer side. Still, over NFS, this is not an atomic operation
  anyway.
  
  B<BEWARE>: there is a race condition between the time we decide a lock is
  stale or too old and the time we unlink it. Don't use C<-stale> and set
  C<-hold> to 0 if you can't bear with that idea, but recall that this race
  only happens when something is already wrong. That does not make it right,
  nonetheless. ;-)
  
  =head1 AUTHOR
  
  Raphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
  
  =head1 SEE ALSO
  
  File::Flock(3).
  
  =cut
  
LOCKFILE_SIMPLE

$fatpacked{"VC3/Bag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_BAG';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Bag; 
  
  use Carp qw/carp croak/;
  #use English qw/-mo_match_vars/;
  use File::Basename;
  use File::Copy;
  use File::Spec::Functions qw/catfile rel2abs file_name_is_absolute/;
  use File::Temp qw/tempfile/;
  use FindBin  qw/$RealBin $RealScript/;
  use JSON::Tiny;
  use List::Util qw/first max/;
  use POSIX ();
  use Tie::RefHash;
  use version ();
  
  use VC3::Plan;
  use VC3::Package;
  
  sub new {
      my ($class, %args) = @_;
      
      #args:
      #    root       
      #    home       
      #    distfiles  
      #    repository 
      #    shell      
      #    dry_run    
      #    on_terminal
      #    silent     
      #    databases  
      #    pkg_opts  
      #    sys_manual 
      #    no_sys     
      #    env_vars   
  
      my $self = bless {}, $class;
  
      $self->{dry_run}     = $args{dry_run};
      $self->{on_terminal} = $args{on_terminal};
      $self->{silent_run}  = $args{silent};
  
      # clean generated shell profile by default
      $self->preserve_profile(0);
  
      # root, home, shell, etc.
      $self->set_builder_variables($args{root}, $args{home}, $args{shell}, $args{distfiles}, $args{repository});
  
      # read the catalog of available packages
      my $recipes_raw = $self->read_bags($args{databases});
  
      $self->{recipes}{op_sys_distro} = $self->decode_recipes($recipes_raw->{op_sys_distro}, $args{pkg_opts});
      # arch, distro, etc.
      $self->set_machine_vars();
  
      $self->{recipes}{op_sys}  = $self->decode_recipes($recipes_raw->{op_sys}, $args{pkg_opts});
      $self->{recipes}{package} = $self->decode_recipes($recipes_raw->{package}, $args{pkg_opts});
  
      if(%{$args{pkg_opts}}) {
          warn 'The options for these packages were unused: ', join(',', keys %{$args{pkg_opts}}) . "\n";
      }
  
      $self->{no_system} = { map { ( $_ => 1 ), } @{$args{no_sys}} };
      $self->{system}    = {};
  
      # always use singularity from the system (we can't compile it as a user.)
      $self->{system}{singularity} = 1;
  
      $self->{indent_level} = 0;
  
      $self->add_manual_variables($args{env_vars});
      $self->add_manual_packages($args{sys_manual});
  
      $self->write_db();
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $bh = {};
  
      for my $subbag (values %{$self->{recipes}}) {
          for my $p (values %{$subbag}) {
              $bh->{$p->name} = $p->original_description();
          }
      }
  
      return $bh;
  }
  
  sub write_db {
      my ($self) = @_;
  
      my $rec_file = $self->sh_profile . '.recipes';
  
      # write recipes
      open(my $sh_f_recp, '>', $rec_file)
      || die "Could not open file $rec_file $!";
  
  
      my $json = JSON::Tiny::encode_json($self->to_hash);
      print { $sh_f_recp } "$json";
      close($sh_f_recp);
  }
  
  sub list_packages() {
      my ($self, $option) = @_;
  
      my @ps;
      if($option eq 'os') {
          @ps = values %{$self->{recipes}{op_sys}};
      } else {
          @ps = values %{$self->{recipes}{package}};
      }
  
      if($option ne 'all') {
          @ps = grep { $_->show_in_list } @ps;
      }
  
      my $by_tags = ($option eq 'section');
  
      my %tags;
      for my $p (@ps) {
          my @ts = ($by_tags && $p->tags) ? @{$p->tags} : ('other');
  
          for my $t (@ts) {
              $tags{$t} ||= [];
              push @{$tags{$t}}, $p;
          }
      }
  
      my @tagnames = sort { $a cmp $b } keys %tags;
  
      @tagnames = grep { ! m/other/ } @tagnames;
      push @tagnames, 'other';
  
      for my $t (@tagnames) {
          if(defined $tags{$t}) {
  
              my @ps = sort { $a->name cmp $b->name } @{$tags{$t}};
  
              if($by_tags) {
                  print "\n--- $t\n";
              }
  
              for my $p (@ps) {
                  my $printed = {};
                  my $ws = $p->widgets;
  
                  for my $w (@{$ws}) {
                      my $version = $w->from_system ? 'auto' : $w->version;
  
                      my $str = $p->name . ':' . $version;
  
                      unless(defined $printed->{$str}) {
                          $printed->{$str} = 1;
                          print "$str\n";
                      }
                  }
              }
          }
      }
  }
  
  sub check_manual_requirements() {
      my ($self) = @_;
  
      my @restricted_unmet;
      for my $w (@{$self->plan->order}) {
          my $msg = $w->msgs_manual_requirements();
          if($msg) {
              $self->activate_widget($w);
              push @restricted_unmet, $w->msgs_manual_requirements();
          }
      }
  
      if(@restricted_unmet > 0) {
          my ($pid, $build_in) = $self->shell();
  
          print { $build_in } "cat <<EOF\n";
  
          for my $msg (@restricted_unmet) {
              for my $line (@{$msg}) {
                  print { $build_in } "$line\n";
              }
              print { $build_in } "\n";
          }
  
          print { $build_in } "EOF\n";
          print { $build_in } "exit 0\n";
  
          die "\n";
      }
  
      return 1;
  }
  
  sub active_widgets {
      my ($self) = @_;
  
      unless($self->{active_widgets}) {
          my %new;
          tie %new, 'Tie::RefHash';
  
          $self->{active_widgets} = \%new;
      }
  
      return $self->{active_widgets};
  }
  
  sub active_widgets_vars {
      my ($self) = @_;
  
      unless($self->{active_widgets_vars}) {
          my %new;
          tie %new, 'Tie::RefHash';
  
          $self->{active_widgets_vars} = \%new;
      }
  
      return $self->{active_widgets_vars};
  }
  
  sub activate_widget {
      my ($self, $widget) = @_;
      $self->activate_widget_vars($widget);
      $self->active_widgets->{$widget} = 1;
  }
  
  sub activate_widget_vars {
      my ($self, $widget) = @_;
      $self->active_widgets_vars->{$widget} = 1;
  }
  
  sub set_builder_variables {
      my ($self, $root, $home, $shell, $distfiles, $repository) = @_;
  
      $self->{environment_variables} = [];
  
      $self->root_dir($root);
      $self->home_dir($home);
      $self->files_dir($distfiles);
      $self->tmp_dir($self->with_root('tmp'));
  
      $self->repository($repository);
  
      $self->shell_executable($shell);
  
      # the var $> has the effective uid of the current user
      $self->user_uid($>);
  
      # the var $) has the effective groups of the current user
      $self->user_gid($));
  
      $self->user_name($ENV{'USER'} || getpwuid($self->user_uid) || 'vc3-user');
  
      my $executable = $RealScript;
      if($executable eq '-e') {
          # this will break! BUG. How to know the name of static executable?
          $executable = 'vc3-builder-static';
      }
  
      $self->builder_path(catfile($RealBin, $executable));
  
      eval {
          File::Path::make_path($self->root_dir);
          File::Path::make_path($self->files_dir);
          File::Path::make_path(catfile($self->files_dir, 'manual-distribution'));
          File::Path::make_path(catfile($self->files_dir, 'images', 'singularity'));
          File::Path::make_path(catfile($self->files_dir, 'images', 'docker'));
          File::Path::make_path($self->home_dir);
          File::Path::make_path($self->tmp_dir);
      };
  
      if($@) {
          my $error = $@;
          $error =~ s/ at .*$//;
          warn("Could not create some directory: $error");
          warn("giving up...\n");
          exit 1;
      }
  
      my ($profile_f, $profile_name) = tempfile(catfile($self->home_dir, '.vc3_sh-XXXXXX'));
      close $profile_f;
      $self->sh_profile($profile_name);
  
      $self->add_builder_variable('VC3_ROOT',         $self->root_dir);
      $self->add_builder_variable('VC3_DISTFILES',    $self->files_dir);
      $self->add_builder_variable('VC3_BUILDER_PATH', $self->builder_path);
      $self->add_builder_variable('VC3_INSTALL_USER_HOME', $self->home_dir);
      $self->add_builder_variable('TMP',              $self->tmp_dir);
      $self->add_builder_variable('TERM',             $ENV{'TERM'} || 'xterm');
      $self->add_builder_variable('CC',               $ENV{'CC'}   || 'gcc');
      $self->add_builder_variable('CXX',              $ENV{'CXX'}  || 'g++');
      $self->add_builder_variable('SHELL',            $self->shell_executable);
  
      # we don't want to overwrite these variables in the general profile:
      # $self->add_builder_variable('USER',
      # $self->add_builder_variable('HOME',             $self->home_dir);
  }
  
  sub DESTROY {
      my ($self) = @_;
      $self->cleanup();
  }
  
  sub root_dir {
      my ($self, $root) = @_;
  
      if($root) {
          $root = glob $root; # expand ~
          $root = rel2abs($root);
          $self->{root_dir} = $root;
      }
  
      return $self->{root_dir};
  }
  
  sub repository {
      my ($self, $shell) = @_;
  
      if($shell) {
          $self->{repository} = $shell;
      }
  
      return $self->{repository};
  }
  
  sub shell_executable {
      my ($self, $shell) = @_;
  
      if($shell) {
          $self->{shell_executable} = $shell;
      }
  
      return $self->{shell_executable};
  }
  
  sub home_dir {
      my ($self, $home) = @_;
  
      if($home) {
          $home = glob $home; # expand ~
  
          unless(file_name_is_absolute($home)) {
              $home = $self->with_root($home);
          }
  
          $home = rel2abs($home);
          $self->{home_dir} = $home;
      }
  
      return $self->{home_dir};
  }
  
  sub files_dir {
      my ($self, $files) = @_;
  
      if($files) {
          $files = glob $files; # expand ~
          $files = rel2abs($files);
          $self->{files_dir} = $files;
      }
  
      return $self->{files_dir};
  }
  
  sub tmp_dir {
      my ($self, $tmp) = @_;
  
      if($tmp) {
          $tmp = glob $tmp; # expand ~
          $tmp = rel2abs($tmp);
          $self->{tmp_dir} = $tmp;
      }
  
      return $self->{tmp_dir};
  }
  
  sub with_root {
      my ($self, $dir) = @_;
  
      return catfile($self->root_dir, $dir);
  }
  
  sub user_name {
      my ($self, $name) = @_;
  
      $self->{user_name} = $name if($name);
  
      return $self->{user_name};
  }
  
  sub user_uid {
      my ($self, $uid) = @_;
  
      if(defined $uid) {
          $self->{user_uid} = $uid;
      }
  
      return $self->{user_uid};
  }
  
  sub user_gid {
      my ($self, $gids) = @_;
  
      if(defined $gids) {
          my @all = split(' ', $gids);
          $self->{user_gid} = $all[0];
      }
  
      return $self->{user_gid};
  }
  
  sub on_terminal {
      my ($self, $ont) = @_;
  
      $self->{on_terminal} = $ont if($ont);
  
      return $self->{on_terminal};
  }
  
  
  sub plan {
      my ($self, $new) = @_;
  
      $self->{plan} = $new if($new);
  
      return $self->{plan};
  }
  
  sub builder_path {
      my ($self, $new) = @_;
  
      $self->{builder} = $new if($new);
  
      return $self->{builder};
  }
  
  
  sub sh_profile {
      my ($self, $init) = @_;
  
      $self->{sh_profile} = $init if($init);
  
      return $self->{sh_profile};
  }
  
  sub dry_run {
      my ($self) = @_;
      return $self->{dry_run};
  }
  
  sub preserve_profile {
      my ($self, $val) = @_;
  
      if(defined $val) {
          $self->{preserve_profile} = $val;
      }
  
      unless(defined $self->{preserve_profile}) {
          # do not preserve profile by default.
          $self->{preserve_profile} = 0;
      }
  
      return $self->{preserve_profile};
  }
  
  
  sub environment_variables {
      my ($self, $new_vars) = @_;
  
      $self->{environment_variables} = $new_vars if($new_vars);
  
      return $self->{environment_variables};
  }
  
  sub add_builder_variable {
      my ($self, $name, $value) = @_;
  
      my $var = {
          name     => $name,
          value    => $value,
          clobber  => 1,
          absolute => 1
      };
  
      my $vars = $self->environment_variables;
      push @{$vars}, $var;
  
      return $var;
  }
  
  sub add_manual_variables {
      my ($self, $extra_vars) = @_;
  
      for my $var (@{$extra_vars}) {
          $var =~ m/
          ^
          (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
          =
          (?<value>.*)
          $
          /x or die "Malformed variable specification: '$var'";
  
          $self->add_builder_variable($+{name}, $+{value});
      }
  }
  
  
  sub add_manual_packages {
      my ($self, $specs) = @_;
  
      for my $spec (@{$specs}) {
          my ($name, $version, $dir);
  
          if(
              $spec =~ m/
              ^
              (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
              :
              (?<version>(([0-9]+(\.?[0-9]){0,3})|auto))
              (=(?<dir>.*))?
              $
              /x
          ) {
              ($name, $version, $dir) = @+{qw(name version dir)};
              $dir ||= '/usr';
          } else {
              die "Malformed manual specification: '$spec'\n";
          }
  
          my $pkg = $self->{recipes}{package}{$name};
          unless($pkg) {
              die "Could not find specification to overwrite for '$name'\n";
          }
  
          if($version eq 'auto') {
              $version = $pkg->compute_auto_version($dir);
          }
  
          my $s = {};
          $s->{version} = $version;
          $s->{source} = {
              type   => 'system',
              recipe => [
                  "echo VC3_ROOT_SYSTEM: $dir"
              ]
          };
  
          $self->{system}{$name} = 1;
  
          my $widgets = $pkg->widgets;
          unshift @{$widgets}, VC3::Widget->new($pkg, $s);
      }
  }
  
  sub del_builder_variable {
      my ($self, $name) = @_;
  
      my @vars = @{$self->environment_variables};
      @vars = grep { $name ne $_->{name} } @vars;
  
      $self->environment_variables(\@vars);
  }
  
  sub set_plan_for {
      my ($self, @requires) = @_;
  
      $self->{indent_level} = 0;
  
      my $plan = VC3::Plan->new($self);
      $self->plan($plan);
  
      if(!$plan->add_main_targets(@requires)) {
          die("Could not find an installation plan.\n");
      }
  
      $plan->order(1);
  }
  
  sub execute_plan {
      my ($self, $sh_on_error, $force_rebuild, $ignore_locks) = @_;
  
      for my $w (@{$self->plan->order}) {
          $self->activate_widget_vars($w);
          $self->build_widget($w, $sh_on_error, $force_rebuild, $ignore_locks);
          $self->activate_widget($w);
      }
  }
  
  sub cleanup {
      my ($self) = @_;
  
      if($self->{child_pid}) {
          $self->say('Cleaning payload with pid: ' . $self->{child_pid});
          # send HUP to all processes
          kill -1, $self->{child_pid};
      }
  
      unless($self->preserve_profile) {
  
          if(defined $self->sh_profile) {
              if(-f $self->sh_profile) {
                  unlink $self->sh_profile;
              }
  
              if(-f $self->sh_profile . '.env') {
                  unlink $self->sh_profile . '.env';
              }
  
              if(-f $self->sh_profile . '.prologue') {
                  unlink $self->sh_profile . '.prologue';
              }
  
              if(-f $self->sh_profile . '.wrapper') {
                  unlink $self->sh_profile . '.wrapper';
              }
  
              if(-f $self->sh_profile . '.payload') {
                  unlink $self->sh_profile . '.payload';
              }
  
              if(-f $self->sh_profile . '.recipes') {
                  unlink $self->sh_profile . '.recipes';
              }
          }
  
          $self->del_builder_variable('VC3_SH_PROFILE_ENV');
          $self->del_builder_variable('VC3_SH_PROFILE_WRAPPER');
      }
  
      if($self->{child_pid}) {
          # give 10 seconds for child to cleanup HUP, then REDRUM
          for my $i (1..10) {
              my $n = waitpid(-1, POSIX::WNOHANG);
              if($n < 0) {
                  $self->{child_pid} = undef;
                  return;
              } else {
                  $self->say('Waiting for payload with pid: ' . $self->{child_pid} . "  $n");
                  VC3::Builder::select_sleep(1);
              }
          }
          $self->say('Hard terminating for payload with pid: ' . $self->{child_pid});
  
          # KILL to anybody
          kill -9, $self->{child_pid};
          $self->{child_pid} = undef;
      }
  }
  
  sub set_machine_vars {
      my ($self) = @_;
  
      ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();
  
      $self->{distribution} = $self->find_distribution();
  
      $self->{target} = catfile($self->architecture, $self->distribution);
  
  
      my $ldd_version_raw = qx(ldd --version);
      $ldd_version_raw =~ /
      # we are looking for a line starting with 'ldd'
      ^ldd
      # followed by anything
      .*
      # followed by at least one space
      \s+
      # followed by the version number (that we capture)
      ([0-9.]+)
      # followed by any number of spaces at the end of the line
      \s*$
      # options: x allows regexp comments. m treats each line indepedently
      /xm ;
  
      $self->{glibc_version} = $1
      || 'unknown';
  
      $self->add_builder_variable('VC3_MACHINE_OS',            catfile($self->{osname}, $self->distribution));
      $self->add_builder_variable('VC3_MACHINE_ARCH',          $self->architecture);
      $self->add_builder_variable('VC3_MACHINE_GLIBC_VERSION', $self->glibc_version);
      $self->add_builder_variable('VC3_MACHINE_TARGET',        $self->{target});
  }
  
  sub target {
      my ($self) = @_;
      return $self->{target};
  }
  
  sub osname {
      my ($self) = @_;
      return $self->{osname};
  }
  
  sub architecture {
      my ($self) = @_;
      return $self->{architecture};
  }
  
  sub glibc_version {
      my ($self) = @_;
      return $self->{glibc_version};
  }
  
  sub distribution {
      my ($self) = @_;
      return $self->{distribution};
  }
  
  # reads /etc/readhat-release and transforms something like:
  # 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
  # into 'redhat6'.
  # or /etc/debian_version into 'debian9
  # etc.
  sub find_distribution {
      my ($self) = @_;
      my $distribution;
  
      my @wheres = values %{$self->{recipes}{op_sys_distro}};
  
      @wheres = sort { $a->name cmp $b->name } @wheres;
  
      for my $p (@wheres) {
          for my $w (@{$p->widgets}) {
              my $exit_status = -1;
              eval { $exit_status = $w->source->check_prerequisites() };
              if($exit_status) {
                  next;
              }
  
              eval { $distribution = $w->compute_os_distribution(); };
              if($@) {
                  next;
              }
  
              if($distribution) {
                  return $distribution;
              }
          }
      }
  
      warn "Could not find any OS version. Using 'generic'\n";
      return 'generic';
  }
  
  sub widgets_of {
      my ($self, $name) = @_;
  
      my $pkg = $self->{recipes}{package}{$name}
      || die "I do not know anything about '$name' . \n";
  
      return $pkg->widgets;
  }
  
  sub read_bags {
      my ($self, $databases) = @_;
  
      my $recipes  = {};
      $recipes->{package} = {};
      $recipes->{op_sys}  = {};
      $recipes->{op_sys_distro} = {};
  
      for my $filespec (@{$databases}) {
          if(-d $filespec) {
              $self->read_bag_dir($filespec, 1, $recipes);
          } elsif(-f $filespec) {
              $self->read_bag_file($filespec, $recipes);
          } elsif($filespec eq '<internal>') {
              $self->read_bag_internal($recipes);
          }
      }
  
      return $recipes;
  }
  
  sub read_bag_dir {
      my ($self, $dir, $depth, $recipes) = @_;
  
      if($depth > 32) {
          die "Maximum directory depth allowed reached.\n";
      }
  
      my @listing = sort { $a cmp $b } glob catfile($dir, '*');
  
      for my $filespec (@listing) {
          if(-d $filespec) {
              $self->read_bag_dir($filespec, $depth+1, $recipes);
          } elsif($filespec =~ m/\.json$/) {
              $self->read_bag_file($filespec, $recipes);
          }
      }
  }
  
  sub read_bag_file {
      my ($self, $filename, $recipes) = @_;
  
      open(my $catbag_f, '<:encoding(UTF-8)', $filename) ||
      die "Could not open '$filename': $!\n";
  
      return $self->read_bag_fh($catbag_f, $recipes);
  }
  
  sub read_bag_internal {
      my ($self, $recipes) = @_;
  
      {
          no warnings;
          if(tell(VC3::Builder::DATA) == -1) {
              return $recipes;
          }
      }
  
      my $catbag_f = *VC3::Builder::DATA;
  
      return $self->read_bag_fh($catbag_f, $recipes);
  }
  
  
  sub read_bag_fh {
      my ($self, $fh, $recipes) = @_;
  
      my $contents = do { local($/); <$fh> };
      close($fh);
  
      my $bag_raw; 
      eval { $bag_raw = JSON::Tiny::decode_json($contents); };
      if($@) {
          die "There was an error while decoding JSON file:\n$@\n";
      }
  
      if(ref($bag_raw) ne 'ARRAY') {
          $bag_raw = [ $bag_raw ];
      }
  
      for my $obj (@{$bag_raw}) {
          for my $package_name (keys %{$obj}) {
  
              my $pkg_raw = $obj->{$package_name};
  
              if(!$pkg_raw->{type} || $pkg_raw->{type} eq 'package') {
                  $recipes->{package}{$package_name} = $pkg_raw;
              } elsif($pkg_raw->{type} eq 'operating-system') {
                  $recipes->{op_sys}{$package_name} = $pkg_raw;
              } elsif($pkg_raw->{type} eq 'operating-system-distribution') {
                  $recipes->{op_sys_distro}{$package_name} = $pkg_raw;
              } else {
                  die "I don't know about a package type '" . $pkg_raw->{type} . "'\n";
              }
          }
      }
  
      return $recipes;
  } 
  
  sub decode_recipes {
      my ($self, $raw, $pkg_opts) = @_;
  
      my $recipes = {};
  
      for my $package_name (keys %{$raw}) {
          if(exists $pkg_opts->{$package_name}) {
              $raw->{$package_name}{options} = $pkg_opts->{$package_name};
              delete $pkg_opts->{$package_name};
          }
  
          my $pkg = VC3::Package->new($self, $package_name, $raw->{$package_name});
          $recipes->{$package_name} = $pkg;
      }
  
      return $recipes;
  }
  
  sub build_widget {
      my ($self, $widget, $sh_on_error, $force_rebuild, $ignore_locks) = @_;
  
      my $sys_label = $widget->source->type eq 'system' ? ' (from host)' : '';
      $self->say("processing for @{[$widget->package->name]}-" . $widget->version->normal . $sys_label);
  
  
      my $exit_status = 0;
      eval { $exit_status = -1; $exit_status = $widget->source->execute_recipe($force_rebuild, $ignore_locks) };
  
      if($exit_status) {
          $widget->process_error($sh_on_error, $English::EVAL_ERROR, $exit_status);
          exit 1;
      }
  
      return $exit_status;
  }
  
  sub dot_graph {
      my ($self, $dotname) = @_;
      return $self->plan->dot_graph($dotname);
  }
  
  sub to_parallel {
      my ($self, $dir, $make_jobs) = @_;
  
      my $abs_dir;
      if(file_name_is_absolute($dir)) {
          $abs_dir = $dir;
      } else {
          $abs_dir = catfile($self->home_dir, $dir);
      }
  
      my $dag_name       = 'dag';
      my $builder_name   = 'builder';
      my $local_database = 'recipes';
  
      File::Path::make_path($abs_dir);
  
      my $build_wrapper = catfile($abs_dir, 'build');
      open my $script_f, '>', "$build_wrapper" || die "Could not open '$build_wrapper' for writing: $!";
      print { $script_f } <<EOFF;
  #! @{[$self->shell_executable]}
  set -e
  
  makeflow --shared-fs @{[$self->root_dir]} -r 5 $dag_name "\$@"
  
  cat <<EOF
  
  Parallel build mode complete. To run type:
  
  VC3_ROOT=@{[$self->root_dir]}
  VC3_DB=@{[catfile($abs_dir, $local_database)]}
  
  $0 --database \\\${VC3_DB} --install \\\${VC3_ROOT} @{[map { "--require $_" } @{$self->plan->requirements}]}
  
  EOF
  EOFF
  
      close $script_f;
      chmod 0755, $build_wrapper;
  
      my $builder_path = catfile($abs_dir, $builder_name);
      copy($self->builder_path, $builder_path);
      chmod 0755, $builder_path;
  
      $self->plan->to_makeflow($abs_dir, $dag_name, $builder_name, $local_database, $make_jobs);
  
      $self->check_manual_requirements();
      $self->plan->prestage();
  }
  
  sub set_environment_variables {
      my ($self, $sh_f) = @_;
  
      my $env = $self->active_widgets_vars();
  
      my $expansion = {};
  
      for my $var (@{$self->environment_variables}) {
          $expansion->{$var->{name}} = [$var->{value}];
      }
  
      if($self->plan and $self->plan->order) {
          for my $wid (@{$self->plan->order}) {
              next unless $env->{$wid};
              $wid->consolidate_environment_variables($expansion);
          }
      }
  
      $expansion->{'PATH'} ||= [];
      $expansion->{'LD_LIBRARY_PATH'} ||= [];
      $expansion->{'MODULEPATH'} ||= [];
  
      # use default PATH:
      push @{$expansion->{'PATH'}},            $ENV{'PATH'}            || qw(/bin /usr/bin /usr/local/bin);
      push @{$expansion->{'LD_LIBRARY_PATH'}}, $ENV{'LD_LIBRARY_PATH'} || qw(/lib /usr/lib /usr/local/lib);
      push @{$expansion->{'MODULEPATH'}},      $ENV{'MODULEPATH'}      || ();
  
      for my $var_name (keys %{$expansion}) {
          my @values = $self->clean_variable_repetitions($expansion->{$var_name});
  
          eval { $expansion->{$var_name} = join(':', @values) };
          if($@) {
              warn("Environment variable '$var_name' was not explicitely set.\n");
          }
      }
  
      my @ordered = $self->order_variables($expansion);
  
      for my $var_name (@ordered) {
          my $value = $expansion->{$var_name};
  
          # if value already starts with quotes, don't add quotes.
          if($value =~ qr/^\s*("|')/) {
              print { $sh_f } "export $var_name=$value\n";
          } else {
              print { $sh_f } "export $var_name=\"$value\"\n";
          }
      }
  
      print { $sh_f } "\n";
  }
  
  sub clean_variable_repetitions {
      my ($self, $ref) = @_;
  
      my @values = @$ref;
  
      my %metric;
      my $count = 1;
      my $root = $self->root_dir;
  
      for my $v (@values) {
          if($v !~ m%^/(usr/(local/)?)?(bin|lib)$%) {
              $metric{$v} = $count;
          } elsif ($v =~ m%^$root%) {
              $metric{$v} = $count;
          } else {
              $metric{$v} = $count + @values;
          }
          $count++;
      }
  
      return sort { $metric{$a} <=> $metric{$b} } keys %metric;
  }
  
  sub order_variables {
      my ($self, $expansion) = @_;
  
      my @alpha = sort { $a cmp $b } keys %{$expansion};
  
      my $order = {};
  
      my $index = 1;
      for my $var (@alpha) {
          $order->{$var} = $index;
          $index++;
      }
  
      my $total_passes = 0;
      my $swap       = 1;
  
      while($swap) {
          $swap = 0;
  
          my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
  
          for my $var (@ordered) {
              my $value = $expansion->{$var};
              my @deps  = ($value =~ m/\$\{(\w+)\}/g);
  
              next unless @deps;
  
              my $org   = $order->{$var};
              my $nxt   = 1 + max(map { $order->{$_} || warn "Variable '$_' is not explicitely set.\n" } @deps);
  
              if($nxt > $org) {
                  $swap++;
                  $order->{$var} = $nxt;
              }
          }
  
          $total_passes++;
          carp "Cyclic dependency in environment variables." if $total_passes > @alpha;
      }
  
      my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
      return @ordered;
  }
  
  
  sub set_profile {
      my ($self, $profile_file, @command_and_args) = @_;
  
      my ($env_file, $prog_file, $wrap_file, $pay_file) = map { $profile_file . $_ } ('.env', '.prologue', '.wrapper', '.payload');
      
      # write to env file
      open(my $sh_f_env, '>', $env_file)
      || die "Could not open file $env_file $!";
      print { $sh_f_env } <<EOFP;
  #! @{[$self->shell_executable]}
  
  # don't load environment variables repeatedly (e.g., to not grow PATH at every shell)
  if [ ! "\${VC3_ENV_TAG_GLOBAL}" = $$ ]
  then
  
  EOFP
      $self->set_environment_variables($sh_f_env);
  
      print { $sh_f_env } <<EOFP;
  export VC3_ENV_TAG_GLOBAL=$$
  fi
  
  EOFP
  
      close($sh_f_env);
  
      # write to prologue file
      open(my $sh_f_prog, '>', $prog_file)
      || die "Could not open file $prog_file $!";
      print { $sh_f_prog } <<EOFP;
  #! @{[$self->shell_executable]}
  
  # don't source prologues at a shell that already sourced them.
  if [ ! "\${VC3_ENV_TAG_LOCAL}" = $$ ]
  then
  
  EOFP
  
      for my $prog_line (@{$self->consolidate_prologue}) {
          print { $sh_f_prog } "$prog_line";
          print { $sh_f_prog } "\n";
      }
  
      print { $sh_f_prog } <<EOFP;
  
      VC3_ENV_TAG_LOCAL=$$
  fi
  
  EOFP
  
      # write to general profile
      open(my $sh_f, '>', "$profile_file")
      || die "Could not open file $profile_file $!";
  
      print { $sh_f } <<EOFP;
  #! @{[$self->shell_executable]}
  
  . $env_file
  . $prog_file
  
  EOFP
      close($sh_f);
  
      # write to payload file
      open(my $sh_f_pay, '>', $pay_file)
      || die "Could not open file $pay_file $!";
  
      print { $sh_f_pay } <<EOFP;
  #! @{[$self->shell_executable]}
  
  if [ "\${VC3_INSIDE_WRAPPER_SCRIPT}" != yes ]
  then
  
      echo This script cannot be executed by itself.
      echo Run instead: ${wrap_file}
      exit 1
  fi
  
  # load profile for further interactive shells.
  export ENV=$profile_file
  
  # load profile if the exec below is not interactive
  . $profile_file
  
  EOFP
  
      print { $sh_f_pay } join(' ', 'exec', @command_and_args);
      print { $sh_f_pay } "\n";
  
      close($sh_f_pay);
      chmod 0755, $pay_file;
  
      # write to wrapper file
      open(my $sh_f_wrap, '>', "$wrap_file")
      || die "Could not open file $wrap_file $!";
  
      print { $sh_f_wrap } <<EOFP;
  #! @{[$self->shell_executable]}
  
  . $env_file
  
  export VC3_INSIDE_WRAPPER_SCRIPT=yes
  cd  "\${HOME}"
  
  EOFP
  
      my @payload = ($pay_file);
  
      my $env = $self->active_widgets();
      if($self->plan and $self->plan->order) {
          for my $w (@{$self->plan->order}) {
              next unless $env->{$w};
              next unless $w->wrapper;
  
              my @wrap = @{$w->wrapper};
              my $braces_pos = first { $wrap[$_] eq '{}' } 0..$#wrap;
  
              if(defined($braces_pos)) {
                  my @tmp = @payload;
                  @payload = @wrap;
                  splice @payload, $braces_pos, 1, @tmp;
              } else {
                  @payload = (@wrap, @payload);
              }
          }
      }
  
      print { $sh_f_wrap } "exec @payload\n\n";
  
      close($sh_f_wrap);
      chmod 0755, $wrap_file;
  
      $self->add_builder_variable('VC3_SH_PROFILE_ENV',     $profile_file);
      $self->add_builder_variable('VC3_SH_PROFILE_WRAPPER', $wrap_file);
  }
  
  sub consolidate_prologue {
      my ($self) = @_;
  
      my $env = $self->active_widgets();
  
      my @progs = ();
  
      if($self->plan and $self->plan->order) {
          for my $w (@{$self->plan->order}) {
              next unless $env->{$w};
  
              if($w->prologue) {
                  push @progs, @{$w->prologue};
              }
          }
      }
  
      return \@progs;
  }
  
  sub preserved_vars {
      my ($self) = @_;
  
      my %to_preserve;
  
      $to_preserve{HOME} = $self->home_dir;
      $to_preserve{USER} = $self->user_name;
  
      my @output;
  
      for my $var (keys %to_preserve) {
          push @output, "$var=$to_preserve{$var}";
      }
  
      return @output;
  }
  
  
  sub execute {
      my ($self, @command_and_args) = @_;
  
      $self->set_profile($self->sh_profile, @command_and_args);
  
      my $pid = fork();
  
      if($pid == 0) {
          my @args = (
              '/usr/bin/env',
              '-i',
              $self->preserved_vars(),
              $self->sh_profile . '.wrapper');
  
          POSIX::setpgid(0, 0);
  
          exec { $args[0] } @args;
          die 'Could not exec payload';
      } elsif($pid > 0) {
  
          close(STDIN);
          POSIX::setpgid($pid, $pid);
  
          if($self->{on_terminal}) {
              $self->bring_to_foreground($pid);
          }
  
          $self->{child_pid} = $pid;
          waitpid $pid, 0;
          my $status = $?;
          $self->{child_pid} = undef;
  
          return POSIX::WEXITSTATUS($status);
      } else {
          die 'Could not fork to exec payload: ' . $!;
      }
  }
  
  sub bring_to_foreground {
      my ($self, $groupid) = @_;
  
      $SIG{TTOU} = 'IGNORE';
  
      open my $term, '+<', '/dev/tty';
      return unless $term;
  
      POSIX::tcsetpgrp(fileno($term), $groupid) or die "Could not bring child to foreground: $!";
  
      close $term;
  }
  
  sub shell {
      my ($self, $payload) = @_;
  
      $payload |= $self->shell_executable;
      $self->set_profile($self->sh_profile, $payload);
  
      my $pid = open(my $input, '|-');
      if($pid == 0) {
          my @args = (
              '/usr/bin/env',
              '-i',
              $self->preserved_vars(),
              $self->sh_profile . '.wrapper');
          exec { $args[0] } @args;
          die 'Could not exec shell';
      } elsif($pid > 0) {
          $self->{child_pid} = $pid;
          # wait for this shell later.
      } else {
          die 'Could not fork to exec payload: ' . $!;
      }
  
      return ($pid, $input);
  }
  
  sub shell_user {
      my ($self) = @_;
      return $self->execute($self->shell_executable);
  }
  
  sub say {
      my ($self, @rest) = @_;
  
      return if($self->{silent_run} and $self->{silent_run} eq 'ALL');
  
      print( ('.' x ($self->{indent_level} || 0)), join(' ', @rest), "\n");
  }
  
  sub say_plan {
      my ($self, @rest) = @_;
  
      return if($self->{silent_run} and $self->{silent_run} eq 'plan');
  
      $self->say(@rest);
  }
  
  1;
  
VC3_BAG

$fatpacked{"VC3/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_PACKAGE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use warnings;
  use strict;
  
  package VC3::Package;
  use Carp;
  use File::Temp;
  use File::Spec::Functions qw/catfile rel2abs/;
  
  use VC3::Widget;
  
  sub new {
      my ($class, $bag, $name, $json_description) = @_;
  
      my $self = bless {}, $class;
  
      $self->original_description(\%{$json_description});
  
      $self->bag($bag);
      $self->name($name);
      $self->dependencies($json_description->{dependencies});
      $self->wrapper($json_description->{wrapper});
      $self->prologue($json_description->{prologue});
      $self->options($json_description->{options});
      $self->environment_variables($json_description->{'environment-variables'});
      $self->environment_autovars($json_description->{'environment-autovars'});
      $self->phony($json_description->{phony});
  
      $json_description->{'type'} ||= 'package';
      $self->type($json_description->{'type'});
  
      $self->show_in_list($json_description->{'show-in-list'});
      $self->tags($json_description->{'tags'});
  
      if($json_description->{versions}) {
          $self->widgets($json_description->{versions});
      } else {
          $self->{widgets} = [];
      }
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $ph = {};
  
      $ph->{phony}     = $self->phony;
      $ph->{prologue}  = $self->prologue;
      $ph->{wrapper}   = $self->wrapper;
      $ph->{options}   = $self->options;
      $ph->{type}      = $self->type;
  
      # environment-autovars already included in environment-variables
      # environment-variables already included in widgets
      # dependencies included in widgets
      
      $ph->{'versions'}       = [];
  
      for my $w (@{$self->widgets}) {
          push @{$ph->{versions}}, $w->to_hash;
      }
  
      for my $k (keys %{$ph}) {
          unless(defined $ph->{$k}) {
              delete $ph->{$k};
          }
      }
  
      return $ph;
  }
  
  
  sub widgets {
      my ($self, $new_widgets_spec) = @_;
  
      if($new_widgets_spec) {
          my @widgets;
          for my $s (@{$new_widgets_spec}) {
              my $w = VC3::Widget->new($self, $s);
              push @widgets, $w if $w;
          }
  
          $self->{widgets} = \@widgets;
      }
  
      return $self->{widgets};
  }
          
  
  sub name {
      my ($self, $new_name) = @_;
  
      if($new_name) {
          # names can only contain letters, numbers, - and _.
          my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
          if(@badchars) {
              die "The name '$new_name' containes the following disallowed charactares: " 
              . join ', ', map { "'$_'" } @badchars;
          } else {
              $self->{name} = $new_name if($new_name);
          }
      }
  
      die 'No name given'
      unless($self->{name}); 
  
      return $self->{name};
  }
  
  sub original_description {
      my ($self, $new_original) = @_;
  
      $self->{original_description} = $new_original if($new_original);
  
      return $self->{original_description};
  }
  
  sub dependencies {
      my ($self, $new_dependencies) = @_;
  
      $self->{dependencies} = $new_dependencies if($new_dependencies);
  
      return $self->{dependencies};
  }
  
  sub prologue {
      my ($self, $new_prologue) = @_;
  
      $self->{prologue} = $new_prologue if($new_prologue);
  
      return $self->{prologue};
  }
  
  sub wrapper {
      my ($self, $new_wrapper) = @_;
  
      $self->{wrapper} = $new_wrapper if($new_wrapper);
  
      return $self->{wrapper};
  }
  
  sub options {
      my ($self, $new_options) = @_;
  
      $self->{options} = $new_options if($new_options);
  
      return $self->{options};
  }
  
  sub environment_variables {
      my ($self, $new_vars) = @_;
  
      $self->{environment_variables} ||= [];
  
      if($new_vars) {
          unshift @{$self->{environment_variables}}, @{$new_vars};
      }
  
      return $self->{environment_variables};
  }
  
  sub environment_autovars {
      my ($self, $new_autovars) = @_;
  
      $self->{environment_autovars} = $new_autovars if($new_autovars);
  
      return $self->{environment_autovars};
  }
  
  sub bag {
      my ($self, $new_bag) = @_;
  
      $self->{bag} = $new_bag if($new_bag);
  
      croak 'No bag given'
      unless($self->{bag}); 
  
      return $self->{bag};
  }
  
  sub phony {
      my ($self, $new_phony) = @_;
  
      $self->{phony} = $new_phony if(defined $new_phony);
  
      return $self->{phony};
  }
  
  sub show_in_list {
      my ($self, $new_show) = @_;
  
      $self->{show_in_list} = $new_show if(defined $new_show);
  
      return $self->{show_in_list};
  }
  
  sub tags {
      my ($self, $new_tags) = @_;
  
      $self->{tags} = $new_tags if($new_tags);
  
      return $self->{tags};
  }
  
  sub type {
      my ($self, $new_type) = @_;
  
      $self->{type} = $new_type if($new_type);
  
      return $self->{type}
  }
  
  1;
  
VC3_PACKAGE

$fatpacked{"VC3/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_PLAN';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Plan;
  use File::Spec::Functions qw/catfile rel2abs/;
  use JSON::Tiny;
  
  use VC3::Plan::Element;
  
  sub new {
      my ($class, $bag, $parent) = @_;
  
      my $self = bless {}, $class;
  
      $self->bag($bag);
  
      $self->elements($parent && $parent->elements || {});
  
      return $self;
  }
  
  sub bag {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{bag} = $new;
      }
  
      return $self->{bag};
  }
  
  sub say {
      my ($self, @rest) = @_;
  
      return $self->bag->say_plan(@rest);
  }
  
  sub elements {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{elements} = \%{ $new };
      }
  
      return $self->{elements};
  }
  
  sub element_of {
      my ($self, $name) = @_;
  
      return $self->elements->{$name};
  }
  
  sub requirements {
      my ($self) = @_;
  
      unless($self->{requirements}) {
          $self->{requirements} = [];
      }
  
      return $self->{requirements};
  }
  
  sub add_target {
      my ($self, $name, $min, $max) = @_;
  
      $self->bag->{indent_level}++;
  
      $self->say("Plan:    $name => [@{[$min || '']}, @{[$max || '']}]");
  
      # if this target has been already added, we check that versions are congruent
      my $p = $self->elements->{$name};
      if($p) {
          my $e = $self->refine($p->widget, $p, $min, $max);
  
          if($e) {
              $self->elements->{$name} = $e;
              $self->say("Using:   $name => [@{[$e->min || '']}, @{[$e->max || '']}]");
              $self->bag->{indent_level}--;
              return 1;
          }
      }
  
      my $available = $self->bag->widgets_of($name);
      for my $widget (@{$available}) {
  
          unless($widget->available) {
              next;
          }
  
          # This is a naive search!
          # We also want to check for different order of targets.
          if($self->add_widget($widget, $min, $max)) {
              $self->bag->{indent_level}--;
              return 1;
          }
      }
  
      $self->say("Failure: $name => [@{[$min || '']}, @{[$max || '']}]");
      $self->bag->{indent_level}--;
  
      return 0;
  }
  
  sub operating_system {
      my ($self, $new_os) = @_;
  
      $self->{operating_system} = $new_os if($new_os);
  
      return $self->{operating_system};
  }
  
  sub add_main_targets {
      my ($self, @requires) = @_;
  
      my $root_entry = { version => version->declare('v0.0.1'), phony => 1, dependencies => {} };
  
      for my $req (@requires) {
          my ($name, $min, $max) = $self->parse_requirement($req);
  
          my $versions = [$min, $max];
  
          $root_entry->{dependencies}{$name} = $versions;
          
          unless($self->add_target($name, $min, $max)) {
              die "Could not find plan for $req.\n";
          }
  
          push @{$self->requirements}, $name;
      }
  
      return 1;
  }
  
  sub parse_requirement {
      my ($self, $req) = @_;
  
      $req =~ m/
      ^
      (?<name> [A-z0-9_-]+)
      (:v?                      # start of min version
      (?<min> [^:]*)
      (:v?                    # start of max version
      (?<max> [^:]*)
      )?)?
      $
      /x;
  
      my ($name, $min, $max) = ($+{name}, $+{min}, $+{max});
  
      if($min) {
          if($min eq 'auto') {
              undef $min;
          } else {
              my ($M, $m, $b) = ($min =~ m/^v?([0-9]+)\.?([0-9]+)?\.?([0-9]+)?/);
              
              $m = '0' unless defined($m);
              $b = '0' unless defined($b);
  
              $min = "v$M.$m.$b";
          }
      }
  
      if($max) {
          if($max eq 'auto') {
              undef $max;
          } else {
              my ($M, $m, $b) = ($max =~ m/^v?([0-9]+)\.?([0-9]+)?\.?([0-9]+)?/);
              
              $m = '999999' unless defined($m);
              $b = '999999' unless defined($b);
  
              $max = "v$M.$m.$b";
          }
      }
  
      if(!$min && $max) {
          $min = 'v0.0.1';
      }
  
      # turn into version strings
      eval {
          $min = version->declare($min) if($min);
          $max = version->declare($max) if($max);
      };
      if($@) {
          die "Versions should be of the form: MAJOR.MINOR.REVISION\n";
      }
  
  
      return ($name, $min, $max);
  }
  
  sub version_str {
      my ($self, $v) = @_;
  
      return ''         unless $v;
      return $v->normal if $v->isa('version');
      return version->parse($v)->normal;
  }
  
  sub add_widget {
      my ($self, $widget, $min, $max) = @_;
  
      my $version = $widget->version;
  
      $self->say("Try:     " . $widget->package->name . " => @{[$version->normal]}");
  
      if($min && $min gt $version || $max && $max lt $version) {
          $self->say("Incorrect version: @{[$version->normal]} => [@{[$self->version_str($min)]},@{[$self->version_str($max)]}]");
          return 0;
      }
  
      my $saved_state = $self->elements();
  
      my $p = $self->elements->{$widget->package->name};
      my $e = $self->refine($widget, $p, $min, $max);
  
      my $success;
      if($p && !$e) {
          $self->say("conflicting versions: @{[$widget->package->name]} [@{[ $self->version_str($p->{min}) ]}, @{[ $self->version_str($p->{max})]} <=> [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
          $success = 0;
      } elsif(!$e) {
          $success = 0;
          die('bug, this should not happen.');
      } else {
          $self->say("Refining version: @{[$widget->package->name, $version]} => [@{[$self->version_str($e->{min})]}, @{[$self->version_str($e->{max})]}]");
          if($self->add_dependencies($widget->dependencies)) {
              if($widget->source) {
                  my $s = $self->add_source($widget->source);
                  if($s) {
                      $success = 1;
                  } else {
                      $self->say("could not add source for: @{[$widget->package->name, $version]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
                      $success = 0;
                  }
              } else {
                  $success = 1;
              }
          } else {
              $self->say("could not set dependencies for: @{[$widget->package->name]} @{[$version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
              $success = 0;
          }
      }
  
      if($success) {
          # add new step to plan
          $self->elements->{$widget->package->name} = $e;
          $self->say("Success: @{[$widget->package->name]} @{[$e->widget->version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
      } else {
          # restore old plan on error
          $self->elements($saved_state);
      }
  
      return $success;
  }
  
  sub add_dependencies {
      my ($self, $dependencies) = @_;
  
      my $saved_state = $self->elements();
  
      my $success = 1;
      for my $name (keys %{$dependencies}) {
  
          my ($min, $max) = @{$dependencies->{$name}};
          unless($self->add_target($name, $min, $max)) {
              $success = 0;
              last;
          }
      }
  
      unless($success) {
          $self->elements($saved_state);
      }
  
      return $success;
  }
  
  sub add_source {
      my ($self, $source) = @_;
  
      my $saved_state = $self->elements();
  
      if($source->isa('VC3::Source::System')) {
          return if $self->bag->{no_system}{ALL};
          return if $self->bag->{no_system}{$source->widget->package->name};
      }
  
      my $exit_status = -1;
      eval { $exit_status = $source->check_prerequisites() };
  
      if($exit_status) {
          $self->say("Fail-prereq: " . $source->widget->package->name . '-' . $source->widget->version->normal);
          return undef;
      }
  
      if($self->add_dependencies($source->dependencies)) {
          return $source;
      }
  
      $self->elements($saved_state);
      return undef;
  }
  
  
  sub refine {
      my ($self, $widget, $p, $min, $max) = @_;
  
      my $e = VC3::Plan::Element->new($widget, $min, $max);
  
      if($p) {
          return $e->refine($min, $max);
      } else {
          return $e;
      }
  }
  
  sub order {
      my ($self, $set) = @_;
  
      if($set) {
          my $ordinals = $self->order_aux();
          my @ordered = sort { ($ordinals->{$a} <=> $ordinals->{$b}) || ($a cmp $b) } keys %{$ordinals};
          $self->{order} = [ map { $self->elements->{$_}{widget} } @ordered ];
      }
  
      return $self->{order};
  }
  
  sub order_aux {
      my ($self) = @_;
  
      my $ordinal_of = {};
  
      my @names = keys %{$self->elements};
  
      for my $name (@names) {
          $ordinal_of->{$name} = 1;
      }
  
      my $to_go = @names;
  
      while($to_go >= 0) {
          my $change = 0;
  
          $to_go--;
  
          for my $name (@names) {
              my $e = $self->elements->{$name};
              my $o = $ordinal_of->{$name};
  
              my @deps;
  
              my $w = $e->{widget};
  
              if($w->dependencies) {
                  push @deps, keys %{$w->dependencies};
              }
  
              if($w->source->dependencies) {
                  push @deps, keys %{$w->source->dependencies};
              }
  
              my $max = $o;
              if(@deps) {
                  $max = 1 + List::Util::max( @{$ordinal_of}{@deps} );
              }
  
              if($max != $o) {
                  $change = 1;
                  $ordinal_of->{$w->package->name} = $max;
              }
          }
  
          if(!$change) {
              return $ordinal_of;
          }
      }
  
      die 'Circular dependency found';
  }
  
  sub dot_graph {
      my ($self, $dotname) = @_;
      my @names = keys %{$self->elements};
  
      open(my $dot_f, '>', $dotname) 
      || die "Could not open '$dotname': $!";
  
      print { $dot_f } "digraph {\n";
  
      print { $dot_f } "node [shape=record];\n";
  
      for my $name (@names) {
          my $e = $self->elements->{$name};
          my $w = $e->{widget};
          my $v = $w->version->normal;
  
          my $n = $name;
          $n =~ s/[^A-z0-9]//g;
  
          print { $dot_f } qq($n [label="$name&#92;n$v"];\n);
      }
  
      for my $name (@names) {
          my @deps;
  
          my $e = $self->elements->{$name};
          my $w = $e->{widget};
  
          if($w->dependencies) {
              push @deps, keys %{$w->dependencies};
          }
  
          if($w->source->dependencies) {
              push @deps, keys %{$w->source->dependencies};
          }
  
          my $n = $name;
          $n =~ s/[^A-z0-9]//g;
  
          if(@deps) {
              for my $dep (@deps) {
                  my $d = $dep;
                  $d =~ s/[^A-z0-9]//g;
  
                  print { $dot_f } qq(\t"$d"->"$n";\n);
              }
          }
      }
  
      print { $dot_f } "}\n";
      close $dot_f;
  }
  
  sub to_makeflow {
      my ($self, $dir, $dag_name, $builder_exec, $local_database, $cores) = @_;
  
      $self->trimmed_database(catfile($dir,$local_database));
  
      my $makeflow_name = $dag_name;
  
      open(my $mflow_f, '>', catfile($dir,$makeflow_name)) 
      || die "Could not open '$dir/$makeflow_name': $!";
  
      print { $mflow_f } ".MAKEFLOW CATEGORY builds\n";
      print { $mflow_f } ".MAKEFLOW CORES    $cores\n";
      print { $mflow_f } ".MAKEFLOW MEMORY   @{[$cores * 512]}\n";
      print { $mflow_f } ".MAKEFLOW DISK     20000\n";    # 20 GB of disk
      print { $mflow_f } "\n\n";
  
      my $bag    = $self->bag;
      my $root   = $bag->root_dir;
      my $target = catfile($bag->root_dir, $bag->target);
  
      my $home   = $bag->home_dir;
      $home      =~ s/^\Q$root/\$(ROOT_DIR)/;
  
      print { $mflow_f } "RECIPES  = $local_database\n";
      print { $mflow_f } "ROOT_DIR = $root\n";
      print { $mflow_f } "TRGT_DIR = \$(ROOT_DIR)/@{[$bag->target]}\n";
      print { $mflow_f } "HOME_DIR = $home\n";
      print { $mflow_f } "DIST_DIR = " . $bag->files_dir  . "\n";
      print { $mflow_f } "REPO     = " . $bag->repository . "\n";
      print { $mflow_f } "OPTIONS  = --silent=plan --make-jobs \$(CORES) --no-run\n\n";
  
      print { $mflow_f } "RIBBON   = .VC3_DEPENDENCY_BUILD\n\n";
  
      print { $mflow_f } "\n";
      print { $mflow_f } "BUILD_COMMAND  = ./$builder_exec --database \$(RECIPES) --install \$(ROOT_DIR) --home \$(HOME_DIR) --distfiles \$(DIST_DIR) --repository \$(REPO) \$(OPTIONS) --ignore-locks\n";
  
      print { $mflow_f } "\n\n";
      
      my @names = keys %{$self->elements};
      for my $name (@names) {
          my @deps;
  
          my $e = $self->elements->{$name};
          my $w = $e->{widget};
  
          if($w->dependencies) {
              push @deps, keys %{$w->dependencies};
          }
  
          if($w->source && $w->source->dependencies) {
              push @deps, keys %{$w->source->dependencies};
          }
  
          my @inputs;
          for my $d (@deps) {
              my $rname = $self->elements->{$d}->{widget}->ribbon->{filename};
  
              $rname =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
              $rname =~ s/^\Q$target/\$(TRGT_DIR)/;
  
              push @inputs, $rname;
          }
  
          my $output = $w->ribbon->{filename};
          $output =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
          $output =~ s/^\Q$target/\$(TRGT_DIR)/;
  
          print { $mflow_f } "$output: $builder_exec $local_database @inputs\n";
  
          print { $mflow_f } "\t";
  
          if(!$w->source || $w->local) {
              print { $mflow_f } "LOCAL "
          }
  
          print { $mflow_f } "\t\$(BUILD_COMMAND) --require $name\n\n";
      }
  
      close $mflow_f;
  }
  
  sub prestage {
      my ($self) = @_;
  
      for my $e (values %{$self->elements}) {
          $e->widget->source->get_files();
      }
  }
  
  sub trimmed_database {
      my ($self, $filename) = @_;
  
      my $output = {};
  
      for my $e (values %{$self->elements}) {
          my $ph = $e->widget->package->to_hash;
          $ph->{versions} = [ $e->widget->to_hash ];
  
          $output->{$e->widget->package->name} = $ph;
      }
  
      open my $f_h, '>', $filename || die "Could not open $filename for writing: $!\n";
  
      my $json = JSON::Tiny::encode_json($output);
  
      print { $f_h } $json, "\n";
  
      close $f_h;
  }
  
  sub to_script {
      my ($self, $filename) = @_;
  
      open my $f_h, '>', $filename || die "Could not open $filename for writing: $!\n";
  
      for my $w (@{$self->order}) {
          $self->bag->activate_widget_vars($w);
          $self->bag->set_environment_variables($f_h);
          $self->bag->activate_widget($w);
      }
  
      close $f_h;
  }
  
  
  package version;
  sub TO_JSON {
      my ($self) = @_;
      return $self->normal;
  }
  
  1;
  
VC3_PLAN

$fatpacked{"VC3/Plan/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_PLAN_ELEMENT';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Plan::Element;
  
  sub new {
      my ($class, $widget, $min, $max) = @_;
  
      my $self = bless {}, $class;
  
      if($min && $max && $min gt $max) {
          die 'Incompatible versions';
      }
  
      $self->{widget} = $widget;
      $self->{min}    = $min;
      $self->{max}    = $max;
  
      return $self;
  }
  
  sub widget {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{widget} = $new;;
      }
  
      return $self->{widget};
  }
  
  sub min {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{min} = $new;
      }
  
      return $self->{min};
  }
  
  sub max {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{max} = $new;
      }
  
      return $self->{max};
  }
  
  sub refine {
      my ($self, $new_min, $new_max) = @_;
  
      if($new_min && $self->{max} && $new_min gt $self->{max}) {
          return undef;
      }
  
      if($new_max && $self->{min} && $new_max lt $self->{min}) {
          return undef;
      }
  
      # take the more restrictive min
      my $min = $new_min || $self->{min};
      if($new_min && $self->{min}) {
          $min = $new_min lt $self->{min} ? $self->{min} : $new_min;
      }
  
      # take the more restrictive max
      my $max = $new_max || $self->{max};
      if($new_max && $self->{max}) {
          $max = $new_max lt $self->{max} ? $new_max : $self->{max};
      }
  
      if($min && $min gt $self->{widget}->version) { 
          return undef;
      }
  
  
      if($max && $max lt $self->{widget}->version) {
          return undef;
      }
          
      return VC3::Plan::Element->new($self->{widget}, $min, $max);
  }
  
  1;
  
VC3_PLAN_ELEMENT

$fatpacked{"VC3/Ribbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_RIBBON';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Ribbon;
  
  use File::Basename; 
  use LockFile::Simple qw(lock unlock);
  use File::Spec::Functions qw/catfile rel2abs/;
  
  sub new {
      my ($class, $name, $install_dir, $tmpdir, $checksum) = @_;
  
      my $self = bless {}, $class;
  
      $self->{filename} = catfile($install_dir, '.VC3_DEPENDENCY_BUILD');
      $self->{lockname} = catfile($tmpdir, $name . '.lock');
      $self->{checksum} = $checksum;
  
      $self->{lockmgr} = LockFile::Simple->make(-hold => 3600, -autoclean => 1, -max => 99999, -delay => 5, -stale => 1, -wmin => 2,
          -wfunc => sub { LockFile::Simple::core_warn("Waiting for a lock for '$name'. If you think this lock is stale, please remove the file:\n'" . $self->{lockname} . "'\n") }
      );
  
      return $self;
  }
  
  sub commit {
      my ($self, $state) = @_;
  
      my $ribbon_fh = IO::Handle->new();
      open ($ribbon_fh, '>', $self->{filename});
  
      my $report = {};
      $report->{state}    = $state;
      $report->{checksum} = $self->{checksum};
      $report->{time}     = time();
  
      printf { $ribbon_fh } JSON::Tiny::encode_json($report);
  
      $ribbon_fh->flush();
      $ribbon_fh->sync();
  
      $ribbon_fh->close();
  }
  
  sub set_lock {
      my ($self) = @_;
  
      # make sure parent directory exists
      File::Path::make_path( dirname($self->{filename}) );
  
      $self->{lockobj} = $self->{lockmgr}->lock($self->{filename}, $self->{lockname});
  }
  
  sub release_lock {
      my ($self) = @_;
      $self->{lockobj}->release();
  }
  
  sub state {
      my ($self) = @_;
  
      my $name = $self->{filename};
      my $state = 'MISSING';
  
      if(-f $name) {
          open my $ribbon_fh, '<', $name || warn $!;
  
          if($ribbon_fh) {
              my $contents = do { local($/); <$ribbon_fh> };
              close($ribbon_fh);
  
              my $report;
              eval { $report = JSON::Tiny::decode_json($contents) };
              if($@) {
                  $state = 'MISSING';
              }
  
              if(!$report->{state}) {
                  $state = 'MISSING';
              } elsif(!$report->{checksum}) {
                  $state = 'MISSING';
              } elsif($report->{checksum} ne $self->{checksum}) {
                  $state = 'OUT_OF_DATE';
              } elsif($report->{state} eq 'PROCESSING') {
                  $state = 'PROCESSING';
              } else {
                  $state = $report->{state};
              }
          }
      }
  
  
      return $state;
  }
  
  1;
  
VC3_RIBBON

$fatpacked{"VC3/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source;
  use Carp;
  
  use VC3::Source::Generic;
  use VC3::Source::Configure;
  use VC3::Source::CMake;
  use VC3::Source::Tarball;
  use VC3::Source::ManualDist;
  use VC3::Source::Binary;
  use VC3::Source::System;
  use VC3::Source::Perl;
  use VC3::Source::Container::Singularity;
  use VC3::Source::Container::Docker;
  use VC3::Source::OSNative;
  
  our $class_of = {};
  
  $class_of->{'generic'}             = 'VC3::Source::Generic';
  $class_of->{'configure'}           = 'VC3::Source::Configure';
  $class_of->{'cmake'}               = 'VC3::Source::CMake';
  $class_of->{'tarball'}             = 'VC3::Source::Tarball';
  $class_of->{'manual-distribution'} = 'VC3::Source::ManualDist';
  $class_of->{'binary'}              = 'VC3::Source::Binary';
  $class_of->{'system'}              = 'VC3::Source::System';
  $class_of->{'cpan'}                = 'VC3::Source::Perl';
  $class_of->{'singularity'}         = 'VC3::Source::Container::Singularity';
  $class_of->{'docker'}              = 'VC3::Source::Container::Docker';
  $class_of->{'os-native'}           = 'VC3::Source::OSNative';
  
  sub new {
      my ($widget, $source_raw) = @_;
  
      my $type  = $source_raw->{type} || 'generic';
      my $class = $class_of->{$type};
  
      unless($class) {
          die "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->package->name . "'\n";
      }
  
      return $class->new($widget, $source_raw);
  }
  
  1;
  
VC3_SOURCE

$fatpacked{"VC3/Source/AutoRecipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_AUTORECIPE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::AutoRecipe;
  use base 'VC3::Source::Tarball';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      # dummy recipe, so Tarball does not complain.
      $json_description->{recipe} = ['dummy'];
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      $self->preface($json_description->{preface});
      $self->options($json_description->{options});
      $self->postface($json_description->{postface});
  
      my @steps;
      if($self->preface) {
          push @steps, @{$self->preface};
      }
  
      push @steps, @{$self->autorecipe};
  
      if($self->postface) {
          push @steps, @{$self->postface};
      }
  
      $self->recipe(\@steps);
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $sh = $self->SUPER::to_hash();
      $sh->{preface}  = $self->preface;
      $sh->{options}  = $self->options;
      $sh->{postface} = $self->postface;
  
      # automatically computed, so we delete it.
      delete $sh->{recipe};
  
      for my $k (keys %{$sh}) {
          unless(defined $sh->{$k}) {
              delete $sh->{$k};
          }
      }
  
      return $sh;
  }
  
  sub preface {
      my ($self, $new_preface) = @_;
  
      $self->{preface} = $new_preface if($new_preface);
  
      return $self->{preface};
  }
  
  sub postface {
      my ($self, $new_postface) = @_;
  
      $self->{postface} = $new_postface if($new_postface);
  
      return $self->{postface};
  }
  
  sub options {
      my ($self, $new_options) = @_;
  
      $self->{options} = $new_options if($new_options);
  
      return $self->{options};
  }
  
  sub autorecipe {
      die 'No autorecipe defined.';
  }
  
  1;
  
VC3_SOURCE_AUTORECIPE

$fatpacked{"VC3/Source/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_BINARY';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Binary;
  use base 'VC3::Source::Generic';
  use Carp;
  # Right now, do the same as generic, but ensure we do it locally in parallel builds.
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $widget->local(1);
  
      unless($json_description->{prerequisites}) {
          if($json_description->{native}) {
              $json_description->{prerequisites} = [
                  ": check if native is prefix of target",
                  'pref=${VC3_MACHINE_TARGET#' . $json_description->{native} . '}',
                  '[ "$pref" != ${VC3_MACHINE_TARGET} ] || exit 1'
              ];
          }
      }
  
      unless($json_description->{recipe}) {
          $json_description->{recipe} = [
              'mkdir -p ${VC3_PREFIX}',
              'for file in $VC3_FILES; do',
              '   tar -C ${VC3_PREFIX} --strip-components=1 -xf $file',
              'done'
          ]
      }
  
      return $class->SUPER::new($widget, $json_description);
  }
  
  1;
  
VC3_SOURCE_BINARY

$fatpacked{"VC3/Source/CMake.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CMAKE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::CMake;
  use base 'VC3::Source::AutoRecipe';
  use Carp;
  
  sub autorecipe {
      my ($self) = @_;
  
      $self->{dependencies}{'cmake'} ||= ['v3.5.0'];
  
      my $conf = 'cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX}';
      if($self->options) {
          $conf = join(' ', $conf, $self->options);
      }
  
      $conf .= ' ..';
  
      return [ 'mkdir -p build', 'cd build', $conf, 'make', 'make install' ];
  }
  
  1;
  
VC3_SOURCE_CMAKE

$fatpacked{"VC3/Source/Configure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONFIGURE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Configure;
  use base 'VC3::Source::AutoRecipe';
  use Carp;
  
  sub autorecipe {
      my ($self) = @_;
  
      my $conf = './configure --prefix ${VC3_PREFIX}';
  
      if($self->options) {
          $conf = join(' ', $conf, $self->options);
      }
  
      return [ $conf, 'make', 'make install' ];
  }
  
  1;
  
VC3_SOURCE_CONFIGURE

$fatpacked{"VC3/Source/Container.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONTAINER';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Container;
  use base 'VC3::Source::System';
  use JSON::Tiny;
  use Carp;
  use File::Copy;
  use File::Spec::Functions qw/catfile file_name_is_absolute/;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      if($widget->wrapper) {
          die "Wrapper specified in conflict with '" . $widget->package->name . "'\n";
      }
  
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      # anything with a Container source becomes an operating system
      $self->widget->package->type('operating-system');
  
      my $image = $json_description->{image};
      unless($image) {
          die "No image specified for '" . $widget->package->name . "'\n";
      }
  
      $json_description->{'images-directory'} ||= 'images';
  
      if($image =~ m^://^ or file_name_is_absolute($image)) {
          $self->image($image);
      } else {
          $image = catfile($json_description->{'images-directory'}, $image);
          $self->image(catfile($self->widget->package->bag->files_dir, $image));
          push @{$self->files}, $image;
      }
  
      return $self;
  }
  
  sub setup_wrapper {
      my ($self, $exe, $builder_args, $mount_map) = @_;
  
      die "Container Source did not define a wrapper.\n";
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $sh = $self->SUPER::to_hash();
      $sh->{image} = $self->image;
  
      # wrapper is generated automatically:
      delete $sh->{wrapper};
  
      return $sh;
  }
  
  sub image {
      my ($self, $new_image) = @_;
  
      $self->{image} = $new_image if($new_image);
  
      unless($self->{image}) {
          die "Container recipe for '" . $self->widget->package->name . "' did not define an 'image' field.\n";
      }
      
      return $self->{image};
  }
  
  sub prepare_recipe_sandbox {
      my ($self, $exe, $builder_args, $payload_args, $mount_map) = @_;
  
      $self->get_files();
  
      my $bag = $self->widget->package->bag;
      my ($root, $home, $files, $tmp) = ($bag->root_dir, $bag->home_dir, $bag->files_dir, $bag->tmp_dir);
  
      my $root_target  = $self->add_mount($mount_map, $bag->root_dir,  '/vc3/vc3-root');
      my $home_target  = $self->add_mount($mount_map, $bag->home_dir,  '/vc3/vc3-home');
      my $files_target = $self->add_mount($mount_map, $bag->files_dir, '/vc3/vc3-distfiles');
  
      my $builder_path = catfile($bag->tmp_dir, 'vc3-builder');
      copy($0, $builder_path);
      chmod 0755, $builder_path;
  
      my $recipe_path = catfile($bag->tmp_dir, 'vc3-recipes');
      copy($bag->sh_profile . '.recipes', $recipe_path);
  
      my @new_builder_args;
      push @new_builder_args, catfile($root_target, 'tmp', 'vc3-builder');
      push @new_builder_args, '--no-os-switch';
      push @new_builder_args, $self->remove_args(@{$builder_args});
      push @new_builder_args, ('--install',   $root_target);
      push @new_builder_args, ('--distfiles', $files_target);
      push @new_builder_args, ('--home',      $home_target);
      push @new_builder_args, ('--database',  catfile($root_target, 'tmp', 'vc3-recipes'));
  
  
      if(scalar @{$payload_args} > 0) {
          push @new_builder_args, '--';
          push @new_builder_args, @{$payload_args};
      }
  
      my $wrapper = $self->setup_wrapper($exe, \@new_builder_args, $mount_map);
  
      $self->widget->wrapper($wrapper);
  }
  
  sub add_mount {
      my ($self, $mount_map, $from, $default_target) = @_;
  
      unless($mount_map->{$from}) {
          $mount_map->{$from} = $default_target;
      }
  
      return $mount_map->{$from};
  }
  
  sub remove_args {
      my ($self, @args) = @_;
  
      my @builder_args;
  
      my $prev_no_equal = 0;
      for my $a (@args) {
          if($prev_no_equal) {
              $prev_no_equal = 0;
              next;
          }
  
          if($a =~ m/^--mount=/) {
              next;
          }
  
          if($a =~ m/^--mount$/) {
              $prev_no_equal = 1;
              next;
          }
  
          if($a =~ m/^--database=/) {
              next;
          }
  
          if($a =~ m/^--database$/) {
              $prev_no_equal = 1;
              next;
          }
  
          push @builder_args, $a;
      }
  
      return @builder_args;
  }
  
  1;
  
VC3_SOURCE_CONTAINER

$fatpacked{"VC3/Source/Container/Docker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONTAINER_DOCKER';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Container::Docker;
  use base 'VC3::Source::Container';
  use Carp;
  use File::Copy;
  use File::Spec::Functions qw/catfile file_name_is_absolute/;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $json_description->{'images-directory'} = 'images/docker';
      my $self = $class->SUPER::new($widget, $json_description);
  
      $self->drop_priviliges($json_description->{'drop-priviliges'});
  
      return $self;
  }
  
  sub drop_priviliges {
      my ($self, $new_drop_priviliges) = @_;
  
      if(defined $new_drop_priviliges) {
          $self->{drop_priviliges} = $new_drop_priviliges;
      }
  
      return $self->{drop_priviliges};
  }
  
  sub setup_wrapper {
      my ($self, $exe, $builder_args, $mount_map) = @_;
  
      my $bag = $self->widget->package->bag;
  
      my @wrapper;
      push @wrapper, $exe;
      push @wrapper, '--require=docker';
      push @wrapper, '--revar=".*"';
      push @wrapper, '--install='    . $self->widget->package->bag->root_dir;
      push @wrapper, '--home='       . $self->widget->package->bag->home_dir;
      push @wrapper, '--distfiles='  . $self->widget->package->bag->files_dir;
      push @wrapper, '--repository=' . $self->widget->package->bag->repository;
  
      push @wrapper, '--';
  
      push @wrapper, 'docker';
      push @wrapper, 'run';
  
      push @wrapper, '--rm=true';
  
      # it would be nice to have this one, but we can't because we need to create
      # the user...
      #push @wrapper, '--read-only';
  
      # for things that need ptrace:
      push @wrapper, ('--security-opt', 'seccomp=unconfined');
  
      if($bag->{on_terminal}) {
          push @wrapper, ('-i', '-t');
      }
  
      for my $from (keys %{$mount_map}) {
          push @wrapper, ('--volume', $from . ':' . $mount_map->{$from});
      }
  
      push @wrapper, ('--tmpfs', '/tmp');
  
      push @wrapper, ('--workdir', $mount_map->{$bag->home_dir()});
  
      if($self->drop_priviliges) {
          push @wrapper, ('--entrypoint', '/sbin/run-with-user');
      }
  
      my $image = $self->image;
      if($image =~ m#^docker://#) {
          $image =~ s#^docker://##;
      } elsif(-f $image) {
          system("docker load -i $image");
      } else {
          die "I don't know how to process '$image'\n";
      }
  
      push @wrapper, $image;
  
      # pass first arguments to run-with-user, if needed
      if($self->drop_priviliges) {
          push @wrapper, ($bag->user_uid, $bag->user_gid);
      }
  
      push @wrapper, @{$builder_args};
  
      return \@wrapper;
  }
  
  1;
  
VC3_SOURCE_CONTAINER_DOCKER

$fatpacked{"VC3/Source/Container/Singularity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONTAINER_SINGULARITY';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Container::Singularity;
  use base 'VC3::Source::Container';
  use Carp;
  use File::Copy;
  use File::Spec::Functions qw/catfile file_name_is_absolute/;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $json_description->{'images-directory'} = 'images/singularity';
      my $self = $class->SUPER::new($widget, $json_description);
  
      return $self;
  }
  
  sub setup_wrapper {
      my ($self, $exe, $builder_args, $mount_map) = @_;
  
      my @wrapper;
      push @wrapper, $exe;
      push @wrapper, '--require=singularity';
      push @wrapper, '--revar=".*"';
      push @wrapper, '--install='    . $self->widget->package->bag->root_dir;
      push @wrapper, '--home='       . $self->widget->package->bag->home_dir;
      push @wrapper, '--distfiles='  . $self->widget->package->bag->files_dir;
      push @wrapper, '--repository=' . $self->widget->package->bag->repository;
  
      push @wrapper, '--';
  
      push @wrapper, 'singularity';
      push @wrapper, 'exec';
  
      for my $from (keys %{$mount_map}) {
          push @wrapper, ('-B', $from . ':' . $mount_map->{$from});
      }
  
      push @wrapper, $self->image;
  
      push @wrapper, @{$builder_args};
  
      return \@wrapper;
  }
  
  1;
  
VC3_SOURCE_CONTAINER_SINGULARITY

$fatpacked{"VC3/Source/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_GENERIC';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Generic;
  use Carp;
  use File::Basename;
  use File::Copy;
  use File::Path;
  use File::Spec::Functions qw/catfile rel2abs/;
  use File::stat;
  use Time::gmtime;
  use HTTP::Tiny;
  use POSIX ":sys_wait_h";
  use parent;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      my $self = bless {}, $class;
  
      $self->widget($widget);
      $self->recipe($json_description->{recipe});
      $self->files($json_description->{files});
      $self->mirrors($json_description->{mirrors});
      $self->msg_manual_requirement($json_description->{'msg-manual-requirement'});
      $self->dependencies($json_description->{dependencies});
      $self->prerequisites($json_description->{prerequisites});
  
  
      $self->type($json_description->{type} || 'generic');
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $sh = {};
  
      $sh->{type}          = $self->type;
      $sh->{recipe}        = $self->recipe;
      $sh->{files}         = $self->files;
      $sh->{mirrors}       = $self->mirrors;
      $sh->{dependencies}  = $self->dependencies;
      $sh->{prerequisites} = $self->prerequisites;
      $sh->{'msg-manual-requirement'} = $self->msg_manual_requirement;
  
      for my $k (keys %{$sh}) {
          unless(defined $sh->{$k}) {
              delete $sh->{$k};
          }
      }
  
      return $sh;
  }
  
  sub type {
      my ($self, $new_type) = @_;
  
      $self->{type} = $new_type if($new_type);
  
      return $self->{type};
  }
  
  sub widget {
      my ($self, $new_widget) = @_;
  
      $self->{widget} = $new_widget if($new_widget);
  
      croak 'No argument given'
      unless($self->{widget}); 
  
      return $self->{widget};
  }
  
  sub bag {
      my ($self) = @_;
  
      return $self->widget->package->bag;
  }
  
  sub recipe {
      my ($self, $new_recipe) = @_;
  
      $self->{recipe} = $new_recipe if($new_recipe);
  
      unless($self->{recipe}) {
          $self->{recipe} = ['echo "no explicit recipe given"'];
      }
  
      return $self->{recipe};
  }
  
  sub files {
      my ($self, $new_files) = @_;
  
      $self->{files} = $new_files if($new_files);
  
      unless($self->{files}) {
          $self->{files} = [];
      }
  
      return $self->{files};
  }
  
  sub mirrors {
      my ($self, $new_mirrors) = @_;
  
      $self->{mirrors} = $new_mirrors if($new_mirrors);
  
      unless($self->{mirrors}) {
          $self->{mirrors} = [];
      }
  
      return $self->{mirrors};
  }
  
  sub msg_manual_requirement {
      my ($self, $new_message) = @_;
  
      if($new_message) {
          $self->{msg_manual_requirement} = $new_message;
      }
  
      return $self->{msg_manual_requirement};
  }
  
  sub check_manual_requirements {
      my ($self, $new_message) = @_;
  
      # by default return true. Usually packages do not have manual requirements.
      return 1;
  }
  
  sub file_absolute {
      my ($self, $file) = @_;
      return rel2abs(catfile($self->bag->files_dir, $file));
  }
  
  sub dependencies {
      my ($self, $new_dependencies) = @_;
  
      if($new_dependencies) {
          $self->{dependencies} = {};
  
          for my $name (keys %{$new_dependencies}) {
              my $versions = $new_dependencies->{$name};
              my ($min_version, $max_version) = @{$versions};
  
              if($min_version) {
                  $min_version = version->declare($min_version);
              }
  
              if($max_version) {
                  $max_version = version->declare($max_version);
  
                  my $num = $max_version->numify();
                  my $fix = ($num * 1000000) % 1000;
                  $num   += 0.000999 unless($fix);
                  $max_version = version->declare($num);
  
                  unless($min_version) {
                      $min_version = version->declare('v0.0.0');
                  }
              }
  
              $self->{dependencies}{$name} = [];
  
              if($min_version) {
                  push @{$self->{dependencies}{$name}}, $min_version;
              }
  
              if($max_version) {
                  push @{$self->{dependencies}{$name}}, $max_version;
              }
          }
      }
  
      return $self->{dependencies};
  }
  
  sub prerequisites {
      my ($self, $new_prerequisites) = @_;
  
      $self->{prerequisites} = $new_prerequisites if($new_prerequisites);
  
      return $self->{prerequisites};
  }
  
  sub check_prerequisites {
      my ($self) = @_;
  
      # by default return true. Usually packages do not have prerequisites.
      unless($self->prerequisites()) {
          return 0;
      }
  
      my @steps = @{$self->prerequisites};
  
      my ($pid, $pre_in) = $self->widget->package->bag->shell();
  
      print { $pre_in } "exec 1>> /dev/null\n";
      print { $pre_in } "exec 2>&1\n";
      print { $pre_in } "set -ex\n";
  
  
      # add shifting to tmp directory as the first step.
      unshift @steps, 'cd ' . $self->bag->tmp_dir;
  
      # add exiting cleanly from shell as a last step.
      push @steps, 'exit 0';
  
      for my $step (@steps) {
          print { $pre_in } "$step\n";
      }
  
      my $exit_status = -1;
      eval { close $pre_in; $exit_status = $? };
  
      if(!$@ && WIFEXITED($exit_status) && (WEXITSTATUS($exit_status) == 0)) {
          return 0;
      } else {
          return -1;
      }
  }
  
  sub say {
      my $self = shift @_;
  
      return $self->widget->say(@_);
  }
  
  sub get_file {
      my ($self, $file) = @_;
  
      my @mirrors = @{$self->mirrors};
  
      unless( grep { $_ eq $self->bag->repository } @mirrors ) {
          push @mirrors, $self->bag->repository;
      }
  
      for my $m (@mirrors) {
          eval { $self->get_file_from_mirror($m, $file); };
  
          return unless $@;
  
          $self->bag->say($@);
      }
  
      die "Could not download '$file' from any of the mirrors.\n";
  }
  
  sub get_file_from_mirror {
      my ($self, $mirror, $file) = @_;
  
      $self->say("downloading '" . $file . "' from " . $mirror);
  
      my $ff = HTTP::Tiny->new();
  
      my $url    = $mirror . '/' . $file;
      my $output = catfile($self->bag->files_dir,  $file);
  
      my $retries = 5;
      my $sleep_before_retry = 5; # seconds
  
      my $last_modification;
      if(-f $self->file_absolute($file)) {
          # + 1 because when dates are the same, HTTP::Tiny is downloading the file...
          $last_modification = gmctime(stat($self->file_absolute($file))->mtime + 1);
      } else {
          $last_modification = gmctime(0)
      }
  
      for my $i (1..$retries) {
  
          my $response = $ff->mirror($url, $output,
              {'headers' => {
                      'If-Modified-Since' => $last_modification }});
  
          # 304 means file did not change from the last time we downloaded it
          if($response->{status} == 304) {
              $self->say("local copy of '" . $file . "' was up to date.");
          }
  
          return if $response->{success};
  
          # retries:
          # 408 is request timeout
          # 503 is service unavailable
          # 504 is a gatewat timeout
          # 524 is a cloudflare timeout
          # 599 is an internal exception of HTTP::Tiny, which may be a timeout too.
  
          if( grep { $response->{status} == $_ } (408,503,504,524,599) ) {
              print "Could not download '" . $file . "':\n" . "$response->{status}: $response->{reason}\n";
              print "$response->{content}\n" if $response->{content};
              print "Retrying @{[$retries - $i]} more time(s)\n"; 
  
              VC3::Builder::select_sleep($sleep_before_retry);
  
              next;
          }
  
          die "Could not download '" . $file . "':\n" . "$response->{status} $response->{reason}";
      }
  
      die "Could not download '" . $file . "':\n";
  }
  
  sub get_files {
      my ($self) = @_;
  
      my $files = $self->files;
  
      for my $file (@{$files}) {
          $self->get_file($file);
      }
  }
  
  sub prepare_files {
      my ($self, $build_dir) = @_;
  
      for my $file (@{$self->files}) {
          symlink($self->file_absolute($file), catfile($build_dir, basename($file)))
          || die "Could not link '" . $file . "' to build directory.\n";
      }
  }
  
  
  sub prepare_recipe_sandbox {
      my ($self) = @_;
  
  
      my $no_erase = $self->isa('VC3::Source::System');
  
      my $result = $self->widget->prepare_recipe_sandbox($self, $no_erase);
  
      if($result == 0) {
          return 0;
      }
  
      # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
      $self->get_files();
  
      # if generic, copy all files to build directory.
      # if tarball, expand first file to build directory, and copy the rest of
      # the files to build directory.
      $self->prepare_files($self->widget->build_dir);
  
      return 1;
  }
  
  sub cleanup_recipe_sandbox {
      my ($self, $result) = @_;
      return $self->widget->cleanup_recipe_sandbox($result);
  }
  
  
  sub execute_recipe {
      my ($self, $force_rebuild, $ignore_locks) = @_;
  
      my $result = 1;
  
      unless($ignore_locks) {
          $self->widget->ribbon->set_lock();
      }
  
      eval {
          my $state = $self->widget->ribbon->state;
  
          if($state eq 'DONE' && !$force_rebuild && !$self->widget->phony) {
              $result = 0;
          } else {
              $self->say("preparing '" . $self->widget->package->name . "' for " . $self->widget->package->bag->target);
              if($self->widget->package->bag->dry_run) {
                  $result = 0;
              } else {
                  $self->prepare_recipe_sandbox();
                  $result = $self->execute_recipe_unlocked();
                  $self->cleanup_recipe_sandbox($result);
              }
          }
      };
  
      my $error_msg = $@;
  
      unless($ignore_locks) {
          $self->widget->ribbon->release_lock();
      }
  
      if($error_msg) {
          die $error_msg;
      }
  
      return $result;
  }
  
  sub execute_recipe_unlocked {
      my ($self) = @_;
  
      unless($self->isa('VC3::Source::System')) {
          $self->widget->ribbon->commit('PROCESSING');
      }
  
      my $result = -1;
      my ($pid, $build_in) = $self->setup_build_shell();
  
      my @steps = @{$self->recipe};
  
      # add shifting to build directory as the first step.
      unshift @steps, 'cd ' . $self->widget->build_dir;
  
      # add exiting cleanly from shell as a last step.
      push @steps, 'exit 0';
  
      $self->say("details: " .  $self->widget->build_log);
  
      for my $step (@steps) {
          print { $build_in } "$step\n";
      }
  
      my $status = -1;
      eval { close $build_in; $status = $? };
      if($@) {
          carp $@;
      }
  
      $self->widget->{child_pid} = undef;
  
      if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
          $result = 0;
      }
  
      return $result;
  }
  
  sub setup_build_shell {
      my ($self) = @_;
      return $self->widget->setup_build_shell(@{$self->recipe});
  }
  
  1;
VC3_SOURCE_GENERIC

$fatpacked{"VC3/Source/ManualDist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_MANUALDIST';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::ManualDist;
  use base 'VC3::Source::Generic';
  use Carp;
  
  use File::Spec::Functions qw/rel2abs catfile/;
  
  sub get_file {
      my ($self, $file) = @_;
  
      unless(-f $self->file_absolute($file)) {
          die "Missing manual or restricted distribution file '$file'.\n";
      }
  }
  
  sub file_absolute {
      my ($self, $file) = @_;
      return rel2abs(catfile($self->bag->files_dir, 'manual-distribution', $file));
  }
  
  sub check_manual_requirements {
      my ($self) = @_;
  
      for my $file (@{$self->files}) {
          unless(-f $self->file_absolute($file)) {
              # check failed, return false
              return 0;
          }
      }
  
      return 1;
  }
  
  1;
  
VC3_SOURCE_MANUALDIST

$fatpacked{"VC3/Source/OSNative.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_OSNATIVE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::OSNative;
  use base 'VC3::Source::System';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $widget->local(1);
  
      unless($json_description->{prerequisites}) {
  
          unless($json_description->{native}) {
              die "No method to verify native OS provided. Add prerequisites or native field.\n";
          }
  
          $json_description->{prerequisites} = [
              ": check if native is prefix of target",
              'pref=${VC3_MACHINE_TARGET#' . $json_description->{native} . '}',
              '[ "$pref" != ${VC3_MACHINE_TARGET} ] || exit 1'
          ];
      }
  
      unless($json_description->{'auto-version'}) {
  
          my $dver = $widget->package->bag->distribution;
          
          unless($dver =~ s/^.*[^0-9.]([0-9.]+)$/$1/) {
              $widget->available(0);
              die "Could not find version of distribution in '$dver'\n";
          }
  
          $json_description->{'auto-version'} = [
              "echo VC3_VERSION_SYSTEM: $dver"
          ]
      }
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      return $self;
  }
  
  
  1;
  
VC3_SOURCE_OSNATIVE

$fatpacked{"VC3/Source/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_PERL';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Perl;
  use base 'VC3::Source::Generic';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      unless($json_description->{recipe}) {
          my @steps;
          push @steps, "cpanm --notest --mirror \${VC3_MODULES_PERL_LOCAL_CPAN}/perl --mirror-only " . $json_description->{files}->[0];
          $json_description->{recipe} = \@steps;
      }
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      unless($self->files) {
          croak "For type 'perl', at least one file should be defined in the files list.";
      }
  
      unless($self->dependencies) {
          $self->dependencies({});
      }
  
      $self->{dependencies}{'perl-cpanminus'} ||= [];
  
      return $self;
  }
  
  sub prepare_files  {
      my ($self, $build_dir) = @_;
  
      # do nothing
      return;
  }
  
  sub get_file {
      my ($self) = @_;
  
      # do nothing
      return;
  }
  
  1;
  
VC3_SOURCE_PERL

$fatpacked{"VC3/Source/System.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_SYSTEM';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::System;
  use base 'VC3::Source::Generic';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $widget->local(1);
      $widget->phony(1);
  
      my $exe    = $json_description->{executable};
      my $switch = $json_description->{"version-switch"} || '--version';
  
      if($exe) {
          $json_description->{prerequisites} ||= [];
          unshift @{$json_description->{prerequisites}}, "which $exe";
  
          unless($json_description->{recipe}) {
              $json_description->{recipe} = [
                  "bin=\$(dirname \$(which $exe))",
                  "echo VC3_ROOT_SYSTEM: \${bin%%bin}"
              ];
          }
  
          unless($json_description->{'auto-version'}) {
              $json_description->{'auto-version'} = [
                  "echo VC3_VERSION_SYSTEM: \$($exe $switch | head -n1 | sed -n -r -e \"s/(^|.*[ \\\"'])([0-9]+(\\.[0-9]+){0,2}).*/\\2/p\")"
              ];
          }
      }
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      $self->auto_version($json_description->{'auto-version'});
  
      return $self;
  }
  
  sub auto_version {
      my ($self, $new_auto_version) = @_;
  
      $self->{auto_version} = $new_auto_version if($new_auto_version);
  
      return $self->{auto_version};
  }
  
  sub execute_recipe_unlocked {
      my ($self) = @_;
  
      my $output_filename = $self->widget->build_log;
  
      my $result;
      eval { $result = $self->SUPER::execute_recipe_unlocked(); };
  
      if($@) {
          die $@;
      } else {
          open(my $f, '<', $output_filename) || die 'Did not produce root directory file';
          my $root;
          while( my $line = <$f>) {
              if($line =~ m/^VC3_ROOT_SYSTEM:\s*(?<root>.*)$/) {
                  $root = $+{root};
                  chomp($root);
  
                  # update root from widget with the new information:
                  $self->widget->root_dir($root);
                  last;
              }
          }
          close $f;
          unless(defined($root)) {
              die 'Did not produce root directory information.';
          }
      }
  
      return $result;
  }
  
  1;
  
VC3_SOURCE_SYSTEM

$fatpacked{"VC3/Source/Tarball.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_TARBALL';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Tarball;
  use base 'VC3::Source::Generic';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      my $self = VC3::Source::Generic->new($widget, $json_description);
  
      unless($self->files) {
          croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
      }
  
      $self = bless $self, $class;
  
      return $self;
  }
  
  sub prepare_files  {
      my ($self, $build_dir) = @_;
  
      # first file in $self->files is the tarball, by convention.
      my $tarball = @{$self->files}[0];
      $tarball = $self->file_absolute($tarball);
  
      system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
      die "Could not expand tarball $tarball.\n" if $?;
  
      # link in the rest of the input files.
      $self->SUPER::prepare_files($build_dir);
  }
  
  1;
  
VC3_SOURCE_TARBALL

$fatpacked{"VC3/Widget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_WIDGET';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Widget;
  use Carp;
  use POSIX ":sys_wait_h";
  use IO::Handle;
  use Digest::Perl::MD5 qw(md5_hex);
  use Cwd;
  use File::Temp qw/tempdir/;
  use File::Spec::Functions qw/catfile rel2abs/;
  use JSON::Tiny;
  
  use VC3::Ribbon;
  
  # Attributes:
  # version, source, dependencies, wrapper, prologue, environment_variables, environment_autovars, phony
  sub new {
      my ($class, $pkg, $json_description) = @_;
  
      my $self = bless {}, $class;
  
      $self->package($pkg);
      $self->available(1);
  
      $self->source($json_description->{source});
  
      if($json_description->{version} eq 'auto') {
          $self->from_system(1);
          eval { $self->version($self->compute_auto_version()) };
          if($@) {
              $self->available(0);
          }
      } else {
          $self->version($json_description->{version});
          $self->from_system(0);
      }
  
      $self->dependencies($json_description->{dependencies});
      $self->wrapper($json_description->{wrapper});
      $self->prologue($json_description->{prologue});
      $self->environment_variables($json_description->{'environment-variables'});
      $self->environment_autovars($json_description->{'environment-autovars'});
  
      # should always be executed
      $self->phony($json_description->{phony});
  
      # should recipe be executed locally when using parallel builds?
      $self->local($json_description->{local});
  
  
      if($self->available) {
          my $majminbug = $self->version->normal;
          $majminbug =~ s/^v([0-9]+\.[0-9]+\.[0-9]+)/$1/;
  
          my $majmin = $self->version->normal;
          $majmin    =~ s/^v([0-9]+\.[0-9]+)\..*/$1/;
  
          $self->add_widget_variable('VERSION', $majmin);
          $self->add_widget_variable('VERSION_FULL', $majminbug);
  
          if($self->package->options) {
              $self->add_widget_variable('OPTIONS', @{$self->package->options});
          }
  
          # initialize root dir variable. we use unless here becase root_dir
          # depends on machine target, which is still not set until we process
          # all the operating-system-distribution's
          unless($self->package->type eq 'operating-system-distribution') {
              $self->root_dir();
          }
      }
  
      unless($self->source) {
          my $null_source = {};
          $null_source->{type}   = 'generic';
          $null_source->{recipe} = ['echo "no explicit recipe given"'];
  
          $self->source($null_source);
      }
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $wh = {};
  
      $wh->{version}       = $self->version;
      $wh->{phony}         = $self->phony;
      $wh->{local}         = $self->local;
      $wh->{source}        = $self->source->to_hash;
      $wh->{dependencies}  = $self->dependencies;
      $wh->{wrapper}       = $self->wrapper;
      $wh->{prologue}      = $self->prologue;
      $wh->{'environment-variables'} = $self->environment_variables;
  
      # environment-autovars already included in environment-variables
  
      for my $k (keys %{$wh}) {
          unless(defined $wh->{$k}) {
              delete $wh->{$k};
          }
      }
  
      return $wh;
  }
  
  sub add_widget_variable {
      my ($self, $varname, $value) = @_;
  
      $varname = $self->widget_var($varname);
  
      my $var = {
          name     => $varname,
          value    => $value,
          clobber  => 1,
          absolute => 1
      };
  
      $self->environment_variables([$var]);
  }
  
  sub widget_var {
      my ($self, $varname) = @_;
  
      my $expanded = "VC3_${varname}_" . uc($self->package->name);
  
      # replace - with _, as env vars cannot have - in their names.
      $expanded =~ s/-/_/g;
  
      return $expanded;
  }
  
  sub package {
      my ($self, $new_pkg) = @_;
  
      $self->{package} = $new_pkg if($new_pkg);
  
      croak 'No package given'
      unless($self->{package}); 
  
      return $self->{package};
  }
  
  sub ribbon {
      my ($self) = @_;
  
      unless($self->{ribbon}) {
          $self->{ribbon} = VC3::Ribbon->new($self->package->name, $self->bookeeping_dir, $self->package->bag->tmp_dir, $self->checksum($self->source->recipe));
      }
  
      return $self->{ribbon};
  }
  
  sub version {
      my ($self, $new_version) = @_;
  
      if($new_version) {
          $self->{version} = version->declare($new_version);
      }
  
      unless($self->{version}) {
          croak 'No version given';
      }
  
      return $self->{version};
  }
  
  sub dependencies {
      my ($self, $new_dependencies) = @_;
  
      if($new_dependencies) {
          $self->{dependencies} = $new_dependencies;
      }
  
      my %deps;
      if($self->package->dependencies) {
          %deps = %{$self->package->dependencies};
      }
  
      for my $d (keys %{$self->{dependencies}}) {
          $deps{$d} = $self->{dependencies}->{$d};
      }
  
      return \%deps;
  }
  
  sub source {
      my ($self, $new_source) = @_;
  
      if($new_source) {
          $self->{source} = VC3::Source::new($self, $new_source);
      }
  
      return $self->{source};
  }
  
  sub prologue {
      my ($self, $new_prologue) = @_;
  
      $self->{prologue} = $new_prologue if($new_prologue);
  
      my $prologue = $self->{prologue} || $self->package->prologue;
  
      return $prologue;
  }
  
  sub wrapper {
      my ($self, $new_wrapper) = @_;
  
      $self->{wrapper} = $new_wrapper if($new_wrapper);
  
      my $wrapper = $self->{wrapper} || $self->package->wrapper;
  
      return $wrapper;
  }
  
  
  sub environment_variables {
      my ($self, $new_vars) = @_;
  
      $self->{environment_variables} ||= [];
  
      if($new_vars) {
          unshift @{$self->{environment_variables}}, @{$new_vars};
      }
  
      return [ @{$self->{environment_variables}}, @{$self->package->environment_variables} ];
  }
  
  sub environment_autovars {
      my ($self, $new_autovars) = @_;
  
      my %mappings;
      $mappings{PATH}               = 'bin';
      $mappings{LD_LIBRARY_PATH}    = 'lib';
      $mappings{LIBRARY_PATH}       = 'lib';
      $mappings{C_INCLUDE_PATH}     = 'include';
      $mappings{CPLUS_INCLUDE_PATH} = 'include';
      $mappings{PKG_CONFIG_PATH}    = 'lib/pkgconfig';
      $mappings{PERL5LIB}           = 'lib/perl5/site_perl';
  
      if($new_autovars) {
          $self->{environment_autovars} = $new_autovars;
      }
  
      my @autovars;
      if($self->package->environment_autovars) {
          push @autovars, @{$self->package->environment_autovars};
      }
  
      if($self->{environment_autovars}) {
          push @autovars, @{$self->{environment_autovars}};
      }
  
      $self->{environment_variables} ||= [];
      for my $var (@autovars) {
          my $target = $mappings{$var};
  
          unless($target) {
              die "Unrecognized auto-variable '$var'";
          }
  
          push @{$self->{environment_variables}}, { 'name' => $var, 'value' => $target };
      }
  
      return \@autovars;
  }
  
  sub phony {
      my ($self, $new_phony) = @_;
  
      $self->{phony} = $new_phony if(defined $new_phony);
  
      my $phony = $self->{phony} || $self->package->phony;
  
      return $phony;
  }
  
  sub local {
      my ($self, $new_local) = @_;
  
      $self->{local} = $new_local if($new_local);
  
      return $self->{local};
  }
  
  sub from_system {
      my ($self, $new_from_system) = @_;
  
      $self->{from_system} = $new_from_system if(defined $new_from_system);
  
      return $self->{from_system};
  }
  
  sub available {
      my ($self, $new_available) = @_;
  
      $self->{available} = $new_available if(defined $new_available);
  
      return $self->{available};
  }
  
  sub root_dir {
      my ($self, $new) = @_;
  
      my $old = $self->{root_dir};
  
      my $var_value;
  
      if($new) {
          $self->{root_dir} = $new;
          $var_value = $new;
      }
  
      unless($self->{root_dir}) {
          my $rel = catfile($self->package->bag->target, $self->package->name, $self->version->normal);
          $self->{root_dir} = catfile($self->package->bag->root_dir, $rel);
          $var_value = catfile('${VC3_ROOT}', '${VC3_MACHINE_TARGET}', $self->package->name, 'v${' . $self->widget_var('VERSION_FULL') . '}');
      }
  
      if(!$old || $old ne $self->{root_dir}) {
          $self->add_widget_variable('ROOT', $var_value);
      }
  
      return $self->{root_dir};
  }
  
  sub bookeeping_dir {
      my ($self, $relative) = @_;
  
      my $rel = catfile($self->package->bag->target, $self->package->name, $self->version->normal);
  
      if($relative) {
          return $rel;
      }
  
      return catfile($self->package->bag->root_dir, $rel);
  }
  
  sub build_dir {
      my ($self) = @_;
  
      unless($self->{build_dir}) {
          my $root     = catfile($self->package->bag->root_dir, 'builds');
  
          unless(-d $root) {
              File::Path::make_path($root);
          }
  
          my $template = catfile($root, $self->package->name . '.XXXXXX');
  
          my $tmpdir   = File::Temp::tempdir($template, CLEANUP => 1);
          $self->{build_dir} = $tmpdir;
      }
  
      return $self->{build_dir};
  }
  
  sub build_log {
      my ($self) = @_;
      my $log_name = catfile($self->bookeeping_dir, $self->package->name . '-build-log');
  
      return $log_name;
  }
  
  sub say {
      my $self = shift @_;
  
      return $self->package->bag->say(@_);
  }
  
  sub consolidate_environment_variables {
      my ($self, $expansion) = @_; 
  
      my $vars = $self->environment_variables
      || return;
  
      for my $var (reverse @{$vars}) {
  
          my $name = $var->{name}
          || carp "Environment variable does not have a name.";
  
          my $value = $var->{value}
          || carp "Environment variable '$name' did not define a value.";
  
          my $clobber  = $var->{clobber};
          my $absolute = $var->{absolute};
  
          if($expansion->{$name} && $clobber) {
              my @old_value = @{$expansion->{$name}};
              my $n = @old_value;
              if($n > 1) {
                  carp("Asked to clobber variable '$name', but it already had a value.\n"
                      . "'$value' <> '" . join(',', @old_value) . "'\n");
              }
          }
  
          $expansion->{$name} ||= [];
  
          my @paths;
          if($clobber) {
              # when clobber, we use the value as is, and remove previous expansions.
              @paths = ($value);
              $expansion->{$name} = [];
          } else {
              # otherwise, split paths on :
              @paths = split /:/, $value;
          }
  
          my @current_expansions;
          for my $path (@paths) {
              if(!$absolute) {
                  if($self->root_dir eq $self->bookeeping_dir) {
                      $path = catfile('${' . $self->widget_var('ROOT') . '}', $path);
                  } else {
                      $path = catfile($self->root_dir, $path);
                  }
              }
  
              push @current_expansions, $path;
          }
  
          unshift @{$expansion->{$name}}, @current_expansions;
      }
  }
  
  sub error_debug_info {
      my ($self, $eval_error) = @_;
  
      print "'", $self->package->name, "' failed to build for ", $self->package->bag->target, "\n";
  
      if($eval_error) {
          print $eval_error, "\n";
      }
  
      if(-f $self->build_log) {
          print "Last lines of log file:\n";
          system('tail', $self->build_log);
      }
  }
  
  
  sub process_error {
      my ($self, $sh_on_error, $eval_error, $status) = @_;
  
      if($eval_error || $status) {
          $self->error_debug_info($eval_error);
  
          if($sh_on_error) {
              warn $@ if $@;
  
              my $cwd = getcwd();
  
              $self->package->bag->shell_user();
  
              chdir $cwd;
          }
      }
  }
  
  sub checksum {
      my ($self, $load) = @_;
  
      if(!$self->{checksum}) {
          $load ||= 'no source';
  
          my $txt = $self->hash_to_canonical_str($load);
          my $dgt = md5_hex($txt);
  
          $self->{checksum} = $dgt;
      }
  
      return $self->{checksum};
  }
  
  sub hash_to_canonical_str {
      my ($self, $ref) = @_;
  
      my $str;
  
      if(ref($ref) eq 'HASH') {
          my @ks = sort { $a cmp $b } keys %{$ref};
  
          $str 
          = '{'
          . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
          . '}';
      } elsif(ref($ref) eq 'ARRAY') {
          $str 
          = '['
          . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
          . ']';
      } else {
          $str = $ref;
      }
  
      return $str;
  }
  
  
  sub msgs_manual_requirements {
      my ($self) = @_;
  
      my $source = $self->source;
  
      if(!$self->source->check_manual_requirements()) {
          return $self->source->msg_manual_requirement();
      }
  }
  
  sub prepare_recipe_sandbox {
      my ($self, $source, $no_erase) = @_;
  
      # clear build directory, to avoid bugs from uncleaned sources.
      my $build = $self->build_dir;
      if( -d $build ) {
          File::Path::rmtree($build);
      }
  
      # clear destination directory, to make sure we are running what we believe
      # we are running.
      unless($no_erase) {
          my $dir = $self->root_dir;
          if( -d $dir ) {
              File::Path::rmtree($dir);
          }
  
          if($self->root_dir ne $self->bookeeping_dir) {
              my $dir = $self->bookeeping_dir;
              if( -d $dir ) {
                  File::Path::rmtree($dir);
              }
          }
      }
  
      # create the dirs we removed above.
      File::Path::make_path($self->build_dir);
      File::Path::make_path($self->root_dir);
      File::Path::make_path($self->bookeeping_dir);
  
      # make sure tmp dir exists
      File::Path::make_path($self->package->bag->tmp_dir);
  
      # set the destination directory as an environment variable before
      # setting up the shell, so that the child created inherets it.
      $self->package->bag->add_builder_variable('VC3_PREFIX', $self->root_dir);
      $self->package->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);
      $self->package->bag->add_builder_variable('VC3_FILES',  join(" ", @{$source->files}));
  }
  
  sub cleanup_recipe_sandbox {
      my ($self, $result) = @_;
  
      $self->package->bag->del_builder_variable('VC3_PREFIX');
      $self->package->bag->del_builder_variable('VC3_BUILD');
      $self->package->bag->del_builder_variable('VC3_FILES');
  
      if($result eq '0') {
          File::Path::rmtree($self->build_dir);
          $self->ribbon->commit('DONE');
      }
  
      # we do not delete the buildir in case of error, to ease debugging.
  }
  
  sub setup_build_shell {
      my ($self, @log_messages) = @_;
  
      # log the recipe used. Since we are opening sh with -e, the recipe executes
      # as if all steps were &&-ed together.
      open(my $build_log, '>', $self->build_log);
      print { $build_log } join("\n && ", @log_messages . "\n");
      close $build_log;
  
      # open sh with -e. This terminates the shell at the first step that returns
      # a non-zero status.
      my ($pid, $build_in) = $self->package->bag->shell();
  
      croak "Could not execute shell for building."
      unless $build_in;
  
      # redirect all output to our log file.
      print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
      print { $build_in } "exec 2>&1\n";
      print { $build_in } "set -ex\n";
  
      # return the stdin of the shell, and the pid so we can wait for it.
      return ($pid, $build_in);
  }
  
  sub shell {
      my ($self) = @_;
      return $self->package->bag->shell();
  }
  
  sub compute_auto_version {
      my ($self, $root) = @_;
  
      unless($self->source->auto_version) {
          die "I don't know how to compute the version of '" . $self->package->name . "'\n";
      }
  
      if($root) {
          $self->package->bag->add_builder_variable('VC3_PREFIX', $root);
      }
  
      my ($pid, $auto_in) = $self->package->bag->shell();
  
      if($root) {
          $self->package->bag->del_builder_variable('VC3_PREFIX');
      }
  
      die "Could not execute shell for auto-version.\n"
      unless $auto_in;
  
      my $template = catfile($self->package->bag->tmp_dir, $self->package->name . 'XXXXXX');
      my $fh = File::Temp->new(template => $template, unlink => 1);
      close($fh);
      
      my $fname = $fh->filename;
  
      # redirect all output to our log file.
      print { $auto_in } 'exec 1> ' . $fname . "\n";
      print { $auto_in } "exec 2>&1\n";
      print { $auto_in } "set -ex\n";
  
      if($root) {
          print { $auto_in } q(export PATH="${VC3_PREFIX}/bin":"$PATH") . "\n";
      }
  
      for my $step (@{$self->source->auto_version}) {
          print { $auto_in } "$step\n";
      }
      print { $auto_in } "exit 0\n";
  
      my $status = -1;
      eval { close $auto_in; $status = $? };
  
  
      open(my $f, '<', $fname) || die 'Did not produce auto-version file';
      my @lines;
      my $version;
      while( my $line = <$f>) {
          push @lines, $line;
          if($line =~ m/^VC3_VERSION_SYSTEM:\s*v?(?<version>([0-9]+(\.?[0-9]){0,3}))$/) {
              $version = $+{version};
              chomp($version);
              last;
          }
      }
      close $f;
      if(!$version) {
          die $self->package->name . " did not produce version information.\n";
      }
  
      return $version;
  }
  
  
  sub compute_os_distribution {
      my ($self) = @_;
  
      unless($self->source) {
          die "I don't know how to find the distribution from '" . $self->package->name . "'\n";
      }
  
      my ($pid, $auto_in) = $self->package->bag->shell();
  
      die "Could not execute shell for operating-system-distro.\n"
      unless $auto_in;
  
      my $template = catfile($self->package->bag->tmp_dir, $self->package->name . 'XXXXXX');
      my $fh = File::Temp->new(template => $template, unlink => 1);
      close($fh);
      
      my $fname = $fh->filename;
  
      # redirect all output to our log file.
      print { $auto_in } 'exec 1> ' . $fname . "\n";
      print { $auto_in } "exec 2>&1\n";
      print { $auto_in } "set -ex\n";
  
      for my $step (@{$self->source->recipe}) {
          print { $auto_in } "$step\n";
      }
      print { $auto_in } "exit 0\n";
  
      my $status = -1;
      eval { close $auto_in; $status = $? };
  
      if($@) {
          warn "$@\n";
      }
  
      open(my $f, '<', $fname) || die 'Did not produce a distribution file';
      my @lines;
      my $distro;
      while( my $line = <$f>) {
          push @lines, $line;
          if($line =~ m/^VC3_MACHINE_DISTRIBUTION:\s*(?<distro>.*)/) {
              $distro = $+{distro};
              chomp($distro);
              last;
          }
      }
      close $f;
      if(!$distro) {
          return;
      }
  
      return $self->distro_canonical_name($distro);
  }
  
  sub distro_canonical_name {
      my ($self, $distro) = @_;
  
      my ($name, $version) = ($distro =~ m/(.+) (.+)/);
  
      if($name =~ m/(redhat|rhel|centos|scientific)/) {
          $name = 'redhat';
      } elsif($name =~ m/debian/) {
          $name = 'debian';
      } elsif($name =~ m/ubuntu/) {
          $name = 'ubuntu';
      } elsif($name =~ m/opensuse/) {
          $name = 'opensuse';
      }
  
      return "$name$version";
  }
  
  1;
  
VC3_WIDGET

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.74;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00";
     # use strict, use utf8; use feature;
     $^H |= 0x820700;
     @^H{qw(feature_say feature_state feature_switch)} = (1) x 3;
  }
  
  1
COMMON_SENSE

$fatpacked{"lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB';
  package lib;
  
  # THIS FILE IS AUTOMATICALLY GENERATED FROM lib_pm.PL.
  # ANY CHANGES TO THIS FILE WILL BE OVERWRITTEN BY THE NEXT PERL BUILD.
  
  use Config;
  
  use strict;
  
  my $archname         = $Config{archname};
  my $version          = $Config{version};
  my @inc_version_list = reverse split / /, $Config{inc_version_list};
  
  
  our @ORIG_INC = @INC;	# take a handy copy of 'original' value
  our $VERSION = '0.63';
  
  sub import {
      shift;
  
      my %names;
      foreach (reverse @_) {
  	my $path = $_;		# we'll be modifying it, so break the alias
  	if ($path eq '') {
  	    require Carp;
  	    Carp::carp("Empty compile time value given to use lib");
  	}
  
  	if ($path !~ /\.par$/i && -e $path && ! -d _) {
  	    require Carp;
  	    Carp::carp("Parameter to use lib must be directory, not file");
  	}
  	unshift(@INC, $path);
  	# Add any previous version directories we found at configure time
  	foreach my $incver (@inc_version_list)
  	{
  	    my $dir = "$path/$incver";
  	    unshift(@INC, $dir) if -d $dir;
  	}
  	# Put a corresponding archlib directory in front of $path if it
  	# looks like $path has an archlib directory below it.
  	my($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir)
  	    = _get_dirs($path);
  	unshift(@INC, $arch_dir)         if -d $arch_auto_dir;
  	unshift(@INC, $version_dir)      if -d $version_dir;
  	unshift(@INC, $version_arch_dir) if -d $version_arch_dir;
      }
  
      # remove trailing duplicates
      @INC = grep { ++$names{$_} == 1 } @INC;
      return;
  }
  
  
  sub unimport {
      shift;
  
      my %names;
      foreach my $path (@_) {
  	my($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir)
  	    = _get_dirs($path);
  	++$names{$path};
  	++$names{$arch_dir}         if -d $arch_auto_dir;
  	++$names{$version_dir}      if -d $version_dir;
  	++$names{$version_arch_dir} if -d $version_arch_dir;
      }
  
      # Remove ALL instances of each named directory.
      @INC = grep { !exists $names{$_} } @INC;
      return;
  }
  
  sub _get_dirs {
      my($dir) = @_;
      my($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir);
  
      $arch_auto_dir    = "$dir/$archname/auto";
      $arch_dir         = "$dir/$archname";
      $version_dir      = "$dir/$version";
      $version_arch_dir = "$dir/$version/$archname";
  
      return($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  lib - manipulate @INC at compile time
  
  =head1 SYNOPSIS
  
      use lib LIST;
  
      no lib LIST;
  
  =head1 DESCRIPTION
  
  This is a small simple module which simplifies the manipulation of @INC
  at compile time.
  
  It is typically used to add extra directories to perl's search path so
  that later C<use> or C<require> statements will find modules which are
  not located on perl's default search path.
  
  =head2 Adding directories to @INC
  
  The parameters to C<use lib> are added to the start of the perl search
  path. Saying
  
      use lib LIST;
  
  is I<almost> the same as saying
  
      BEGIN { unshift(@INC, LIST) }
  
  For each directory in LIST (called $dir here) the lib module also
  checks to see if a directory called $dir/$archname/auto exists.
  If so the $dir/$archname directory is assumed to be a corresponding
  architecture specific directory and is added to @INC in front of $dir.
  lib.pm also checks if directories called $dir/$version and $dir/$version/$archname
  exist and adds these directories to @INC.
  
  The current value of C<$archname> can be found with this command:
  
      perl -V:archname
  
  The corresponding command to get the current value of C<$version> is:
  
      perl -V:version
  
  To avoid memory leaks, all trailing duplicate entries in @INC are
  removed.
  
  =head2 Deleting directories from @INC
  
  You should normally only add directories to @INC.  If you need to
  delete directories from @INC take care to only delete those which you
  added yourself or which you are certain are not needed by other modules
  in your script.  Other modules may have added directories which they
  need for correct operation.
  
  The C<no lib> statement deletes all instances of each named directory
  from @INC.
  
  For each directory in LIST (called $dir here) the lib module also
  checks to see if a directory called $dir/$archname/auto exists.
  If so the $dir/$archname directory is assumed to be a corresponding
  architecture specific directory and is also deleted from @INC.
  
  =head2 Restoring original @INC
  
  When the lib module is first loaded it records the current value of @INC
  in an array C<@lib::ORIG_INC>. To restore @INC to that value you
  can say
  
      @INC = @lib::ORIG_INC;
  
  =head1 CAVEATS
  
  In order to keep lib.pm small and simple, it only works with Unix
  filepaths.  This doesn't mean it only works on Unix, but non-Unix
  users must first translate their file paths to Unix conventions.
  
      # VMS users wanting to put [.stuff.moo] into 
      # their @INC would write
      use lib 'stuff/moo';
  
  =head1 NOTES
  
  In the future, this module will likely use File::Spec for determining
  paths, as it does now for Mac OS (where Unix-style or Mac-style paths
  work, and Unix-style paths are converted properly to Mac-style paths
  before being added to @INC).
  
  If you try to add a file to @INC as follows:
  
    use lib 'this_is_a_file.txt';
  
  C<lib> will warn about this. The sole exceptions are files with the
  C<.par> extension which are intended to be used as libraries.
  
  =head1 SEE ALSO
  
  FindBin - optional module which deals with paths relative to the source file.
  
  PAR - optional module which can treat C<.par> files as Perl libraries.
  
  =head1 AUTHOR
  
  Tim Bunce, 2nd June 1995.
  
  C<lib> is maintained by the perl5-porters. Please direct
  any questions to the canonical mailing list. Anything that
  is applicable to the CPAN release can be sent to its maintainer,
  though.
  
  Maintainer: The Perl5-Porters <perl5-porters@perl.org>
  
  Maintainer of the CPAN release: Steffen Mueller <smueller@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This package has been part of the perl core since perl 5.001.
  It has been released separately to CPAN so older installations
  can benefit from bug fixes.
  
  This package has the same copyright and license as the perl core.
  
  =cut
LIB

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.234';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9917;
  $CLASS = 'version';
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  
  push @ISA, "version::vpp";
  local $^W;
  
  *version::qv = \&version::vpp::qv;
  *version::declare = \&version::vpp::declare;
  *version::_VERSION = \&version::vpp::_VERSION;
  *version::vcmp = \&version::vpp::vcmp;
  *version::new = \&version::vpp::new;
  *version::numify = \&version::vpp::numify;
  *version::normal = \&version::vpp::normal;
  if ($] >= 5.009000) {
      no strict 'refs';
      *version::stringify = \&version::vpp::stringify;
      *{'version::(""'} = \&version::vpp::stringify;
      *{'version::(<=>'} = \&version::vpp::vcmp;
      *{'version::(cmp'} = \&version::vpp::vcmp;
      *version::parse = \&version::vpp::parse;
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
          local $^W;
          *{$class.'::declare'} =  \&{$CLASS.'::declare'};
          *{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
          map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
          %args =
          (
              qv => 1,
              'UNIVERSAL::VERSION' => 1,
          );
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
          *{$callpkg.'::declare'} =
          sub {return $class->declare(shift) }
          unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
          *{$callpkg.'::qv'} =
          sub {return $class->qv(shift) }
          unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
          local $^W;
          *UNIVERSAL::VERSION
          = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
          *{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
          *{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
          unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
          *{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
          unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
  $VERSION = 0.9917;
  $CLASS = 'version::vpp';
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
  
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = 0.9917;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
VERSION_REGEX

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#
# Copyright (C) 2016- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.
#

use v5.009;
use strict;
use warnings;

# load module path, for bare, if needed
eval {use Cwd; use lib getcwd . "/builder-pack/fatlib";};

use VC3::Bag;
use VC3::Plan;
use VC3::Source;

package VC3::Builder;

use English qw/-mo_match_vars/;
use File::Basename qw/basename/;
use File::Spec::Functions qw/catfile rel2abs file_name_is_absolute/;
use Getopt::Long qw/GetOptions/;
use File::Path qw/make_path remove_tree/;
use Cwd;

use Carp qw( confess );
$SIG{TERM} = \&cleanup_signal_handler;
$SIG{INT}  = \&cleanup_signal_handler;
$SIG{ALRM} = \&cleanup_signal_handler;

# disable stdout buffering
select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

my $pwd            = getcwd();
my $vc3_root       = catfile(${pwd}, 'vc3-root');
my $vc3_distfiles  = catfile(${pwd}, 'vc3-distfiles');
my $vc3_user_home  = 'vc3-home';
my $vc3_repository = "http://download.virtualclusters.org/builder-files";

my $shell          = '/bin/sh';

my $unsafe_path    = qr/[\\"#\$&'`\n]/;

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;
my @cleanups;     # functions to call on exit.

# call main if running interactively
VC3::Builder::main();

END {
    local $?;

    for my $fn (@cleanups) {
        eval { $fn->() };
    }
}

sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] [-- command-and-args]

  command-and-args      defaults to $shell

  and options are:

  --require  <pkg>[:<m>[:<M>]]
                        Ensure that the package <pkg> is installed, optionally
                        specifying a minimum <m> and maximum <M> version. May
                        be specified several times.

  --require-os <name>   Ensure the operating system is <name>. May use a
                        container to fulfill the requirement. May be specified
                        several times, but only the last occurance is honored.
                        Use --list=os for a list of available operating
                        systems. 

  --mount /<x>          Ensure that path /<x> is exists inside the execution
                        environment. If using --require-os with a non-native
                        operating system, it is equivalent to --mount /<x>:/<x>
  --mount /<x>:/<y>     Mount path <x> into path <y> inside the execution
                        environment.  When executing in a native operating
                        system, <x> and <y> cannot be different paths.

  --database <f-d>      defaults to <internal> if available. <f-d> may be a
                        file, or a directory.  The unique file, or the files in
                        the directory should contain a JSON encoded object with
                        package recipes.  May be specified several times, with
                        latter package recipes overwriting previous ones. 


  Installation locations:
  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home> if <home> is a relative
                        path, otherwise to <home> if it is an absolute path.
                        Default is ${vc3_user_home}
  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}

  --repository <url>    Fallback site to fetch packages if needed.
                        Default is ${vc3_repository}

  --make-jobs <n>       Concurrent make jobs. Default is 4.


  Host system software handling:
  --sys package:version=<dir>
                        Assume <dir> to be the installation location of
                        package:version in the system.
                        (e.g. --sys python:2.7=/opt/local/)
  --no-sys=<package>    Do not use host system version of <package>. If
                        package is 'ALL', do not use system versions at
                        all. (Ignored if package specified with --sys.)


  Environment variables:
  --var NAME=VALUE      Add environment variable NAME with VALUE. 
                        May be specified several times.
  --revar PATTERN       All environment variables matching the regular
                        expression PATTERN are preserved.
                        (E.g. --revar "SGE_.*", --revar NAME is equivalent
                        to -var NAME=\$NAME)


  Running options:
  --force               Reinstall the packages named with --require and the
                        packages they depend on.

  --interactive         Treat command-and-args as an interactive terminal.

  --no-run              Set up environment, but do not execute any payload.

  --prestage            Download all files to --distfiles <dir> before
                        processing.

  --silent              Do not print any progress information.
  --silent=plan         Do not print dependency information.

  --timeout SECONDS     Terminate after SECONDS have elapased. 
                        If 0, then the timeout is not activated (default).


  Listing software available:
  --list                List packages available with their versions.
                        Software that may be detected as already installed
                        is marked as 'auto' version 
  --list=section        List packages available, classified by
                        sections.
  --list=all            List all the packages available, even vc3-internals.


  Output modes:
  --env-to <file>       Write environment script to <file>.{,env,payload}, but
                        do not execute command-and-args.
                        To execute command-and-args, run ./<file>.

  --dot <file>          Write a dependency graph of the requirements to <file>.


  Parallel batch build mode:
  --parallel <dir>      Write specifications for a parallel build to <dir>.
                        (Implies --prestage.)

  --parallel-mode <m>   One of local, condor, slurm, workqueue, sge, pbs,
                        torque, or amazon. (Default is local.)

  --parallel-max  <n>   Maximum number of parallel concurrent jobs.
                        (Default is 10.)


  Developers options:
  --debug               On a builder error, print the full back-trace. 
  --sh-on-error         On building error, run $shell on the partially-built
                        environment.


Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require-os redhat7 --require maker-example-ecoli-01
EOF

}

sub main {
    my @requires     = ();

    my %pkg_opts;

    my $require_os;
    my $no_os_switch = 0;

    my @mounts       = ();

    my $print_help   = 0;
    my $make_jobs    = 4;
    my $sh_on_error  = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $no_run             = 0;
    my $debug_run          = 0;
    my $interactive_run    = 0;
    my $force_rebuild      = 0;
    my $prestage           = 0;
    my $timeout;

    my $ignore_locks       = 0;

    my $env_to;
    my $dot_output;
    my $to_script;
    my $list_option;

    my $silent_option;

    my $parallel_dir;       
    my $parallel_mode;       
    my $parallel_max;       

    my $bosco_fix;

    my @extra_env_vars = ();
    my @databases   = ();
    my @re_vars     = ();
    my @sys_manual  = ();
    my @no_sys      = ();

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);
    
    VC3::Builder::remove_vc3_vars();
    VC3::Builder::fix_http_proxy_vars();

    my @saved_args = @ARGV;

    my $opt_result = GetOptions(
        "help"  => \$print_help,
        "debug" => \$debug_run,

        "silent:s" => sub { my ($o, $s) = @_; $silent_option = $s ? $s : 'ALL'},

        "database=s"  => \@databases,
        "require=s"   => \@requires, 

        "require-os=s" => \$require_os, 
        "no-os-switch" => \$no_os_switch, 

        "mount=s" => \@mounts,

        "option|o=s"     =>
            sub {
                my ($o, $s) = @_;
                my ($key, $value) = split('=', $s, 2);
                unless(defined $key and defined $value) {
                    die "\n--option should be of the form package=option\n";
                }
                $pkg_opts{$key} ||= [];
                push @{$pkg_opts{$key}}, $value;
            },

        "install=s" => \$vc3_root,
        "home=s"    => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,

        "sh-on-error"     => \$sh_on_error,

        "force"           => \$force_rebuild,
        "ignore-locks"    => \$ignore_locks,

        "env-to=s"    => \$env_to,
        "dot=s"       => \$dot_output,
        "to-script=s" => \$to_script,

        "dry-run"  => \$dry_run,
        "no-run"   => \$no_run,
        "prestage" => \$prestage,
        "list:s"   => \$list_option,

        "bosco-workaround" => \$bosco_fix,

        "interactive" => \$interactive_run,

        "timeout=i"   => \$timeout,

        "sys=s"    => \@sys_manual,
        "no-sys=s" => \@no_sys,
        "var=s"    => \@extra_env_vars,
        "revar=s"  => \@re_vars,

        "parallel=s"  => \$parallel_dir,
        "parallel-mode=s" => \$parallel_mode,
        "parallel-max=i"  => \$parallel_max,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used,
    );

    unless($opt_result) {
        die "\nTerminating because of invalid command line arguments.\n";
    }

    if($debug_run) {
        $SIG{__DIE__}  =  \&confess;
    }

    unshift @databases, '<internal>';

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        push @no_sys, 'ALL';
        $dry_run = 1;
    }

    if(defined $to_script) {
        $dry_run = 1;
    }

    if(defined $list_option) {
        $silent_option = 'ALL';
        $dry_run = 1;
    }

    if(defined $timeout) {
        if($timeout < 0) {
            die 'timeout cannot be less than 0';
        } else {
            alarm $timeout;
        }
    }

    # split mounts
    my $mount_map = get_mount_map(@mounts);

    # set up parallel mode
    if(defined $parallel_dir) {
        push @no_sys, 'ALL';

        $parallel_mode ||= 'local';
        $parallel_max  ||= 10;

        if(@ARGV) {
            die "Cannot specify command-and-args with --parallel build mode.\n";
        }
    } else {
        if(defined($parallel_mode) or defined($parallel_max)) {
            die "Cannot use --parallel-mode or --parallel-max options without specifying --parallel\n";
        }
    }

    push @extra_env_vars, "MAKEFLAGS=-j${make_jobs}";
    push @extra_env_vars, "VC3_COMMAND_LINE=" . rel2abs(join(" ", $original_command));

    # honor paths from enclosing builder, if any.
    unshift @re_vars, 'VC3_.*';

    for my $pat (@re_vars) {
        for my $name (keys %ENV) {
            next unless $name =~ /$pat/;
            push @extra_env_vars, "$name='" . $ENV{$name} . "'";
        }
    }

    if($bosco_fix) {
        #remove this case once we figure out how to give installation paths to
        #bosco
        $vc3_root = bosco_fix_path($vc3_root);
    } else {
        is_safe_path($vc3_root);
    }

    # set default payload
    my @command_and_args;

    if(defined($parallel_dir)) {
        @command_and_args = ("sh -c 'cd $parallel_dir && ./build -T$parallel_mode -j$parallel_max -J$parallel_max'");
    } elsif(@ARGV) {
        @command_and_args = @ARGV;
    } else {
        @command_and_args = ($shell,);
        $interactive_run = 1;
    }

    my $bag = VC3::Bag->new(
        root       => $vc3_root,
        home       => $vc3_user_home,
        distfiles  => $vc3_distfiles,
        repository => $vc3_repository,
        shell      => $shell,
        dry_run    => $dry_run,
        on_terminal=> $interactive_run,
        silent     => $silent_option,
        databases  => \@databases,
        pkg_opts   => \%pkg_opts,
        sys_manual => \@sys_manual,
        no_sys     => \@no_sys,
        env_vars   => \@extra_env_vars);

    push @cleanups, sub { $bag->cleanup() };

    if(defined $list_option) {
        $bag->list_packages($list_option);
        exit(0);
    }

    if($require_os and not $no_os_switch) {
        # following call may produce an exec to a container.  original command line
        # is executed, dropping --require-os.
        my $exe = $0 eq '-e' ? $^X : $0;
        
        switch_os($bag, $require_os, $exe, \@saved_args, \@ARGV, $mount_map); # ARGV is original payload now.
    } else {
        unless(check_local_mounts($mount_map)) {
            die "Some mount points do not exists locally and no mounting can be performed natively.\n";
        }
    }

    unshift @requires, 'vc3-builder-hands';

    $bag->set_plan_for(@requires);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
    }

    if(defined $to_script) {
        $bag->plan->to_script($to_script);
    }

    if($bag->dry_run) {
        exit 0;
    }

    $bag->check_manual_requirements();

    if(defined $parallel_dir) {
        $bag->to_parallel($parallel_dir, $make_jobs);
        $bag->check_manual_requirements();
 
        $bag->set_plan_for('cctools-statics');
        $ignore_locks = 1;
        $prestage     = 1;
    }

    if($prestage) {
        $bag->plan->prestage();
    }

    $bag->execute_plan($sh_on_error, $force_rebuild, $ignore_locks);
    
    # run the payload
    my $exit_code;
    if($no_run) {
        $exit_code = 0;
    } elsif($env_to) {
        $bag->preserve_profile(1);
        $bag->set_profile($env_to, @command_and_args);
        $exit_code = 0;
    } elsif(defined $parallel_dir) {
        $exit_code = $bag->execute(@command_and_args);
        if($exit_code) {
            warn "Parallel build mode failed.\n";
        }
    } else {
        $exit_code = $bag->execute(@command_and_args);
    }

    exit $exit_code;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink catfile($vc3_distfiles, $file);

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = catfile($vc3_distfiles,  $file);

    # dummy calls to trigger the use of the http module.
    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);

    my @modules = grep { /\.pm$/ } keys %INC;

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # add modules that %INC sometimes does not find:
    my @manuals = 
    qw(
        encoding
        strict
        Cwd
        Digest::Perl::MD5
        English 
        Getopt::Long
        LockFile::Simple
        PerlIO
        Tie::RefHash );

    @modules = (@manuals, @modules);


    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

sub switch_os {
    my ($bag, $os, $exe, $all_args, $payload_args, $mount_map) = @_;

    # chop payload args from all args to only get builder args.
    my $builder_args  = [@{$all_args}];
    my $payload_count = scalar @{$payload_args};
    if($payload_count > 0) {
        splice @{$builder_args}, -1 * $payload_count;
    }
    splice @{$builder_args}, -1, 1 if $builder_args->[-1] eq '--';

    my ($name, $min, $max) = VC3::Plan->parse_requirement($os);

    my $pkg = $bag->{recipes}{op_sys}{$name};
    unless($pkg) {
        die "I don't know anything about operating system '$name'.\n";
    }

    # try to satisfy the os requirement
    for my $w (@{$pkg->widgets}) {

        unless($w->available) {
            next;
        }

        my $exit_status = -1;
        eval { $exit_status = $w->source->check_prerequisites() };

        if($exit_status) {
            next;
        }

        my $fmt = sprintf("OS %%-14s %12s %s:%s for %s", $w->source->type, $w->package->name, $w->version, $os);
        $bag->say(sprintf($fmt, 'trying:'));

        if($min and $min > $w->version) {
            $bag->say(sprintf($fmt, 'fail min:'));
            next;
        }

        if($max and $max < $w->version) {
            $bag->say(sprintf($fmt, 'fail max:'));
            next;
        }

        # if generic, simply check mount points.
        if($w->source->type eq 'os-native') {
            if(check_local_mounts($mount_map)) {
                return;
            } else {
                $bag->say(sprintf($fmt, 'fail mounts:'));
                next;
            }
        }

        eval {
            if($w->source) {
                $w->source->prepare_recipe_sandbox($exe, $builder_args, $payload_args, $mount_map);
            }

            unless($w->wrapper) {
                $bag->say(sprintf($fmt, 'fail wrapper:'));
                die "\n";
                
            }

            system @{$w->wrapper};
        };

        if($@) {
            $bag->say(sprintf($fmt, 'failed'));
            next;
        } else {
            # payload executed, so we end this builder.
            exit(0);
        }
    }

    die "Could not satisfy operating system requirement '$os'.\n";
}

sub get_mount_map {
    my (@mounts) = @_;

    my %mount_map;
    for my $spec (@mounts) {
        $spec =~ m/^(?<from>[^:]+)(:(?<to>.*))?/;

        unless($+{from}) {
            die "Malformed mount specification: '$spec'.\n";
        }

        $mount_map{$+{from}} = $+{to} || $+{from}; 

        unless(file_name_is_absolute($+{from})) {
            die "Path '$+{from}' is not absolute.\n";
        }

        unless(file_name_is_absolute($mount_map{$+{from}})) {
            die "Path '$mount_map{$+{from}}' is not absolute.\n";
        }
    }
    
    return \%mount_map;
}

sub check_local_mounts {
    my ($mount_map) = @_;

    my $all_present = 1;
    for my $from (keys %{$mount_map}) {
        my $to = $mount_map->{$from};

        if($from ne $to) {
            $all_present = 0;
            print("Mount source '$from' and target '$to' are different.\n");
        } elsif(! -d $to) {
            $all_present = 0;
            print("Mount target '$to' does not exist locally.\n");
        }
    }

    return $all_present;
}

sub is_safe_path {
    my ($root) = @_;

    my @chars = ($root =~ m/(${unsafe_path})/g);
    if(@chars) {
        my %uniq = map { ( $_ => 1 ) } @chars;

        if($uniq{"\n"}) {
            delete $uniq{"\n"};
            $uniq{'\n'} = 1;
        }

        die 'Terminating because installation path contains unsafe characters: ' . join(' ', keys %uniq) . "\n";
    }
}

sub bosco_fix_path {
    #remove this function once we figure out how to give installation paths to bosco
    #
    my ($original_root) = @_;

    $original_root = rel2abs($original_root);

    my $bosco_infix = qr^bosco/sandbox/[[:xdigit:]]+/[[:xdigit:]]+/^;

    eval { is_safe_path($original_root); };
    my $msg = $@;

    unless($msg) {
        # path does not need any fixes.
        return $original_root;
    }

    unless($original_root =~ m^(?<pre>.*?${bosco_infix})(?<post>.*)^) {
        die "This does not look like a bosco path with a sandbox.\n$msg\n";
    }

    my ($pre, $post) = ($+{pre}, $+{post});

    if($pre =~ m/${unsafe_path}/) {
        die "This bosco path cannot be fixed inside the sandbox.\n$msg\n";
    }

    $post =~ s^${unsafe_path}^_^g;
    $post =~ s^/^_^g;

    my $new_root = catfile($pre, $post); 

    warn "Fixing bosco path to '$new_root'\n";

    push @cleanups, sub { remove_tree($new_root) };
    make_path($new_root);

    my @files = (glob("${original_root}/*"), glob("${original_root}/.*"));

    for my $file (@files) {
        my $base = basename($file);

        next if $base eq '.';
        next if $base eq '..';

        symlink $file, catfile(${new_root}, $base);

        warn "symlinking $file ${new_root}/$base\n";
    }

    return $new_root;
}

sub select_sleep {
    my ($seconds) = @_;

    select(undef, undef, undef, $seconds);
}

sub cleanup_signal_handler {
    my ($signal) = @_;

    if($signal) {
        warn("Got signal!: $signal\n");

        if($signal eq 'ALRM') {
            warn("Timeout!\n");
        }

        exit 128;
    }
}

sub fix_http_proxy_vars {
    for my $var (qw(http_proxy HTTP_PROXY)) {
        my $val = $ENV{$var};

        if($val) {
            if($val =~ /^:?;?DIRECT$/) {
                delete $ENV{$var};
                next;
            }

            if($val !~ m#^https?://#) { 
                $ENV{$var} = "http://$val";
            }
        }
    }
}

sub remove_vc3_vars() {
    for my $var (keys %ENV) {
        if($var =~ '^VC3_') {
            delete $ENV{$var};
        }
    }
}



package VC3::Builder;
__DATA__
[

{
    "noop":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1
            }
        ]
    },

    "vc3-builder-hands":{
        "versions":[
            {
                "version":"v1.0.0",
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "echo 'hello builder'"
                    ],
                    "dependencies":{
                        "tar":[
                            "v1.0"
                        ],
                        "gzip":[
                            "v1.0"
                        ],
                        "make":[
                            "v3.82.0"
                        ],
                        "sed":[
                            "v4.2.0"
                        ],
                        "pkg-config":[
                            "v0.23.0"
                        ],
                        "which":[
                            "v1.00.0"
                        ]
                    }
                }
            }
        ]
    },

    "static-get":{
        "versions":[
            {
                "version":"v1.0.0",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "static-get"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_ARCH} = \"x86_64\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp -L static-get ${VC3_PREFIX}/bin",
                        "chmod 755 ${VC3_PREFIX}/bin/static-get"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "pax":{
        "tags":["file utilities"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2016.11.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "pax-20161104.tar.gz"
                    ],
                    "recipe":[
                        "${CC} -O2 -o pax  -DPAX_SAFE_PATH=\\\"/bin\\\" *.c",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp pax ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "sharutils":{
        "tags":["file utilities"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v4.15.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "sharutils-4.15.tar.gz"
                    ]
                },
                "dependencies":{
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "r-lang":{
        "tags":["programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.5.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "R-3.5.1.tar.gz"
                    ]
                },
                "dependencies":{
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "gcc":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gcc"
                }
            },
            {
                "version":"v4.6.1",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "gcc-4.6.1-2.tar.gz"
                    ],
                    "recipe":[
                        ": from static-get",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf gcc-4.6.1-2.tar.gz"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"C_INCLUDE_PATH",
                        "value":"lib/gcc/i586-linux-uclibc/4.6.1/include"
                    }
                ]
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ],
        "environment-variables":[
            {
                "name":"CC",
                "value":"gcc",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "gcc-cplusplus":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"g++"
                }
            },
            {
                "version":"5.3.0",
                "source":{
                    "type":"system",
                    "prerequisites":[
                        "case \"${VC3_MACHINE_TARGET}\" in x86_64/redhat7*);; *) exit 1;; esac",
                        "stat /cvmfs/cms.cern.ch/slc7_amd64_gcc530/external/gcc/5.3.0"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /cvmfs/cms.cern.ch/slc7_amd64_gcc530/external/gcc/5.3.0\""
                    ]
                },
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            },
            {
                "version":"5.3.0",
                "source":{
                    "type":"system",
                    "prerequisites":[
                        "case \"${VC3_MACHINE_TARGET}\" in x86_64/redhat6*);; *) exit 1;; esac",
                        "stat /cvmfs/cms.cern.ch/slc6_amd64_gcc530/external/gcc/5.3.0"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /cvmfs/cms.cern.ch/slc6_amd64_gcc530/external/gcc/5.3.0\""
                    ]
                },
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ],
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            },
            {
                "name":"CC",
                "value":"gcc",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"CXX",
                "value":"g++",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "gcc-fortran":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gfortran"
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "make":{
        "tags":["compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"make"
                }
            },
            {
                "version":"v3.82",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "make-x86_64-3.82.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "sed":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"sed"
                }
            },
            {
                "version":"v4.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "sed-x86_64-4.2.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "grep":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"grep"
                },
                "version":"v2.6.3",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "grep-x86_64-2.6.3-2.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "gawk":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gawk"
                },
                "version":"v4.1.1",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "gawk-x86_64-4.1.1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "which":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"which"
                },
                "version":"v2.20.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "which-x86_64-2.20-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "coreutils":{
        "versions":[
            {
                "version":"v7.6.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "coreutils-x86_64-7.6-5.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "tar":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"tar"
                }
            },
            {
                "version":"v1.23.0",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "tar-1.23"
                    ],
                    "recipe":[
                        ": from static-get",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp -L tar-1.23 ${VC3_PREFIX}/bin/tar",
                        "chmod 755 ${VC3_PREFIX}/bin/tar"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "gzip":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gzip"
                }
            },
            {
                "version":"v1.4.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "gzip-x86_64-1.4-1.tar"
                    ]
                },
                "dependencies":{
                    "tar":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "bzip2":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"bzip2"
                }
            },
            {
                "version":"v1.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "bzip2-bin-1.0.6-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "xz":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"xz"
                }
            },
            {
                "version":"v5.0.5",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "xz-x86_64-5.0.5.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "pkg-config":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"pkg-config"
                }
            },
            {
                "version":"v0.23",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "pkg-config-x86_64-0.23-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v0.23",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "pkg-config-0.23-1.tar.gz"
                    ],
                    "recipe":[
                        ": from static-get",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf pkg-config-0.23-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "icecube-argonne-demo":{
        "tags":["demos"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "icecube-argonne-demo-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/icecube-argonne-demo-01",
                        "tar -C ${VC3_INSTALL_USER_HOME}/icecube-argonne-demo-01 --strip-components=1 -xpf icecube-argonne-demo-01.tar.gz"
                    ]
                },
                "dependencies":{
                    "icecube-environment":[
                        "v1.0"
                    ],
                    "python":[
                        "v2.6"
                    ]
                }
            }
        ]
    },

    "icecube-environment":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "prologue": [
                    "eval $(/cvmfs/icecube.opensciencegrid.org/py2-v3.0.1/setup.sh)"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ],
                    "python":[
                        "v2.6"
                    ]
                }
            }
        ]
    },

    "oasis-environment":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "prologue": [
                    "source /cvmfs/oasis.opensciencegrid.org/osg/modules/lmod/current/init/bash"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "atlas-local-root-base-environment":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "prologue": [
                    "export ATLAS_LOCAL_ROOT_BASE=/cvmfs/atlas.cern.ch/repo/ATLASLocalRootBase",
                    "source ${ATLAS_LOCAL_ROOT_BASE}/user/atlasLocalSetup.sh"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "cmssw-environment":{
        "tags":["environments"],
        "versions":[
            {
                "version":"1.0",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "if [ -z $VC3_OPTIONS_CMSSW_ENVIRONMENT ]; then",
                        "cat <<EOF",
                        "    No CMSSW environment defined. For example:",
                        "    vc3-builder -o cmssw-environment=CMSSW_9_3_0_pre2 ...",
                        "EOF",
                        "exit 1",
                        "fi"
                    ]
                },
                "prologue":[
                    ". /cvmfs/cms.cern.ch/cmsset_default.sh",
                    "if [ ! -d ${HOME}/${VC3_OPTIONS_CMSSW_ENVIRONMENT} ]; then",
                    "   cd ${HOME}",
                    "   vc3_cmsrel=$(alias cmsrel | sed -r -e \"s/.*='(.*)'/\\1/\")",
                    "   ${vc3_cmsrel} ${VC3_OPTIONS_CMSSW_ENVIRONMENT}",
                    "fi",
                    "if [ -d ${HOME}/${VC3_OPTIONS_CMSSW_ENVIRONMENT} ]; then",
                    "    cd ${HOME}/${VC3_OPTIONS_CMSSW_ENVIRONMENT}",
                    "    vc3_cmsenv=$(alias cmsenv | sed -r -e \"s/.*='(.*)'/\\1/\")",
                    "    ${vc3_cmsenv} ${VC3_OPTIONS_CMSSW_ENVIRONMENT}",
                    "    cd ${HOME}",
                    "fi"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "vc3-glidein":{
        "versions": [
            {
                "version":"v1.1.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "vc3-glidein-v1.1.4.tar.gz"
                    ],
                    "recipe":[
                        "chmod 755 vc3-glidein",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv vc3-glidein ${VC3_PREFIX}/bin"
                    ]
                }
            },
            {
                "version":"v1.0",
                "source":{
                    "type":"generic",
                    "mirrors":[
                        "https://raw.githubusercontent.com/vc3-project/vc3-glidein/master"
                    ],
                    "files":[
                        "vc3-glidein"
                    ],
                    "recipe":[
                        "chmod 755 vc3-glidein",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv vc3-glidein ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "dependencies":{
            "python":[
                "v2.6"
            ]
        },
        "environment-autovars":[
            "PATH"
        ]
    },

    "osg-advertise": {
        "tags":["environments"],
        "versions": [
            {
                "version": "v0.0.1",
                "source":{ 
                    "type":"generic",
                    "mirrors":[
                        "https://raw.githubusercontent.com/opensciencegrid/osg-flock/master/node-check"
                    ],
                    "files":[
                        "osgvo-node-advertise"
                    ],
                    "recipe":[
                        "chmod 755 osgvo-node-advertise",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv osgvo-node-advertise ${VC3_PREFIX}/bin"
                    ]
                }
            },
            {
                "version": "v0.0.2",
                "source": {
                    "type":"generic",
                    "mirrors":[
                        "http://stash.ci-connect.net/~briedel/"
                    ],
                    "files":[
                        "osg-env"
                    ],
                    "recipe":[
                        "chmod 755 osg-env",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv osg-env ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    

    "osg-advertise-wrapper": {
        "tags": ["environments"],
        "show-in-list": 1,
        "versions": [
            {
                "version": "v0.0.1",
                "wrapper": [
                    "osgvo-node-advertise"
                ],
                "dependencies": {
                    "osg-advertise": [
                        "v0.0.1"
                    ]
                }
            },
            {
                "version": "v0.0.2",
                "prologue": [
                    "source ${VC3_ROOT_OSG_ADVERTISE}/bin/osg-env"
                ],
                "dependencies": {
                    "osg-advertise": [
                        "v0.0.2"
                    ]
                }
            }
        ]
    },

    "cvmfs-parrot-libcvmfs":{
        "versions":[
            {
                "version":"v2.4.0",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "dependencies":{
                        "parrot-wrapper":[
                            "v6.0.0"
                        ]
                    }
                }
            }
        ]
    },

    "cvmfs":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(cvmfs2 -V | sed -r -e 's/CernVM-FS version\\s+([0-9]+\\.[0-9]+\\.[0-9]+)(\\.[0-9])?/\\1/')" 
                    ],
                    "prerequisites":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /\""
                    ]
                },
                "environment-variables":[
                    {
                        "name":"VC3_PARROT_EXTRA_OPTIONS",
                        "value":"--disable-service=cvmfs",
                        "absolute":1,
                        "clobber":1
                    }
                ]
            },
            {
                "version":"v2.4.0",
                "dependencies":{
                    "cvmfs-parrot-libcvmfs":[
                        "v2.4.0"
                    ]
                }
            }
        ]
    },

    "parrot-wrapper":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.0.6",
                "wrapper":[
                    "parrot_run",
                    "--dynamic-mounts",
                    "-p", "\"${PARROT_HTTP_PROXY}\"",
                    "--cvmfs-repo-switching",
                    "$(echo ${VC3_PARROT_EXTRA_OPTIONS} | sed -e 's/:/ /g')",
                    "{}"
                ],
                "dependencies":{
                    "cctools":[
                        "v7.0.6"
                    ]
                }
            }
        ]
    },

    "parrot-static":{
        "versions":[
            {
                "version":"v7.0.6",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cctools-7.0.6-source.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --without-system-sand --without-system-allpairs --without-system-wavefront --without-system-makeflow --without-system-umbrella --without-system-prune --without-system-resource_monitor --without-system-doc --with-zlib-path ${VC3_ROOT_ZLIB} --with-cvmfs-path ${VC3_ROOT_LIBCVMFS} --with-uuid-path ${VC3_ROOT_UUID} --with-openssl-path ${VC3_ROOT_OPENSSL} --with-fuse-path ${VC3_ROOT_FUSE} --with-globus-path no --with-irods-path no --with-mysql-path no --with-xrootd-path no",
                        "make",
                        "cd parrot/src",
                        "make parrot_cvmfs_static_run",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp parrot_cvmfs_static_run ${VC3_PREFIX}/bin"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.2"
                        ],
                        "libcvmfs":[
                            "v2.2"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "uuid":[
                            "v1.0"
                        ],
                        "gcc-cplusplus":[
                            "v4.4"
                        ],
                        "c-build-environment++":[
                            "v1.0"
                        ]
                    }
                }
            }
        ]
    },

    "cctools-catalog-server":{
        "versions":[
            {
                "version":"v6.0.0",
                "dependencies":{
                    "cctools-statics":[
                        "v0.0.1"
                    ]
                }
            },
            {
                "version":"v6.0.0",
                "dependencies":{
                    "cctools":[
                        "v6.0.0"
                    ]
                }
            }
        ]
    },

    "cctools-binary":{
        "versions":[
            {
                "version":"v7.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat7",
                    "files":[
                        "cctools-7.0.6-x86_64-redhat7.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-7.0.6-x86_64-redhat7.tar.gz",

                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.16"
                        ],
                        "python":[
                            "v2.7.0"
                        ]
                    }
                }
            },
            {
                "version":"v7.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat6",
                    "files":[
                        "cctools-7.0.6-x86_64-redhat6.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-7.0.6-x86_64-redhat6.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.10.0"
                        ],
                        "python":[
                            "v2.6.0"
                        ]
                    }
                }
            }
        ],
        "dependencies":{
            "zlib":[
                "v1.2"
            ]
        },
        "environment-autovars":[
            "PATH", "PERL5LIB"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "cctools-source":{
        "versions":[
            {
                "version":"v7.0.6",
                "source":{
                    "type":"configure",
                    "files":[
                        "cctools-7.0.6-source.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "options":"--without-system-umbrella --without-system-prune --without-system-doc --with-swig-path ${VC3_ROOT_SWIG} --with-python-path ${VC3_ROOT_PYTHON} --with-perl-path ${VC3_ROOT_PERL} --with-zlib-path ${VC3_ROOT_ZLIB} --with-cvmfs-path ${VC3_ROOT_LIBCVMFS} --with-uuid-path ${VC3_ROOT_UUID} --with-openssl-path ${VC3_ROOT_OPENSSL} --with-fuse-path ${VC3_ROOT_FUSE} --with-globus-path no --with-irods-path no --with-mysql-path no --with-xrootd-path no",
                    "postface":[
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "swig":[
                            "v3.0"
                        ],
                        "python":[
                            "v2.6"
                        ],
                        "perl":[
                            "v5.10"
                        ],
                        "libcvmfs":[
                            "v2.2"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "uuid":[
                            "v1.0"
                        ],
                        "gcc-cplusplus":[
                            "v4.4"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "dependencies":{
            "zlib":[
                "v1.2"
            ]
        },
        "environment-autovars":[
            "PATH", "PERL5LIB"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "cctools":{
        "tags":["workflow tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.0.6",
                "dependencies":{
                    "cctools-binary":[
                        "v7.0.6"
                    ]
                }
            },
            {
                "version":"v7.0.6",
                "dependencies":{
                    "cctools-source":[
                        "v7.0.6"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "cctools-unstable":{
        "tags":["workflow tools"],
        "show-in-list":1,
        "phony":1,
        "versions":[
            {
                "version":"v999.999.999",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat7",
                    "recipe":[
                        "wget http://ccl.cse.nd.edu/software/autobuild/commit/most-recent/cctools-current-x86_64-redhat7.tar.gz",
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-*-redhat7.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.16"
                        ],
                        "python":[
                            "v2.7.0"
                        ],
                        "wget":[
                            "v1.0"
                        ]
                    }
                }
            },
            {
                "version":"v999.999.999",
                "source": {
                    "type":"binary",
                    "native":"x86_64/redhat6",
                    "recipe":[
                        "wget http://ccl.cse.nd.edu/software/autobuild/commit/most-recent/cctools-current-x86_64-redhat6.tar.gz",
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-*-redhat6.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.10.0"
                        ],
                        "python":[
                            "v2.6.0"
                        ]
                    }
                }
            }
        ],
        "dependencies":{
            "zlib":[
                "v1.2"
            ],
            "wget":[
                "v1.0"
            ]
        },
        "environment-autovars":[
            "PATH", "PERL5LIB"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "swig":{
        "tags":["compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.0.12",
                "source":{
                    "type":"configure",
                    "files":[
                        "swig-3.0.12.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib",
                    "dependencies":{
                        "pcre":[
                            "v8.34"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "e2fsprogs":{
        "tags":["file systems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v1.44.5",
                "source":{
                    "type":"configure",
                    "files":[
                        "e2fsprogs-1.44.5.tar.gz"
                    ],
                    "preface":[
                        "export LN='/bin/cp -pR'"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-symlink-install",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "patch":{
        "tags":["file utilities", "compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"patch"
                }
            },
            {
                "version":"v2.7.5",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "patch-x86_64-2.7.5.tar.gz"
                    ]
                }
            },
            {
                "version":"v2.7.5",
                "source":{
                    "type":"configure",
                    "files":[
                        "patch-2.7.5.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "cmake":{
        "tags":["compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"cmake",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(cmake --version | sed -r -e 's/cmake version ([0-9]+\\.[0-9]+)(\\.[0-9])?/\\1/')" 
                    ]
                }
            },
            {
                "version":"v3.10.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "cmake-3.10.2-Linux-x86_64.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cmake-3.10.2-Linux-x86_64.tar.gz"
                    ]
                }
            },
            {
                "version":"v3.5.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cmake-3.5.2.tar.gz"
                    ],
                    "recipe":[
                        "prefix=$(echo ${VC3_PREFIX} | sed -e 's/#/_/g')",
                        "./bootstrap --prefix=${prefix}",
                        ": ./bootstrap --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "libcvmfs":{
        "versions":[
            {
                "version":"v2.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cvmfs-70dfa0d62.tar.gz"
                    ],
                    "recipe":[
                        "export CPLUS_INCLUDE_PATH=${VC3_ROOT_UUID}/include",                                           
                        "mkdir -p build",
                        "cd build",
                        ": set NO_INTERNET to stop parcparser tests",
                        "export NO_INTERNET=1",
                        ": to force openssl static, nullify PKG_CONFIG_PATH",
                        ": export PKG_CONFIG_PATH=invalid",
                        "sed -i '305ifind_package (FUSE REQUIRED)' ../CMakeLists.txt",
                        "sed -i '306iset (INCLUDE_DIRECTORIES ${INCLUDE_DIRECTORIES} ${FUSE_INCLUDE_DIR} ${ATTR_INCLUDE_DIR})' ../CMakeLists.txt",
                        "cmake -Wno-dev -DINSTALL_MOUNT_SCRIPTS=OFF -DBUILD_SERVER:BOOL=OFF -DBUILD_CVMFS:BOOL=OFF -DBUILD_LIBCVMFS:BOOL=ON -DINSTALL_BASH_COMPLETION:BOOL=OFF -DUUID_LIBRARY=${VC3_ROOT_UUID}/lib/libuuid.a -DUUID_INCLUDE_DIR:PATH=${VC3_ROOT_UUID}/include -DZLIB_LIBRARY=${VC3_ROOT_ZLIB}/lib/libz.a -DZLIB_INCLUDE_DIR:PATH=${VC3_ROOT_ZLIB}/include -DOPENSSL_ROOT_DIR:PATH=${VC3_ROOT_OPENSSL} -DOPENSSL_INCLUDE_DIR:PATH=${VC3_ROOT_OPENSSL}/include -DOPENSSL_CRYPTO_LIBRARY:PATH=${VC3_ROOT_OPENSSL}/lib/libcrypto.a -DOPENSSL_SSL_LIBRARY:PATH=${VC3_ROOT_OPENSSL}/lib/libssl.a -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DFUSE_INCLUDE_DIR:PATH=${VC3_ROOT_FUSE}/include -DFUSE_LIBRARY=${VC3_ROOT_FUSE}/lib/libfuse.a -DATTR_INCLUDE_DIR:PATH=${VC3_ROOT_ATTR}/include .. -DATTR_LIBRARY=${VC3_ROOT_ATTR}/lib/libattr.a",
                        "cd cvmfs",
                        "make libcvmfs",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "mkdir -p ${VC3_PREFIX}/include",
                        "cp libcvmfs.a ${VC3_PREFIX}/lib",
                        "cp ../../cvmfs/libcvmfs*.h ${VC3_PREFIX}/include"
                    ],
                    "dependencies":{
                        "uuid":[
                            "v1.0"
                        ],
                        "zlib":[
                            "v1.2"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "cmake":[
                            "v3.1"
                        ],
                        "patch":[
                            "v2.0"
                        ],
                        "attr":[
                            "v2.4"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "python":[
                            "v2.6"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib64"
                    }
                ]
            }
        ]
    },

    "uuid":{
        "versions":[
            {
                "version":"v1.0.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "libuuid-1.0.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "openssl":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"openssl",
                    "auto-version":[
                        "pkg-config openssl --exists",
                        "echo VC3_VERSION_SYSTEM: $(openssl version -v | sed -r -e 's/OpenSSL (([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ]
                }
            },
            {
                "version":"v1.0.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "openssl-1.0.2h.tar.gz"
                    ],
                    "recipe":[
                        ": ./config shared -fPIC --prefix=${VC3_PREFIX} --libdir=lib zlib-dynamic -Wl,-rpath=${VC3_PREFIX}/lib",
                        ": ./config -fPIC --prefix=${VC3_PREFIX} --libdir=lib zlib no-shared",
                        "./config -fPIC --prefix=${VC3_PREFIX} --libdir=lib -D_GNU_SOURCE -DOPENSSL_NO_HEARTBEAT -Wl,-rpath=${VC3_PREFIX}/lib shared no-zlib no-comp no-weak-ssl-ciphers",
                        "make depend",
                        "make build_all",
                        "make install_sw"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "libssh2":{
        "versions":[
            {
                "version":"v1.8.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "libssh2-1.8.0.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--with-libssl-prefix=${VC3_ROOT_OPENSSL} --enable-static=yes --enable-shared=yes"
                },
                "dependencies":{
                    "openssl":[
                        "v1.0.2"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "gss":{
        "versions":[
            {
                "version":"v1.0.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "gss-1.0.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--enable-static=yes --enable-shared=no",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "curl":{
        "tags":["data transfer tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.53.1",
                "source":{
                    "type":"tarball",
                    "files":[
                        "curl-7.53.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export LIBS='-ldl -lz'",
                        "./configure --prefix=${VC3_PREFIX} --enable-static=yes --enable-shared=yes --enable-http --enable-ftp --enable-file --enable-proxy --enable-tftp --disable-ldap --disable-ldaps --with-ssl=${VC3_ROOT_OPENSSL} --with-libssh2=${VC3_ROOT_LIBSSH2} --with-zlib=${VC3_ROOT_ZLIB}  --with-gssapi=${VC3_ROOT_GSS}/bin --with-gssapi-libs=${VC3_ROOT_GSS}/lib",
                        "make",
                        "make install"
                    ]
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "openssl":[
                        "v1.0.2"
                    ],
                    "gss":[
                        "v1.0.3"
                    ],
                    "libssh2":[
                        "v1.8.0"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "wget":{
        "tags":["data transfer tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"wget"
                }
            },
            {
                "version":"v1.81",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "wget-1.18-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v1.19.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "wget-1.19.4.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --with-zlib --with-ssl=openssl --with-libssl-prefix=${VC3_ROOT_OPENSSL} --with-libuuid",
                        "make",
                        "make install"
                    ]
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "openssl":[
                        "v1.0.2"
                    ],
                    "uuid":[
                        "v1.0"
                    ],
                    "libssh2":[
                        "v1.8.0"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "git":{
        "tags":["source version control", "compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"git",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(git --version | sed -r -e 's/git version (([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ]
                }
            },
            {
                "version":"v2.7.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "git-x86_64-2.7.2-2.tar.gz"
                    ]
                },
                "environment-autovars":[
                    "PATH"
                    ]
            },
            {
                "version":"v2.12.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "git-2.12.0.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--with-openssl=${VC3_ROOT_OPENSSL} --with-curl=${VC3_ROOT_CURL} --with-zlib=${VC3_ROOT_ZLIB} --with-perl=${VC3_ROOT_PERL}/bin/perl --with-python=${VC3_ROOT_PYTHON}/bin/python --without-tcltk"
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "openssl":[
                        "v1.0.2"
                    ],
                    "gss":[
                        "v1.0.3"
                    ],
                    "curl":[
                        "v7.53.1"
                    ],
                    "libssh2":[
                        "v1.8.0"
                    ],
                    "perl":[
                        "v5.24"
                    ],
                    "python":[
                        "v2.7"
                    ],
                    "perl-extutils-makemaker":[
                        "v7.24.0"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "condor-personal":{
        "versions":[
            {
                "version":"v8.6.0",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        ": run as condor_master -f",
                        "cd ${VC3_ROOT_CONDOR}",
                        "[ -f etc/condor_config ] && rm etc/condor_config",
                        "if [ ! -f ${VC3_ROOT_CONDOR}/etc/condor_config.local ]; then",
                        "    echo SCHEDD_NAME = $$.$(hostname)    >> ${VC3_ROOT_CONDOR}/condor_config.local",
                        "    echo ALLOW_WRITE = \\*               >> ${VC3_ROOT_CONDOR}/condor_config.local",
                        "fi",
                        "./condor_install --make-personal-condor"
                    ]
                }
            }
        ],
        "dependencies":{
            "condor":[
                "v8.6.0"
            ]
        },
        "environment-variables":[
            {
                "name":"CONDOR_CONFIG",
                "value":"${VC3_ROOT_CONDOR}/etc/condor_config",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "condor-configure":{
        "versions":[
            {
                "version":"v8.6.0",
                "sources":[
                    {
                        "type":"generic",
                        "phony":1,
                        "recipe":[
                            "echo BROKEN FOR NOW",
                            "exit 1",
                            ": run as condor_master -dyn -f",
                            "if [ -z \"${VC3_CONDOR_CONFIG_OPTIONS}\" ]; then",
                            "export VC3_CONDOR_CONFIG_OPTIONS='--make-personal-condor --type=submit,manager,execute'",
                            "cat <<EOF",
                            "   No VC3_CONDOR_CONFIG_OPTIONS defined. Examples:",
                            "   export VC3_CONDOR_CONFIG_OPTIONS='--type=submit,manager --central-manager \\$(hostname -i)'",   
                            "   export VC3_CONDOR_CONFIG_OPTIONS='--type=submit --central-manager somewhere.net'",
                            "   export VC3_CONDOR_CONFIG_OPTIONS='--type=execute --central-manager somewhere.net'",
                            "   using: ${VC3_CONDOR_CONFIG_OPTIONS}",
                            "EOF",
                            "fi",
                            "if [ -z \"${VC3_CONDOR_PASSWORD}\" ]; then",
                            "cat <<EOF",
                            "   [Warning]: No VC3_CONDOR_PASSWORD defined.",
                            "   Condor will use the default authentication protocols (FS, CLAIMTOBE).",
                            "EOF",
                            "elif [ ! -f \"${VC3_CONDOR_PASSWORD}\" ]; then",
                            "   echo \"[Error]: Could not find:  \"${VC3_CONDOR_PASSWORD}\"\"",
                            "   exit 1",
                            "fi",
                            "export CONDOR_CONFIG=${VC3_CONDOR_LOCAL_DIR}/etc/condor_config",
                            ": rm -f ${CONDOR_CONFIG}",
                            "cd ${VC3_ROOT_CONDOR}",
                            "if [ ! -f ${VC3_CONDOR_LOCAL_DIR}/etc/condor_config.local ]; then",
                            "    echo SCHEDD_NAME = $$.$(hostname)    >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "    echo ALLOW_WRITE = \\*               >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "    if [ -n \"${VC3_CONDOR_PASSWORD}\" ]; then",
                            "       echo SEC_PASSWORD_FILE = ${VC3_CONDOR_PASSWORD}    >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_DEFAULT_AUTHENTICATION_METHODS = PASSWORD, FS   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_DAEMON_AUTHENTICATION = REQUIRED   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_ADVERTISE_STARTD_AUTHENTICATION = REQUIRED   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_ADVERTISE_STARTD_INTEGRITY = REQUIRED   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_ADVERTISE_STARTD_AUTHENTICATION_METHODS =  PASSWORD, FS   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_CLIENT_AUTHENTICATION_METHODS = PASSWORD, FS   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo ALLOW_ADVERTISE_STARTD = \\*   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo ALLOW_ADVERTISE_MASTER = \\*   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo ALLOW_ADVERTISE_SCHEDD = \\*   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "    fi",
                            "fi",
                            "if [ -f \"${CONDOR_CONFIG}\" ]; then",
                            "    ./condor_configure $(eval echo ${VC3_CONDOR_CONFIG_OPTIONS}) --overwrite",
                            "else",
                            "    ./condor_configure --install --local-dir=${VC3_CONDOR_LOCAL_DIR} $(eval echo ${VC3_CONDOR_CONFIG_OPTIONS}) --overwrite",
                            "fi",
                            ": condor_master -dyn -f -r 120"
                        ]
                    }
                ],
                "dependencies":{
                    "condor":[
                        "v8.6.0"
                    ],
                    "perl":[
                        "v5.10.0"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"CONDOR_CONFIG",
                        "value":"${VC3_ROOT_CONDOR}/etc/condor_config",
                        "absolute":1,
                        "clobber":1
                    }
                ]
            }
        ]
    },

    "condor":{
        "versions":[
            {
                "version":"v8.6.9",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat6",
                    "files":[
                        "condor-8.6.9-x86_64_RedHat6-stripped.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "mkdir -p ${VC3_PREFIX}/config",
                        "mkdir -p ${VC3_PREFIX}/log",
                        "mkdir -p ${VC3_PREFIX}/spool",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf condor-8.6.9-x86_64_RedHat6-stripped.tar.gz"
                    ]
                }
            },
            {
                "version":"v8.6.9",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat7",
                    "files":[
                        "condor-8.6.9-x86_64_RedHat7-stripped.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/var/condor/log",
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/var/condor/spool",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf condor-8.6.9-x86_64_RedHat7-stripped.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python $(python -m site --user-site)"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PATH"
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"sbin"
            }
        ]
    },

    "berkeley-db":{
        "versions":[
            {
                "version":"v6.2.23",
                "source":{
                    "type":"tarball",
                    "files":[
                        "db-6.2.23.tar.gz"
                    ],
                    "recipe":[
                        "cd build_unix",
                        "export CFLAGS=-fPIC",
                        "export CXXFLAGS=-fPIC",
                        "../dist/configure --prefix=${VC3_PREFIX} --enable-static --enable-shared --enable-compat185 --enable-dbm --enable-cxx",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "readline":{
        "versions":[
            {
                "version":"v6.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "readline-6.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "glib":{
        "versions":[
            {
                "version":"v2.18.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "glib-2.48.1.tar.gz"
                    ],
                    "preface":[
                        ": system pcre is not working! using internal",
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --with-python=${VC3_ROOT_PYTHON}/bin/python --with-pcre=internal"
                },
                "dependencies":{
                    "libffi":[
                        "v3.2.1"
                    ],
                    "gettext":[
                        "v0.19"
                    ],
                    "zlib":[
                        "v1.2"
                    ],
                    "pcre":[
                        "v8.13"
                    ],
                    "python":[
                        "v2.5"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "attr":{
        "versions":[
            {
                "version":"v2.4.47",
                "source":{
                    "type":"configure",
                    "files":[
                        "attr-2.4.47.src.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--enable-static --enable-shared",
                    "postface":[
                        "make install-dev install-lib",
                        "chmod -v 755 ${VC3_PREFIX}/lib/libattr.so"
                    ]
                },
                "dependencies":{
                    "gettext":[
                        "v0.19"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "libffi":{
        "versions":[
            {
                "version":"v3.2.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "libffi-3.2.1.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --enable-portable-binary",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib64"
                    },
                    {
                        "name":"LIBRARY_PATH",
                        "value":"lib64"
                    }
                ],
                "environment-autovars":[
                    "PKG_CONFIG_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "pcre":{
        "versions":[
            {
                "version":"v8.43",
                "source":{
                    "type":"configure",
                    "files":[
                        "pcre-8.43.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --disable-shared --enable-unicode-properties --enable-pcre16 --enable-pcre32 ",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "fuse":{
        "versions":[
            {
                "version":"v2.9.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "fuse-2.9.3.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib  --enable-lib --disable-util",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "perl":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"perl",
                    "auto-version":[
                        "perl -e  'print(\"VC3_VERSION_SYSTEM: $^V\\n\");'"
                    ],
                    "recipe":[
                        "perl -MConfig -e '$cmd = $Config{perlpath}; $cmd =~ s:(.*)\/bin/perl:\\1:; print \"VC3_ROOT_SYSTEM: $cmd\n\"'"
                    ]
                }
            },
            {
                "version":"v5.24",
                "source":{
                    "type":"tarball",
                    "files":[
                        "perl-5.24.0.tar.gz"
                    ],
                    "recipe":[
                        "CFLAGS='-m64 -mtune=nocona' ./Configure -Dprefix=${VC3_PREFIX} -Dcc=${CC} -des -A ccflags=-fPIC make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/local_modules"
                    ]
                }
            }
        ],
        "dependencies":{
            "perl-vc3-modules":[
                "v0.5.0"
            ]
        },
        "environment-variables":[
            {
                "name":"PATH",
                "value":"bin"
            },
            {
                "name":"PERL5LIB",
                "value":"${VC3_MODULES_PERL}/lib/perl5",
                "absolute":1
            },
            {
                "name":"PERL5LIB",
                "value":"lib/perl5/site_perl/${VC3_VERSION_FULL_PERL}"
            },
            {
                "name":"PERL_MB_OPT", 
                "value":"--install_base ${VC3_MODULES_PERL}",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"PERL_MM_OPT", 
                "value":"INSTALL_BASE=${VC3_MODULES_PERL}",
                "clobber":1,
                "absolute":1 
            },
            {
                "name":"PATH",
                "value":"${VC3_MODULES_PERL}/bin",
                "absolute":1
            }
        ]
    },

    "perl-vc3-modules":{
        "versions":[
            {
                "version":"v0.5.0",
                "source":{
                    "type":"generic",
                    "files":[
                        "perl-vc3-modules-005.tar"
                    ],
                    "recipe":[
                        ": cpanm --force -L none --save-dists /path/ --scandeps PACKAGE", 
                        ": orepan2-indexer /path/",
                        "local_cpan=${VC3_ROOT}/${VC3_MACHINE_TARGET}/perl_local_modules/local_cpan",
                        "mkdir -p ${local_cpan}",
                        "tar -C ${local_cpan} -xf perl-vc3-modules-005.tar"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_MODULES_PERL", 
                "value":"${VC3_ROOT}/${VC3_MACHINE_TARGET}/perl_local_modules",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"VC3_MODULES_PERL_LOCAL_CPAN", 
                "value":"${VC3_MODULES_PERL}/local_cpan",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"PATH",
                "value":"${VC3_MODULES_PERL}/bin",
                "absolute":1
            }
        ]
    },

    "perl-local-lib":{
        "versions":[
            {
                "version":"v2.19",
                "source":{
                    "type":"tarball",
                    "files":[
                        "local-lib-2.000019.tar.gz"
                    ],
                    "recipe":[
                        "perl Makefile.PL --bootstrap=${VC3_MODULES_PERL}",
                        "make install"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ]
                }
            }
        ]
    },

    "perl-cpanminus":{
        "tags":["perl packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.7",
                "source":{
                    "type":"generic",
                    "files":[
                        "cpanminus-1.7.distribution"
                    ],
                    "recipe":[
                        "chmod 755 cpanminus-1.7.distribution",
                        "cp cpanminus-1.7.distribution ${VC3_MODULES_PERL}/bin/cpanm"
                    ]
                },
                "dependencies":{
                    "perl-local-lib":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "python-pip":{
        "tags":["python packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v9.0.1",
                "phony":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "pip-9.0.1.distribution"
                    ],
                    "recipe":[
                        "python pip-9.0.1.distribution --user --ignore-installed",
                        ": patch pip otherwise the lenght of the hash-bang is too long and fails. both after install and update",
                        "sed -i ~/.local/bin/pip -e '1s:.*:#! /usr/bin/env python:'",
                        "pip install --user -U pip",
                        "sed -i ~/.local/bin/pip -e '1s:.*:#! /usr/bin/env python:'",

                        "pip install --user -U wheel",
                        "pip install --user -U setuptools",
                        ": patch wheel otherwise the lenght of the hash-bang is too long and fails.",
                        "wheel=\"${VC3_INSTALL_USER_HOME}/.local/lib/python${VC3_VERSION_PYTHON}/site-packages/pip\"",
                        "if [ -d \"${wheel}/_internal\" ]; then",
                        "   wheel=\"$wheel/_internal/wheel.py\"",
                        "else",
                        "   wheel=\"$wheel/wheel.py\"",
                        "fi",
                        "sed -i \"$wheel\" -e \"/^def fix_script/,/return True/s:firstline =.*:firstline = '#! /usr/bin/env python':\""
                    ]
                },
                "dependencies":{
                    "python":[
                        "v2.6"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/bin",
                "absolute":1
            },
            {
                "name":"PYTHONUSERBASE",
                "value":"${VC3_INSTALL_USER_HOME}/.local",
                "absolute":1
            }
        ]
    },

    "python":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"python",
                    "auto-version":[
                        "python -c 'import sys; print \"VC3_VERSION_SYSTEM: %d.%d.%d\" % (sys.version_info[0], sys.version_info[1], sys.version_info[2])'"
                    ],
                    "recipe":[
                        "cmd=$(which python)",
                        "base=$(echo $cmd | sed -r -n -e 's:(^.*/)bin/python$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                }
            },
            {
                "version":"v2.7.14",
                "source":{
                    "type":"tarball",
                    "files":[
                        "Python-2.7.14.tgz"
                    ],
                    "recipe":[
                        "sed -i Modules/Setup.dist -e \"217s:.*:_ssl _ssl.c -DUSE_SSL -I${VC3_ROOT_OPENSSL}/include -I${VC3_ROOT_OPENSSL}/include/openssl -L${VC3_ROOT_OPENSSL}/lib -lssl -lcrypto:\"",
                        "sed -i Modules/Setup.dist -e \"468s:.*:zlib zlibmodule.c -I${VC3_ROOT_ZLIB}/include -L${VC3_ROOT_ZLIB}/lib -Wl,-Bstatic -lz -Wl,-Bdynamic:\"",
                        ": using shared library, and instead of using LD_LIBRARY_PATH, we set it with rpath",
                        "LDFLAGS='-Wl,-rpath=\\$$ORIGIN/../lib' ./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-shared --enable-unicode=ucs4",
                        "make",
                        "make install",
                        "ln -s ${VC3_PREFIX}/bin/pydoc{,2}"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.2.8"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "libffi":[
                            "v3.2.1"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"C_INCLUDE_PATH",
                "value":"${VC3_ROOT_PYTHON}/include/python${VC3_VERSION_PYTHON}",
                "absolute":1
            }
        ]
    },

    "python3":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"python3",
                    "auto-version":[
                        "python3 -c 'import sys; print(\"VC3_VERSION_SYSTEM: %d.%d.%d\" % (sys.version_info[0], sys.version_info[1], sys.version_info[2]))'"
                    ],
                    "recipe":[
                        "cmd=$(which python3)",
                        "base=$(echo $cmd | sed -E -n -e 's:(^.*/)bin/python3$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                }
            },
            {
                "version":"v3.6.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "Python-3.6.4.tgz"
                    ],
                    "recipe":[
                        "sed -i Modules/Setup.dist -e \"217s:.*:_ssl _ssl.c -DUSE_SSL -I${VC3_ROOT_OPENSSL}/include -I${VC3_ROOT_OPENSSL}/include/openssl -L${VC3_ROOT_OPENSSL}/lib -lssl -lcrypto:\"",
                        "sed -i Modules/Setup.dist -e \"468s:.*:zlib zlibmodule.c -I${VC3_ROOT_ZLIB}/include -L${VC3_ROOT_ZLIB}/lib -Wl,-Bstatic -lz -Wl,-Bdynamic:\"",
                        ": using shared library, and instead of using LD_LIBRARY_PATH, we set it with rpath",
                        "LDFLAGS='-Wl,-rpath=\\$$ORIGIN/../lib' ./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-shared --enable-unicode=ucs4",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.2.8"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "libffi":[
                            "v3.2.1"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"C_INCLUDE_PATH",
                "value":"${VC3_ROOT_PYTHON3}/include/python${VC3_VERSION_PYTHON3}",
                "absolute":1
            }
        ]
    },

    "python3-pip":{
        "tags":["python packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v9.0.1",
                "phony":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "pip-9.0.1.distribution"
                    ],
                    "recipe":[
                        ": updating pip3 is broken for now",
                        "if pip3 --help; then exit 0; fi",
                        "python3 pip-9.0.1.distribution --user --ignore-installed",
                        ": patch pip otherwise the lenght of the hash-bang is too long and fails. both after install and update",
                        "sed -i ~/.local/bin/pip3 -e '1s:.*:#! /usr/bin/env python3:'",
                        "pip3 install --user -U pip",
                        "sed -i ~/.local/bin/pip3 -e '1s:.*:#! /usr/bin/env python3:'",
                        "pip3 install --user -U wheel",
                        "pip3 install --user -U setuptools",
                        ": patch pip and wheel, otherwise the lenght of the hash-bang is too long and fails.",
                        "sed -i ~/.local/lib/python${VC3_VERSION_PYTHON3}/site-packages/pip/_internal/wheel.py -e \"/^def fix_script/,/return True/s:firstline =.*:firstline = b'#! /usr/bin/env python3':\""
                    ]
                },
                "dependencies":{
                    "python3":[
                        "v3.0"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/bin",
                "absolute":1
            },
            {
                "name":"PYTHONUSERBASE",
                "value":"${VC3_INSTALL_USER_HOME}/.local",
                "absolute":1
            }
        ]
    },

    "zlib": {
        "versions":[
            {
                "version":"v1.2.8",
                "source":{
                    "type":"configure",
                    "files":[
                        "zlib-1.2.8.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --static",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "gsl": {
        "versions":[
            {
                "version":"v2.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "gsl-2.1.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --disable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "gettext": {
        "versions":[
            {
                "version":"v0.19.8",
                "source":{
                    "type":"configure",
                    "files":[
                        "gettext-0.19.8.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "mash": {
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.1",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "mash-Linux64-v1.1.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf mash-Linux64-v1.1.tar.gz"
                    ]
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },


    "xrootd": {
        "tags":["data transfer tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v4.8.4",
                "source":{
                    "type":"cmake",
                    "files":[
                        "xrootd-4.8.4.tar.gz"
                    ],
                    "mirrors":[
                        "http://xrootd.org/download/v4.8.4/"
                    ]                    
                }
            },
            {
                "version":"v3.0.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "xrootd-3.0.2.tar.gz"
                    ],
                    "recipe":[
                        "sed -i -e'14s/.*/#include <fcntl.h>/' src/XrdOss/XrdOssAio.cc",
                        "sed -i -e'25s/.*/#define R__SSL_GE_098 yes/' src/XrdCrypto/XrdCryptosslAux.hh",
                        "./configure.classic --no-arch-subdirs --enable-posix --enable-pwd --enable-ssl --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            }
        ],
        "dependencies":{
            "gcc-cplusplus":[
                "v4.4"
            ],
            "perl":[
                "v5.10"
            ],
            "zlib":[
                "v1.2"
            ],
            "fuse":[
                "v2.9"
            ]
        },
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "irods":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.0",
                "source":{
                    "type":"tarball",
                    "files":[
                        "irods3.0.tgz"
                    ],
                    "recipe":[
                        "mv * ${VC3_PREFIX}",
                        "cd ${VC3_PREFIX}",
                        "if [ \"$INSIDE_CONTAINER\" = yes ]; then",
                        "   sed -i -e '149d' scripts/perl/configure.pl",
                        "fi",
                        "if perl -e \"$VC3_VERSION_GCC >= 5 ? exit 0 : exit 1\"; then",
                        "export LDFLAGS=\"-pthread\"",
                        "fi",
                        "./scripts/configure",
                        "make"
                    ],
                    "dependencies":{
                        "help2man":[
                            "v1.0.0"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"PATH",
                        "value":"clients/icommands/bin"
                    },
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib/core/obj"
                    },
                    {
                        "name":"C_INCLUDE_PATH",
                        "value":"lib/api/include"
                    },
                    {
                        "name":"CPLUS_INCLUDE_PATH",
                        "value":"lib/api/include"
                    }
                ]
            }
        ]
    },

    "help2man":{
        "versions":[
            {
                "version":"v1.43.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "help2man-1.43.3.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "perl-text-soundex":{
        "versions":[
            {
                "version":"v3.0",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Text::Soundex"
                    ]
                }
            }
        ]
    },

    "perl-bioperl":{
        "tags":["bioinformatics tools", "perl packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.6",
                "source":{
                    "type":"cpan",
                    "files":[
                        "CJFIELDS/BioPerl-1.6.924.tar.gz"
                    ]
                },
                "dependencies":{
                    "berkeley-db":[
                        "v6.0"
                    ],
                    "perl-DB_File":[
                        "v1.8"
                    ]

                }
            }
        ]
    },

    "perl-DB_File":{
        "versions":[
            {
                "version":"v1.8",
                "source":{
                    "type":"tarball",
                    "files":["DB_File-1.838.tar.gz"],
                    "recipe":[
                        "sed -i -e 's%^INCLUDE.*%INCLUDE = '${VC3_ROOT_BERKELEY_DB}'/include%;s%^LIB.*%LIB = '${VC3_ROOT_BERKELEY_DB}'/lib%' config.in",
                        "perl Makefile.PL --bootstrap=${VC3_MODULES_PERL}",
                        "make",
                        "make install"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ],
                    "berkeley-db":[
                        "v6.0"
                    ]
                }
            }
        ]
    },

    "perl-extutils-makemaker":{
        "versions":[
            {
                "version":"v7.24",
                "source":{
                    "type":"cpan",
                    "files":[
                        "ExtUtils::MakeMaker"
                    ]
                }
            }
        ]
    },

    "perl-dbi":{
        "versions":[
            {
                "version":"v1.6",
                "source":{
                    "type":"cpan",
                    "files":[
                        "DBI"
                    ]
                }
            }
        ]
    },

    "perl-file-which":{
        "versions":[
            {
                "version":"v1.2",
                "source":{
                    "type":"cpan",
                    "files":[
                        "File::Which"
                    ]
                }
            }
        ]
    },

    "perl-unsafe-signals":{
        "versions":[
            {
                "version":"v0.3",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Perl::Unsafe::Signals"
                    ]
                }
            }
        ]
    },

    "perl-bit-vector":{
        "versions":[
            {
                "version":"v7.4",
                "source":{
                    "type":"cpan",
                    "files":[
                        "STBEY/Bit-Vector-7.4.tar.gz"
                    ]
                }
            }
        ]
    },

    "perl-inline":{
        "versions":[
            {
                "version":"v0.8",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Inline"
                    ]
                }
            }
        ]
    },

    "perl-inline-c":{
        "versions":[
            {
                "version":"v0.76",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Inline::C"
                    ]
                }
            }
        ]
    },

    "perl-forks":{
        "versions":[
            {
                "version":"v0.36",
                "source":{
                    "type":"cpan",
                    "files":[
                        "forks"
                    ]
                }
            }
        ]
    },

    "perl-io-all":{
        "versions":[
            {
                "version":"v0.86",
                "source":{
                    "type":"cpan",
                    "files":[
                        "IO::All"
                    ]
                }
            }
        ]
    },

    "perl-dbd-sqlite":{
        "versions":[
            {
                "version":"v1.5",
                "source":{
                    "type":"cpan",
                    "files":[
                        "DBD::SQLite"
                    ]
                }
            }
        ]
    },

    "perl-want":{
        "versions":[
            {
                "version":"v0.29",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Want"
                    ]
                }
            }
        ]
    },

    "perl-lwp-simple":{
        "versions":[
            {
                "version":"v6.15",
                "source":{
                    "type":"cpan",
                    "files":[
                        "LWP::Simple"
                    ]
                }
            }
        ]
    },

    "hmmer":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "hmmer-3.1b2.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-mpi"
                },
                "dependencies":{
                    "openmpi":[
                        "v1.10"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "openmpi":{
        "tags":["compilation tools", "hpc"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.10",
                "source":{
                    "type":"configure",
                    "files":[
                        "openmpi-1.10.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-shared --disable-dependency-tracking --with-sge --disable-debug",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "ncbi-blast":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.2.28",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ]
                }
            },
            {
                "version":"v2.2.28",
                "source":{
                    "type":"configure",
                    "files":[
                        "ncbi-blast-2.2.28+-src.tar.gz"
                    ],
                    "preface":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ROOT_ZLIB} --with-pcre=${VC3_ROOT_PCRE} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_ROOT_SQLITE3} --without-debug"
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "pcre":[
                        "v8.34"
                    ],
                    "python":[
                        "v2.6"
                    ],
                    "perl":[
                        "v5.8"
                    ],
                    "sqlite3":[
                        "v3.13"
                    ],
                    "gcc-cplusplus":[
                        "v4.4"
                    ],
                    "make":[
                        "v3.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "ncbi-rmblastn":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.2.28",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "ncbi-rmblastn-2.2.28-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-rmblastn-2.2.28-x64-linux.tar.gz",
                        "cd ${VC3_PREFIX}/bin",
                        "for file in ${VC3_ROOT_NCBI_BLAST}/bin/*; do ln -s ../../../${file#${VC3_ROOT}/${VC3_MACHINE_TARGET}/}; done"
                    ]
                }
            },
            {
                "version":"v2.2.28",
                "source":{
                    "type":"configure",
                    "files":[
                        "rmblastn-2.2.28+-src.tar.gz"
                    ],
                    "preface":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ROOT_ZLIB} --with-pcre=${VC3_ROOT_PCRE} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_ROOT_SQLITE3} --without-debug"
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "pcre":[
                        "v8.34"
                    ],
                    "python":[
                        "v2.6"
                    ],
                    "perl":[
                        "v5.8"
                    ],
                    "ncbi-blast":[
                        "v2.2.28"
                    ],
                    "sqlite3":[
                        "v3.13"
                    ],
                    "gcc-cplusplus":[
                        "v4.4"
                    ],
                    "make":[
                        "v3.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "sqlite3":{
        "tags":["databases"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.13",
                "source":{
                    "type":"configure",
                    "files":[
                        "sqlite-autoconf-3130000.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "exonerate":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.2.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "exonerate-2.2.0.tar.gz"
                    ],
                    "preface":[
                        ": exonerate does not like parallel compilation",
                        "export MAKEFLAGS=-j1",
                        ": for old glibc we need to manually link librt",
                        "export LDFLAGS=-lrt"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-glib2 --enable-utilities",
                    "dependencies":{
                        "glib":[
                            "v2.0"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "snap":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2013.11.29",
                "source":{
                    "type":"tarball",
                    "files":[
                        "snap-2013-11-29.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "cp -af ${VC3_BUILD} ${VC3_PREFIX}/snap",
                        "cd ${VC3_PREFIX}/snap",
                        "sed -i -e '678s/h2->q_end/h1->q_end/;684s/h2->s_end/h1->s_end/' Zoe/zoeAlignment.c",
                        "sed -i -e 's/-Wall//;s/-Werror//' Makefile",
                        "sed -i -e 's/-Wall//;s/-Werror//' Zoe/Makefile",
                        "make"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.8"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"ZOE",
                        "value":"${VC3_ROOT_SNAP}/snap/Zoe",
                        "clobber":1,
                        "absolute":1
                    },
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_SNAP}/snap",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "repeatmasker":{
        "versions":[
            {
                "version":"v4.0.6",
                "source":{
                    "type":"manual-distribution",
                    "msg-manual-requirement":[
                        "RepeatMasker library have a restrictive distribution license, and have to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On http://www.girinst.org, click on 'Downloads'.",
                        "    2) Register for a free account.",
                        "    3) Download the most recent library repeatmaskerlibrary-YEARMONTDAY.tar.gz.",
                        "    4) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/repeatmaskerlibrary-LATEST.tar.gz.",
                        "    For example:",
                        "cp ~/Downloads/repeatmaskerlibrary-20150807.tar.gz ${VC3_DISTFILES}/manual-distribution/repeatmaskerlibrary-LATEST.tar.gz",
                        "    5) Try again '${VC3_COMMAND_LINE}'."],
                        "files":[
                            "repeatmaskerlibrary-LATEST.tar.gz"
                        ],
                        "recipe":[
                            "mkdir -p ${VC3_ROOT_REPEATMASKER_COMMON}",
                            "tar -C ${VC3_ROOT_REPEATMASKER_COMMON} -xpf repeatmaskerlibrary-LATEST.tar.gz",
                            "cd ${VC3_ROOT_REPEATMASKER_COMMON}",
                            "perl VC3_RepeatMasker-open-4-0-6.configure -re_exec_perl=${VC3_ROOT_PERL}/bin/perl -repeatmasker_dir=${VC3_ROOT_REPEATMASKER_COMMON} -trf_bin_path=${VC3_ROOT_TRF}/bin/trf -hmmer_bin_dir=${VC3_ROOT_HMMER}/bin -rmblast_bin_dir=${VC3_ROOT_NCBI_RMBLASTN}/bin -default_engine=rmblast"
                        ]
                },
                "dependencies":{
                    "repeatmasker-free":[
                        "v4.0.6"
                    ]
                }
            }
        ]
    },

    "repeatmasker-free":{
        "versions":[
            {
                "version":"v4.0.6",
                "source":{
                    "type":"generic",
                    "files":[
                        "RepeatMasker-open-4-0-6.tar.gz",
                        "VC3_RepeatMasker-open-4-0-6.configure"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_REPEATMASKER_COMMON}",
                        "tar -C ${VC3_ROOT_REPEATMASKER_COMMON} --strip-components=1 -xpf RepeatMasker-open-4-0-6.tar.gz",
                        "cp VC3_RepeatMasker-open-4-0-6.configure ${VC3_ROOT_REPEATMASKER_COMMON}/"
                    ]
                },
                "dependencies": {
                    "repeatmasker-common":[
                        "v4.0.6"
                    ],
                    "perl":[
                        "v5.8"
                    ],
                    "hmmer":[
                        "v3.1"
                    ],
                    "ncbi-blast":[
                        "v2.2.28"
                    ],
                    "ncbi-rmblastn":[
                        "v2.2.28"
                    ],
                    "trf":[
                        "v4.0.9"
                    ],
                    "perl-text-soundex":[
                        "v3.0"
                    ]
                }
            }
        ]
    },

    "repeatmasker-common":{
        "versions":[
            {
                "version":"v4.0.6",
                "source": {
                    "type":"generic",
                    "recipe":[
                        "echo setting variables..."
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"${VC3_ROOT_REPEATMASKER_COMMON}",
                "absolute":1
            },
            {
                "name":"LD_LIBRARY_PATH",
                "value":"${VC3_ROOT_REPEATMASKER_COMMON}/lib",
                "absolute":1
            }
        ]
    },

    "augustus":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.4",
                "source":{
                    "type":"generic",
                    "files":[
                        "augustus.2.4.src.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf augustus.2.4.src.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "make"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ],
                "environment-variables":[
                    {
                        "name":"AUGUSTUS_CONFIG_PATH",
                        "value":"config",
                        "clobber":1
                    }
                ]
            }
        ]
    },

    "trf":{
        "versions":[
            {
                "version":"v4.9",
                "source":{
                    "msg-manual-requirement":[
                        "Tandem Repeats Finder (trf) has a restrictive distribution license, and has to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On https://tandem.bu.edu/trf/trf.html, click on 'Download Your Own Copy of the Program'.",
                        "    2) Download the version appropiate for your machine.",
                        "      (Your machine is a ${VC3_MACHINE_OS}-${VC3_MACHINE_ARCH}, GLIBC version ${VC3_MACHINE_GLIBC_VERSION})",
                        "    3) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/trf409",
                        "    For example:",
                        "cp ~/Downloads/trf409.legacylinux64 ${VC3_DISTFILES}/manual-distribution/trf409",
                        "    4) Try again '${VC3_COMMAND_LINE}'."],
                        "type":"manual-distribution",
                        "files":[
                            "trf409"
                        ],
                        "recipe":[
                            "mkdir -p ${VC3_PREFIX}/bin",
                            ": -L to ensure real files are copied, and not only symlinks",
                            "cp -L trf409 ${VC3_PREFIX}/bin/trf",
                            "chmod 755 ${VC3_PREFIX}/bin/trf"
                        ]
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "maker":{
        "versions":[
            {
                "version":"v2.31",
                "source":{
                    "type":"manual-distribution",
                    "msg-manual-requirement":[
                        "maker has a restrictive distribution license, and has to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On http://www.yandell-lab.org/software/maker.html, click on 'Registration Page'.",
                        "    2) Fill the form and click on 'Submit and Download MAKER.",
                        "    3) Download maker-2.31.8.tgz.",
                        "    4) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/maker-2.31.8.tgz",
                        "    For example:",
                        "cp ~/Downloads/maker-2.31.8.tgz ${VC3_DISTFILES}/manual-distribution/",
                        "    5) Try again '${VC3_COMMAND_LINE}'."],
                        "files":[
                            "maker-2.31.8.tgz"
                        ],
                        "recipe":[
                            "mkdir -p ${VC3_PREFIX}",
                            "tar -C ${VC3_PREFIX} --strip-components=1 -xpf maker-2.31.8.tgz",
                            "cd ${VC3_PREFIX}/src",
                            ": y to activate MPI support",
                            "/bin/echo -e 'y\n\n' | perl Build.PL",
                            "./Build install",
                            "cd ${VC3_PREFIX}/bin",
                            "echo '#! /bin/sh' > maker_mpi",
                            "echo 'if [ -n \"$LD_PRELOAD\" ]; then' >> maker_mpi",
                            "echo ' LD_PRELOAD=${VC3_ROOT_OPENMPI}/lib/libmpi.so:${LD_PRELOAD} mpiexec $* maker' >> maker_mpi", 
                            "echo else >> maker_mpi",
                            "echo ' LD_PRELOAD=${VC3_ROOT_OPENMPI}/lib/libmpi.so mpiexec $* maker' >> maker_mpi", 
                            "echo fi >> maker_mpi",
                            "chmod 755 maker_mpi"
                        ]
                },
                "dependencies":{
                    "ncbi-blast":[
                        "v2.2.28"
                    ],
                    "snap":[
                        "v2013.11.29"
                    ],
                    "repeatmasker":[
                        "v4.0.6"
                    ],
                    "exonerate":[
                        "v2.2"
                    ],
                    "augustus":[
                        "v2.4"
                    ],
                    "openmpi":[
                        "v1.10"
                    ],
                    "perl-bioperl":[
                        "v1.6"
                    ],
                    "perl-dbi":[
                        "v1.6"
                    ],
                    "perl-dbd-sqlite":[
                        "v1.5"
                    ],
                    "perl-want":[
                        "v0.29"
                    ],
                    "perl-lwp-simple":[
                        "v6.15"
                    ],
                    "perl-file-which":[
                        "v1.2"
                    ],
                    "perl-unsafe-signals":[
                        "v0.3"
                    ],
                    "perl-bit-vector":[
                        "v7.4"
                    ],
                    "perl-inline":[
                        "v0.8"
                    ],
                    "perl-inline-c":[
                        "v0.76"
                    ],
                    "perl-forks":[
                        "v0.36"
                    ],
                    "perl-io-all":[
                        "v0.86"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_MAKER}/bin",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "findutils":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"find"
                }
            },
            {
                "version":"4.4.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "findutils-x86_64-4.4.2-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v4.6.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "findutils-4.6.0.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "maker-example-ecoli-01":{
        "versions":[
            {
                "version":"v1",
                "source":{
                    "type":"generic",
                    "files":[
                        "maker-example-ecoli-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/maker-example-ecoli-01",
                        "tar -C ${VC3_INSTALL_USER_HOME}/maker-example-ecoli-01 --strip-components=1 -xpf maker-example-ecoli-01.tar.gz"
                    ]
                },
                "dependencies":{
                    "maker":[
                        "v2.31"
                    ]
                }
            }
        ]
    },

    "namd":{
        "versions":[
            {
                "version":"v2.12.0",
                "source":{
                    "type":"manual-distribution",
                    "msg-manual-requirement":[
                        "NAMD has a restrictive distribution license, and has to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On http://www.ks.uiuc.edu/Research, click on 'Sofware/NAMD/Download'.",
                        "    3) Click 'Source code' on the most recent stable release.",
                        "    2) Register for a free account.",
                        "    3) Download the most recent stable release.",
                        "    4) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/NAMD_Source.tar.gz.",
                        "    For example:",
                        "cp ~/Downloads/NAMD_2.12_Source.tar.gz ${VC3_DISTFILES}/manual-distribution/NAMD_Source.tar.gz",
                        "    5) Try again '${VC3_COMMAND_LINE}'."],
                        "files":[
                            "NAMD_Source.tar.gz"
                        ],
                        "recipe":[
                            "tar -C ${VC3_PREFIX} --strip-components=1 -xpf NAMD_Source.tar.gz",
                            "cd ${VC3_PREFIX}",
                            "./config Linux-x86_64-g++ --charm-arch mpi-linux-x86_64 --charm-base ${VC3_ROOT_CHARM} --tcl-prefix ${VC3_ROOT_TCL} --fftw-prefix ${VC3_ROOT_FFTW} --python-prefix ${VC3_ROOT_PYTHON}",
                            "cd Linux-x86_64-g++",
                            "make"
                        ]
                },
                "dependencies":{
                    "openmpi":[
                        "v1.10"
                    ],
                    "charm":[
                        "v6.7.1"
                    ],
                    "fftw":[
                        "v3.3.6"
                    ],
                    "tcl":[
                        "v8.5.9"
                    ],
                    "python":[
                        "v2.6.0"
                    ]
                },
                "environment-variables":
                [
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_NAMD}/Linux-x86_64-g++",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "charm":{
        "tags":["compilation tools", "hpc"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v6.7.1",
                "source":{
                    "type":"generic",
                    "files":[
                        "charm-6.7.1.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf charm-6.7.1.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "env MPICXX=mpicxx ./build charm++ mpi-linux-x86_64 --with-production"
                    ]
                },
                "dependencies":{
                    "openmpi":[
                        "v1.10"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"CHARM_BASE",
                        "value":"$VC3_ROOT_CHARM/mpi-linux-x86_64",
                        "absolute":1,
                        "clobber":1
                    },
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/bin",
                        "absolute":1
                    },
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/lib",
                        "absolute":1
                    },
                    {
                        "name":"CPLUS_INCLUDE_PATH",
                        "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/include",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "tcl":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v8.5.9",
                "source":{
                    "type":"configure",
                    "files":[
                        "tcl8.5.9-src.tar.gz"
                    ],
                    "preface":[
                        "cd unix"
                    ],
                    "options":"--enable-threads --enable-64bit",
                    "postface":[
                        "ln -s tclsh8.5 ${VC3_PREFIX}/bin/tclsh"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "fftw":{
        "versions":[
            {
                "version":"v3.3.6",
                "source":{
                    "type":"configure",
                    "files":[
                        "fftw-3.3.6-pl2.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--enable-openmp --enable-mpi --enable-shared --enable-float",
                    "dependencies":{
                        "openmpi":[
                            "v1.10"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "octave":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v4.2.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "octave-4.2.1.tar.gz"
                    ],
                    "options":"--prefix ${VC3_PREFIX} --disable-java --with-qhull-includedir=${VC3_ROOT_QHULL}/include --with-qhull-libdir=${VC3_ROOT_QHULL}/lib --with-z-includedir=${VC3_ROOT_ZLIB}/include --with-z-libdir=${VC3_ROOT_ZLIB}/lib  --with-hdf5-includedir=${VC3_ROOT_HDF5}/include --with-hdf5-libdir=${VC3_ROOT_HDF5}/lib --with-fftw3-includedir=${VC3_ROOT_FFTW}/include --with-fftw3-libdir=${VC3_ROOT_FFTW}/lib --with-fftw3f-includedir=${VC3_ROOT_FFTW}/include --with-fftw3f-libdir=${VC3_ROOT_FFTW}/lib --with-glpk-includedir=${VC3_ROOT_GLPK}/include --with-glpk-libdir=${VC3_ROOT_GLPK}/lib --with-curl-includedir=${VC3_ROOT_CURL}/include --with-curl-libdir=${VC3_ROOT_CURL}/lib --without-x --without-opengl --without-qt --without-fltk --with-blas=${VC3_ROOT_LAPACK}/lib64/libblas.so --with-lapack=${VC3_ROOT_LAPACK}/lib64/liblapack.so --with-qrupdate-includedir=${VC3_ROOT_QRUPDATE}/include --with-qrupdate-libdir=${VC3_ROOT_QRUPDATE}/lib --with-arpack-includedir=${VC3_ROOT_ARPACK}/includedir --with-arpack-libdir=${VC3_ROOT_ARPACK}/lib --with-openssl --disable-readline"
                },
                "dependencies":{
                    "qhull":[
                        "v7.2"
                    ],
                    "zlib":[
                        "v1.2"
                    ],
                    "hdf5":[
                        "v1.8"
                    ],
                    "fftw":[
                        "v3.3"
                    ],
                    "glpk":[
                        "v4.61"
                    ],
                    "curl":[
                        "v7.53"
                    ],
                    "lapack":[
                        "v3.7"
                    ],
                    "qrupdate":[
                        "v1.2"
                    ],
                    "arpack":[
                        "v3.4"
                    ],
                    "pcre":[
                        "v8.39"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "qrupdate":{
        "tags":["numerical methods tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.2.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "qrupdate-1.1.2.tar.gz"
                    ],
                    "recipe":[
                        "sed -i Makeconf -e 's:^BLAS=-lblas.*:BLAS=-L${VC3_ROOT_LAPACK}/lib -lblas:'",
                        "sed -i Makeconf -e 's:^LAPACK=-llapack.*:LAPACK=-L${VC3_ROOT_LAPACK}/lib64 -llapack:'",
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make lib",
                        "make PREFIX=${VC3_PREFIX} install"
                    ]
                },
                "dependencies":{
                    "lapack":[
                        "v3.7"
                    ]
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "hdf5":{
        "tags":["data management tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.8.18",
                "source":{
                    "type":"cmake",
                    "files":[
                        "hdf5-1.8.18.tar.gz"
                    ],
                    "options":"-DCMAKE_C_FLAGS=-fPIC -DCMAKE_Fortran_FLAGS=-fPIC",
                    "dependencies":{
                        "openmpi":[
                            "v1.10"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "qhull":{
        "tags":["numerical methods tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.2.0",
                "source":{
                    "type":"cmake",
                    "files":[
                        "qhull-2015-src-7.2.0.tgz"
                    ],
                    "options":"-DCMAKE_Fortran_FLAGS=-fPIC -DCMAKE_C_FLAGS=-fPIC"
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "glpk":{
        "versions":[
            {
                "version":"v4.61.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "glpk-4.61.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --with-pic",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "arpack":{
        "tags":["numerical methods libraries"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.4.0",
                "source":{
                    "type":"tarball",
                    "files":[
                        "arpack-ng-3.4.0.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p build",
                        "cd build",
                        "cmake -DMPI=ON -DBLAS_LIBRARIES=${VC3_ROOT_LAPACK} -DLAPACK_LIBRARIES=${VC3_ROOT_LAPACK} -DCMAKE_Fortran_FLAGS=-fPIC -DCMAKE_C_FLAGS=-fPIC ..",
                        "make",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "cp *.a ${VC3_PREFIX}/lib"
                    ],
                    "dependencies":{
                        "cmake":[
                            "v3.0"
                        ],
                        "openmpi":[
                            "v1.10"
                        ],
                        "lapack":[
                            "v3.7.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "lapack":{
        "tags":["numerical methods libraries"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.7.0",
                "source":{
                    "type":"tarball",
                    "files":[
                        "lapack-3.7.0.tgz"
                    ],
                    "recipe":[
                        "mkdir build-static",
                        "cd build-static",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=RELEASE ..",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make install",
                        "cd ..",
                        "mkdir build-shared",
                        "cd build-shared",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=ON ..",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/include",
                        "cp ../LAPACKE/include/* ${VC3_PREFIX}/include"
                    ],
                    "dependencies":{
                        "cmake":[
                            "3.0.0"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib64"
                    },
                    {
                        "name":"PKG_CONFIG_PATH",
                        "value":"lib64/pkgconfig"
                    },
                    {
                        "name":"C_INCLUDE_PATH",
                        "value":"include"
                    }
                ]
            }
        ]
    },

    "openblas":{
        "tags":["numerical methods libraries"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v0.2.19",
                "source":{
                    "type":"tarball",
                    "files":[
                        "openblas-0.2.19.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make PREFIX=${VC3_PREFIX} install"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "musl":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.1.15",
                "source":{
                    "type":"tarball",
                    "files":[
                        "musl-1.1.15.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} x86_64",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "musl-zlib": {
        "versions":[
            {
                "version":"v1.2.8",
                "source":{
                    "type":"configure",
                    "files":[
                        "zlib-1.2.8.tar.gz"
                    ],
                    "preface":[
                        "export CC=musl-gcc CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --static"
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ],
        "dependencies":{
            "musl":[
                "v1.0"
            ]
        },
        "environment-variables":[
            {
                "name":"CC",
                "value":"musl-gcc",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "cctools-statics":{
        "versions":[
            {
                "version":"v7.0.9",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "cctools-statics-7.0.9.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-statics-*.tar.gz"
                    ]
                }
            },
            {
                "version":"v7.0.6",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cctools-7.0.6-source.tar.gz"
                    ],
                    "recipe":[
                        "CFLAGS=-D__MUSL__ CC=musl-gcc ./configure --prefix ${VC3_PREFIX} --without-system-{doc,apps} --with-readline-path=no --static --with-zlib-path=${VC3_ROOT_MUSL_ZLIB}",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "musl-zlib":[
                            "v1.2.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "cctools-wq-worker":{
        "versions":[
            {
                "version":"v999.999.999",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "CCTOOLS_ND=${CCTOOLS_ND:-stable}",
                        "AFS=/afs/crc.nd.edu/group/ccl/software",
                        "CCLPLATFORM=$(${AFS}/cclplatform.sh)",
                        "CCLSOFTWARE=\"${AFS}/$CCLPLATFORM\"",
                        "mkdir -p $VC3_PREFIX/bin",
                        "cp \"${CCLSOFTWARE}/cctools/${CCTOOLS_ND}/bin/work_queue_worker\" $VC3_PREFIX/bin"
                    ]
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "vim":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"vim"
                }
            },
            {
                "version":"v7.3.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "vim-x86_64-7.3-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "singularity":{
        "tags":["containers"],
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"singularity"
                }
            },
            {
                "version":"2.5",
                "comment":"For Bridges",
                "prologue":[
                    "eval $(modulecmd sh load singularity)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(modulecmd sh load singularity)",
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which modulecmd"
                    ]
                }
            },
            {
                "version":"2.5",
                "comment":"For TACC-Stampede",
                "prologue":[
                    "eval $(/opt/apps/lmod/lmod/libexec/lmod sh load tacc-singularity)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(/opt/apps/lmod/lmod/libexec/lmod sh load tacc-singularity)",
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which /opt/apps/lmod/lmod/libexec/lmod"
                    ]
                }
            }
        ]
    },

    "docker":{
        "tags":["containers"],
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"docker"
                }
            }
        ]
    },

    "spack":{
        "tags":["software building"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v0.11",
                "phony":1,
                "prologue":[
                    ". ${SPACK_ROOT}/share/spack/setup-env.sh"
                ],
                "source":{
                    "type":"generic",
                    "phony":1,
                    "recipe":[
                        ". ${SPACK_ROOT}/share/spack/setup-env.sh",
                        "spack load || spack bootstrap"
                    ]
                }
            }
        ],
        "dependencies":{
            "spack-noconf":[
                "v0.11"
            ]
        }
    },

    "spack-noconf":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"spack"
                }
            },
            {
                "version":"0.11.2",
                "source":{
                    "type":"generic",
                    "files":[
                        "spack-0.11.2.tar.gz"
                    ],
                    "mirrors":[
                        "https://github.com/spack/spack/releases/download/v0.11.2/"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf spack-0.11.2.tar.gz"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"SPACK_ROOT",
                "value":"${VC3_ROOT_SPACK_NOCONF}",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "bc":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"bc"
                }
            },
            {
                "version":"v1.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "bc-x86_64-1.06-1.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "libfreetype": {
        "versions":[
            {
                "version":"v2.3.11",
                "source":{
                    "type":"configure",
                    "files":[
                        "freetype-2.3.11.src.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib64"
                }
            }
        ],
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            }
        ]
    },

    "libaio": {
        "versions":[
            {
                "version":"v0.3.107",
                "source":{
                    "type":"tarball",
                    "files":[
                        "libaio_0.3.107.src.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/lib64",
                        "make prefix=${VC3_PREFIX} libdir=${VC3_PREFIX}/lib64 install"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            }
        ]
    },

    "libmysql":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"5.6.20",
                "source":{
                    "type":"cmake",
                    "files":[
                        "mysql-5.6.20.tar.gz"
                    ],
                    "options":"-DCMAKE_INSTALL_PREFIX=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=Release -DWITH_READLINE=OFF"
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "gridftp":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"5.0.3",
                "source":{
                    "type":"tarball",
                    "files":[
                        "gt5.0.3-all-source-installer.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --with-flavor=gcc64 --with-gsiopensshargs='--enable-static-only'",
                        "make -j1 gridftp",
                        "make -j1 install"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "environment-modules":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"modulecmd",
                    "postface":[
                        "/bin/echo  -e '#!/bin/sh\neval $(${VC3_ROOT_ENVIRONMENT_MODULES}/bin/modulecmd sh \"$@\")\n' > ${VC3_PREFIX}/bin/module",
                        "chmod 755 ${VC3_PREFIX}/bin/module"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "c-build-environment":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"1.0",
                "type":"generic",
                "phony":1,
                "dependencies":{
                    "gcc":[
                        "v4.4"
                    ],
                    "make":[
                        "v3.5"
                    ]
                }
            }
        ]
    }
}

,
{
    "java-jre":{
        "tags":["programming languages"],
        "versions":[
            {
                "version":"v1.8.0_181",
                "source":{
                    "type":"tarball",
                    "files":[
                        "jre-8u181-linux-x64.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,lib}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r lib/* ${VC3_PREFIX}/lib/"
                    ] 
                }
            }
        ],
        "environment-variables":[
            {
                "name":"JAVA_HOME",
                "value":"${VC3_ROOT_JAVA_JRE}",
                "clobber":1,
                "absolute":1
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "java-jdk":{
        "tags":["programming languages"],
        "versions":[
            {
                "version":"v1.8.0_181",
                "source":{
                    "type":"tarball",
                    "files":[
                        "jdk-8u181-linux-x64.tar.gz"
                    ],
                    "recipe":[
                        "[ -d ${VC3_ROOT_JAVA_JRE} ] || exit 1",
                        "cp -r bin/* ${VC3_ROOT_JAVA_JRE}/bin/",
                        "cp -r lib/* ${VC3_ROOT_JAVA_JRE}/lib/"
                    ] 
                }
            }
        ],
        "dependencies":{
            "java-jre":[
                "v1.8"
            ]
        },
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "scala":{
        "tags":["programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.11.12",
                "dependencies":{
                    "java-jre":[
                        "v1.8.0"
                    ]
                },
                "source":{
                    "type":"tarball",
                    "files":[
                        "scala-2.11.12.tgz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,lib}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r lib/* ${VC3_PREFIX}/lib/"
                    ] 
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "maven":{
        "tags":["packager"],
        "show-in-list": 1,
        "versions":[
            {
                "version":"v3.6.0",
                "dependencies":{
                    "java-jdk":[
                        "v1.8"
                    ]
                },
                "source":{
                    "type":"generic",
                    "files":[
                        "apache-maven-3.6.0-bin.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf apache-maven-3.6.0-bin.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    }
}
,
{
    "spark":{
        "tags":["job execution engines"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.4.0",
                "source":{ 
                    "type":"tarball",
                    "files":[
                        "spark-2.4.0-bin-vc3-custom-spark.tgz",
                        "aws-jars-1.11.234.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,jars,sbin}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r jars/* ${VC3_PREFIX}/jars",
                        "cp -r sbin/* ${VC3_PREFIX}/sbin",
                        "tar -C ${VC3_PREFIX}/jars --strip-components=1 -xf aws-jars-*.tar.gz"
                    ]
                },
                "dependencies":{
                    "scala":[
                        "v2.11.12"
                    ],
                    "hadoop":[
                        "v3.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"sbin"
            },
            {
                "name":"SPARK_HOME",
                "value":"${VC3_ROOT_SPARK}",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"SPARK_DIST_CLASSPATH",
                "value":"${JAVA_HOME}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"SPARK_DIST_CLASSPATH",
                "value":"$(${VC3_ROOT_HADOOP}/bin/hadoop classpath)",
                "absolute":1
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },
    
    "spark-xrootd":{
        "tags":["xrootd plugin for spark"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0.0",
                "dependencies":{
                    "pyspark":[
                        "v2.4.0"
                    ],
                    "xrootd":[
                        "v4.8.4"
                    ]
                },
                "source":{
                    "type":"tarball",
                    "files":[
                        "spark-xrootd-plugins-v1.0.0.tar.gz"
                    ],
                    "recipe":[
                        "cp EOSfs.jar ${VC3_ROOT_SPARK}/jars",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "chmod 755 libjXrdCl.so",
                        "cp libjXrdCl.so ${VC3_PREFIX}/lib"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },
    
    "pyspark":{
        "tags":["python packages"],
        "show-in-list": 1,
        "versions":[
            {
                "version":"v2.4.0",
                "dependencies":{
                    "spark":[
                        "v2.4.0"
                    ],
                    "python":[
                        "v2.7"
                    ],
                    "python-pip":[
                        "v9"
                    ]
                },
                "source":{
                    "type":"generic",
                    "recipe":[
                       "pip install --user pyspark==2.4.0 matplotlib==2.1.0 histogrammar",
                       "ln -s $VC3_INSTALL_USER_HOME/.local/lib/python2.7/site-packages/pyspark/python $VC3_ROOT_SPARK"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PYTHONPATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/lib/python2.7/site-packages",
                "clobber":1,
                "absolute":1
            }
         ]
    },

    "minio":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2018.11.8",
                "source":{
                    "type":"generic",
                    "files":[
                        "minio"
                    ],
                    "mirrors":[
                        "https://dl.minio.io/server/minio/release/linux-amd64"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "chmod 755 minio",
                        "cp minio ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ],
        "dependencies":{
            "minio-client":[
                "v2.4.0"
            ]
        }
    },

    "minio-client":{
        "tags":["file system tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2018.11.8",
                "source":{
                    "type":"generic",
                    "files":[
                        "mc"
                    ],
                    "mirrors":[
                        "https://dl.minio.io/client/mc/release/linux-amd64"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "chmod 755 mc",
                        "cp mc ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "hadoop":{
        "tags":["filesystems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.1.1",
                "dependencies":{
                    "java-jre":[
                        "v1.8.0"
                    ]
                },
                "source":{
                    "type":"generic",
                    "files":[
                        "hadoop-3.1.1.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf hadoop-*tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"HADOOP_HOME",
                "value":"${VC3_ROOT_HADOOP}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"HADOOP_CONF_DIR",
                "value":"${VC3_ROOT_HADOOP}/etc/hadoop",
                "absolute":1,
                "clobber":1
            }
        ]
    }
}
,
{
  "tutorial": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v0.0.1",
        "source": {
          "type": "binary",
          "native": "x86_64",
          "files":[ "tutorial-0.1.tar.gz" ]
        }
      }
    ],
    "environment-variables":[
      {
        "name":"PATH",
        "value":"bin"
      }
    ]
  },
  "connect-client": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v1.0.1",
        "source": {
          "type": "binary",
          "native": "x86_64",
          "files": [ "connect_client-1.0.1.linux-x86_64.tar.gz" ]
        },
        "dependencies":{
          "python":[
            "v2.6"
          ]
        }        
      }
    ],
    "environment-variables":[
      {
        "name":"PYTHONPATH",
        "value":"${VC3_ROOT_CONNECT_CLIENT}/lib/python2.6/site-packages",
        "absolute":1
      }
    ],
    "environment-autovars":[
      "PATH"
    ]
  },
  "modules": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v1.0",
        "prologue": [
            "source /cvmfs/oasis.opensciencegrid.org/osg/modules/lmod/current/init/sh"
        ],
        "source": {
          "type": "generic",
          "dependencies":{
              "cvmfs":[
                  "v2.0"
              ],
              "tcl": [
                "v8.5.0"
              ]
          }
        }
      }

    ]
  },
  "osgconnect": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v0.0.1",
        "source": {
          "type": "generic",
          "prologue": [
              "source /cvmfs/oasis.opensciencegrid.org/osg/modules/lmod/current/init/sh"
          ],
          "dependencies":{
              "modules":[
                  "v1.0"
              ],
              "tutorial": [
                "v0.0.1"
              ],
              "connect-client": [
                "v1.0.1"
              ]
          }
        }
      }
    ]
  }
}
,
{
    "redhat":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/redhat"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos7.img"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos7"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos6.img"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos6"
                }
            }
        ]
    },

    "centos":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/redhat"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos7.img"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos7"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos6.img"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos6"
                }
            }
        ]
    },

    "ubuntu":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/ubuntu"
                }
            },
            {
                "version":"16",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-ubuntu16.04.img"
                }
            },
            {
                "version":"16.04",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:ubuntu16.04"
                }
            }
        ]
    },

    "debian":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/debian"
                }
            },
            {
                "version":"9.2",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-debian9.2.img"
                }
            },
            {
                "version":"9.2",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:debian9.2"
                }
            }
        ]
    },

    "opensuse":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/opensuse"
                }
            },
            {
                "version":"42.3",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-opensuse42.3.img"
                }
            },
            {
                "version":"42.3",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:opensuse42.3"
                }
            }
        ]
    }
}

,
{
    "parrot-static-binary":{
        "tags":["file systems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v7.0.11",
                "source":{
                    "type":"tarball",
                    "files":[
                        "parrot-static-v7.0.11.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv parrot_static_run ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "parrot-static-wrapper":{
        "tags":["file systems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v7.0.11",
                "wrapper":[
                    "parrot_static_run",
                    "--dynamic-mounts",
                    "-p", "\"${PARROT_HTTP_PROXY}\"",
                    "--cvmfs-repo-switching",
                    "$(echo ${VC3_PARROT_EXTRA_OPTIONS} | sed -e 's/:/ /g')",
                    "{}"
                ],
                "dependencies":{
                    "parrot-static-binary":[
                        "v6.2.6"
                    ]
                }
            }
        ]
    }
}
,
{
    "parsl":{
        "tags":["python packages", "parallel scripting"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"generic",
                    "auto-version":[
            "python3 -c 'import parsl.version; print(\"VC3_VERSION_SYSTEM: {}\".format(parsl.version.VERSION))'"
                    ]
                }
            },
            {
                "version":"v0.6.1",
                "source":{
                    "type":"generic",
                    "recipe":[
                        "pip3 install --user -U parsl==0.6.1"
                    ]
                },
                "dependencies":{
                    "python3":[
                        "v3.6"
                    ],
                    "python3-pip":[
                        "v9.0"
                    ]
                }
            }
        ]
    }
}
,
{
    "autopyfactory":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "[ -d autopyfactory ] || git clone https://github.com/PanDAWMS/autopyfactory.git",
                        "cd autopyfactory",
                        "rm -rf build",
                        "python setup.py install --user",
                        "mkdir -p ${VC3_SERVICES_HOME}/etc",
                        "cp -r etc ${VC3_SERVICES_HOME}/etc/autopyfactory"
                    ]
                },
                "dependencies":{
                    "vc3-infoservice":[
                        "v0.0.1"
                    ],
                    "condor":[
                        "v8.6"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"APF_HOME",
                "value":"${VC3_SERVICES_HOME}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"PATH",
                "value":"${APF_HOME}/bin",
                "absolute":1
            }
        ]
    },

    "vc3-factory-plugins":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "[ -d vc3-factory-plugins ] || git clone https://github.com/vc3-project/vc3-factory-plugins.git",
                        "cd vc3-factory-plugins",
                        "find . autopyfactory/plugins -name '*.py' | pax -r -w ${VC3_SERVICES_HOME}/lib/python${VC3_VERSION_PYTHON}/",
                        "cp -r etc/*.conf ${VC3_SERVICES_HOME}/etc"
                    ]
                },
                "dependencies":{
                    "autopyfactory":[
                        "v0.0.1"
                    ],
                    "pax":[
                        "v2016.0.0"
                    ]
                }
            }
        ]
    },

    "vc3-factory":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "dependencies":{
                    "vc3-factory-plugins":[
                        "v0.0.1"
                    ],
                    "condor-personal":[
                        "v8.6.0"
                    ]
                }
            }
        ]
    },

    "vc3-services-common-requirements":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "home=$(python -m site --user-base)",
                        "mkdir -p ${home}/lib/python",
                        "mkdir -p ${home}/bin",
                        "mkdir -p ${home}/etc",
                        "mkdir -p ${home}/var/log/vc3",
                        "pip install --user requests==2.7.0 cherrypy==3.2.2 pyYAML"
                    ]
                },
                "dependencies":{
                    "python":[
                        "v2.7.12"
                    ],
                    "python-pip":[
                        "v1.8"
                    ],
                    "git":[
                        "v2.12.0"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_SERVICES_HOME",
                "value":"$(python -m site --user-base)",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"PATH",
                "value":"${VC3_SERVICES_HOME}/bin",
                "absolute":1
            }
        ]
    },

    "vc3-pluginmanager":{
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd $VC3_INSTALL_USER_HOME/git",
                        "[ -d sdcc-pluginmanager ] || git clone https://github.com/bnl-sdcc/sdcc-pluginmanager.git",
                        "cd ${VC3_INSTALL_USER_HOME}/git/sdcc-pluginmanager",
                        "rm -rf build",
                        "python setup.py install --user"
                    ]
                },
                "dependencies":{
                    "vc3-services-common-requirements":[
                        "v0.0.1"
                    ]
                }
            }
        ]
    },

    "vc3-credible":{
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "[ -d credible ] || git clone https://github.com/vc3-project/credible.git",
                        "cd ${VC3_INSTALL_USER_HOME}/git/credible",
                        "rm -rf build",
                        "python setup.py install --user",
                        "credroot=${VC3_SERVICES_HOME}/var/credible/ssca/defaultca/intermediate",
                        "cp etc/credible.conf{,.sample} etc/openssl.cnf.*.template ${VC3_SERVICES_HOME}/etc",
                        "missing=0",
                        "[ -f $credroot/certs/localhost.cert.pem ]      || missing=1",
                        "[ -f $credroot/certs/ca-chain.cert.pem ]       || missing=1",
                        "[ -f $credroot/certs/VC3Admin.cert.pem ]       || missing=1",
                        "[ -f $credroot/private/localhost.keynopw.pem ] || missing=1",
                        "[ -f $credroot/private/VC3Admin.keynopw.pem ]  || missing=1",
                        "if [ \"$missing\" = 1 ]; then",
                        "   mkdir -p ${credroot}/private",
                        "   ${VC3_SERVICES_HOME}/bin/credible -c ${VC3_SERVICES_HOME}/etc/credible.conf -d hostcert localhost > /dev/null",
                        "   ${VC3_SERVICES_HOME}/bin/credible -c ${VC3_SERVICES_HOME}/etc/credible.conf certchain",

                        "   ${VC3_SERVICES_HOME}/bin/credible -c ${VC3_SERVICES_HOME}/etc/credible.conf -d usercert VC3Admin > /dev/null",
                        "fi"
                    ]
                },
                "dependencies":{
                    "vc3-services-common-requirements":[
                        "v0.0.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_SERVICES_CERTS_HOME",
                "value":"${VC3_SERVICES_HOME}/etc/ssca/certs",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_CERTS_CHAINFILE",
                "value":"${VC3_SERVICES_CERTS_HOME}/ca-chain.cert.pem",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_CERTS_CERTFILE",
                "value":"${VC3_SERVICES_CERTS_HOME}/VC3Admin.cert.pem",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_CERTS_KEYFILE",
                "value":"${VC3_SERVICES_CERTS_HOME}/private/VC3Admin.keynopw.pem",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "vc3-services":{
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "for S in vc3-infoservice vc3-client vc3-master; do",
                        "    [ -d $S ] || git clone https://github.com/vc3-project/${S}.git",
                        "    cd $S",
                        "    rm -rf build",
                        "    python setup.py install --user",
                        "    cp etc/*.conf ${VC3_SERVICES_HOME}/etc",
                        "    cd ..",
                        "done"
                    ]
                },
                "dependencies":{
                    "vc3-pluginmanager":[
                        "v0.0.1"
                    ],
                    "vc3-credible":[
                        "v0.0.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_SERVICES_INFOSERVICE_INFOHOST",
                "value":"localhost",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_INFOSERVICE_HTTP_PORT",
                "value":"20333",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_INFOSERVICE_HTTPS_PORT",
                "value":"20334",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "vc3-builder":{
        "tags":["environment tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "vc3-builder"
                    ],
                    "mirrors":[
                        "https://raw.githubusercontent.com/vc3-project/vc3-builder/master"
                    ],
                    "recipe":[
                        "chmod 755 vc3-builder",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp vc3-builder ${VC3_PREFIX}/bin"
                    ],
                    "dependencies":{
                        "wget":[
                            "v1.0.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    }
}

,
{
    "cvmfs-vc3ndcms":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(cvmfs2 -V | sed -r -e 's/CernVM-FS version\\s+([0-9]+\\.[0-9]+\\.[0-9]+)(\\.[0-9])?/\\1/')" 
                    ],
                    "prerequisites":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /\""
                    ]
                },
                "environment-variables":[
                    {
                        "name":"VC3_PARROT_EXTRA_OPTIONS",
                        "value":"--disable-service=cvmfs",
                        "absolute":1
                    }
                ]
            },
            {
                "version":"v2.4.0",
                "dependencies":{
                    "parrot-wrapper-vc3ndcms":[
                        "v2.4.0"
                    ]
                }
            }
        ]
    },

    "parrot-wrapper-vc3ndcms":{
        "tags":["file systems"],
        "versions":[
            {
                "version":"v2.4.0",
                "dependencies":{
                    "parrot-wrapper":[
                        "v6.2.10"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_PARROT_EXTRA_OPTIONS",
                "value":"--no-flock",
                "absolute":1
            },
            {
                "name":"VC3_PARROT_EXTRA_OPTIONS",
                "value":"-M /cvmfs/cms.cern.ch/SITECONF/local=/cvmfs/cms.cern.ch/SITECONF/T3_US_VC3_NotreDame",
                "absolute":1
            }
        ]
    },

    "oasis-wn-vc3ndcms":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.3",
                "native": "x86_64/redhat6",
                "prologue": [
                    "source /cvmfs/oasis.opensciencegrid.org/mis/osg-wn-client/3.3/current/el6-x86_64/setup.sh"
                ],
                "dependencies":{
                    "cvmfs-vc3ndcms":[
                        "v2.4.0"
                    ]
                }
            },
            {
                "version":"v3.3",
                "native": "x86_64/redhat7",
                "prologue": [
                    "source /cvmfs/oasis.opensciencegrid.org/mis/osg-wn-client/3.3/current/el7-x86_64/setup.sh"
                ],
                "dependencies":{
                    "cvmfs-vc3ndcms":[
                        "v2.4.0"
                    ]
                }
            }
        ],
        "dependencies":{
            "bc":[
                "v1.0.6"
            ],
            "libfreetype":[
                "v2.3.11"
            ],
            "libaio":[
                "v0.3.107"
            ]
        }
    }
}
,
{
    "redhat-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/redhat-release ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/redhat-release",
                        "version=$(cat ${INPUT} | sed -n -r -e 's/.*release ([0-9]+(\\.[0-9]+){0,2}).*/\\1/p')",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: redhat ${version}"
                    ]
                }
            }
        ]
    },

    "os-file-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/os-release ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/os-release",
                        "distro=$(cat ${INPUT} | sed -n -r '/^ID=/{s/^ID=\"?(.*)\"?/\\1/p;q}')",
                        "version=$(cat ${INPUT} | sed -n -r '/^VERSION_ID=/{s/^VERSION_ID=\"?([0-9]+(\\.[0-9]+){0,2}).*\"?/\\1/p;q}')",
                        "[ -n \"${distro}\" ]  || exit 1",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: ${distro} ${version}"
                    ]
                }
            }
        ]
    },

    "debian-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/debian_version ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/debian_version",
                        "version=$(cat ${INPUT} | sed -n -r -e 's/([0-9]+(\\.[0-9]+){0,2}).*/\\1/p')",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: debian ${version}"
                    ]
                }
            }
        ]
    },

    "lsb-exe-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "which lsb_release"
                    ],
                    "recipe":[
                        "distro=$(lsb_release -is | tr '[A-Z]' '[a-z]')",
                        "version=$(lsb_release -rs | sed -n -r -e 's/([0-9]+(\\.[0-9]+){0,2}).*/\\1/p')",
                        "[ -n \"${distro}\"  ] || exit 1",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: ${distro} ${version}"
                    ]
                }
            }
        ]
    },

    "lsb-file-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/lsb-release ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/lsb-release",
                        "[ -f ${INPUT} ] || exit 1",
                        "distro=$(cat ${INPUT} | sed -n -r '/^DISTRIB_ID=/{s/^DISTRIB_ID=\"?(.*)\"?/\\1/p;q}' | tr '[A-Z]' '[a-z]')",
                        "version=$(cat ${INPUT} | sed -n -r '/^DISTRIB_RELEASE=/{s/^DISTRIB_RELEASE=\"?([0-9]+(\\.[0-9]+){0,2}).*\"?/\\1/p;q}')",
                        "[ -n \"${distro}\" ] || exit 1",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: ${distro} ${version}"
                    ]
                }
            }
        ]
    }
}

]
